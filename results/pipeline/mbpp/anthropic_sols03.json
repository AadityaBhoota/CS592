{
    "MbppEval/56": "def rev(num):\n    reverse = 0\n    while num > 0:\n        digit = num % 10\n        reverse = reverse * 10 + digit\n        num //= 10\n    return num == 2 * reverse - 1\n",
    "MbppEval/83": "def get_Char(strr):\n    total_ascii = 0\n    for char in strr:\n        total_ascii += ord(char)\n    return chr(total_ascii % 26 + 97)\n",
    "MbppEval/62": "def smallest_num(xs):\n    smallest = xs[0]\n    for x in xs[1:]:\n        if x < smallest:\n            smallest = x\n    return smallest\n",
    "MbppEval/79": "def word_len(s):\n    return len(s) % 2 == 1\n",
    "MbppEval/20": "import math\n\ndef is_woodall(x):\n    \"\"\"\n    Check if the given number is a Woodall number.\n\n    Args:\n        x (int): The number to be checked.\n\n    Returns:\n        bool: True if x is a Woodall number, False otherwise.\n    \"\"\"\n    n = math.log2(x + 1) - 1\n    return x == 2 ** int(n) + int(n) - 1\n",
    "MbppEval/75": "def find_tuples(test_list, K):\n    result = []\n    for tup in test_list:\n        if all(x % K == 0 for x in tup):\n            result.append(tup)\n    return str(result)\n",
    "MbppEval/58": "def opposite_Signs(x, y):\n    if (x > 0 and y < 0) or (x < 0 and y > 0):\n        return True\n    else:\n        return False\n",
    "MbppEval/19": "def test_duplicate(arraynums):\n    unique_elements = set()\n    for num in arraynums:\n        if num in unique_elements:\n            return True\n        unique_elements.add(num)\n    return False\n",
    "MbppEval/8": "def square_nums(nums):\n    squared_nums = []\n    for num in nums:\n        squared_nums.append(num ** 2)\n    return squared_nums\n",
    "MbppEval/18": "NO_OF_CHARS = 256\n\ndef str_to_list(string, dirty_chars):\n    \"\"\"\n    Write a function to remove characters from the first string which are present in the second string.\n\n    Examples:\n    remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'\n    remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'\n    remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles'\n    \"\"\"\n    keep_chars = []\n    for char in string:\n        if char not in dirty_chars:\n            keep_chars.append(char)\n    return ''.join(keep_chars)\n",
    "MbppEval/66": "def pos_count(list_of_numbers):\n    positive_count = 0\n    for num in list_of_numbers:\n        if num > 0:\n            positive_count += 1\n    return positive_count\n",
    "MbppEval/74": "def is_samepatterns(colors, patterns):\n    if len(colors) != len(patterns):\n        return False\n\n    pattern_to_color = {}\n\n    for i in range(len(colors)):\n        pattern = patterns[i]\n        color = colors[i]\n\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n\n    return True\n",
    "MbppEval/3": "import math\n\ndef is_not_prime(n):\n    '''\n    Write a python function to identify non-prime numbers.\n\n    Examples:\n    is_not_prime(2) == False\n    is_not_prime(10) == True\n    is_not_prime(35) == True\n    '''\n    if n < 2:\n        return True\n    \n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return True\n    \n    return False\n",
    "MbppEval/2": "def similar_elements(test_tup1, test_tup2):\n    shared_elements = set(test_tup1) & set(test_tup2)\n    return tuple(shared_elements)\n",
    "MbppEval/17": "def square_perimeter(a):\n    return 4 * a\n",
    "MbppEval/61": "from collections import defaultdict\n\ndef count_Substrings(s):\n    digit_counts = defaultdict(int)\n    running_sum = 0\n\n    for char in s:\n        running_sum += int(char)\n        digit_counts[running_sum] += 1\n\n    return sum(digit_counts.values())\n",
    "MbppEval/65": "def recursive_list_sum(data_list):\n    total = 0\n    for item in data_list:\n        if isinstance(item, list):\n            total += recursive_list_sum(item)\n        else:\n            total += item\n    return total\n",
    "MbppEval/88": "import collections\n\ndef freq_count(list1):\n    return dict(collections.Counter(list1))\n",
    "MbppEval/7": "import re\n\ndef find_char_long(text):\n    words = re.findall(r'\\b\\w{4,}\\b', text)\n    return words\n",
    "MbppEval/9": "def find_Rotations(s):\n    if not s:\n        return 0\n    \n    doubled_s = s + s\n    for i in range(1, len(s)):\n        if s == doubled_s[i:i+len(s)]:\n            return i\n    \n    return len(s)\n",
    "MbppEval/16": "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
    "MbppEval/4": "import heapq as hq\n\ndef heap_queue_largest(nums, n):\n    heap = []\n    for num in nums:\n        hq.heappush(heap, num)\n        if len(heap) > n:\n            hq.heappop(heap)\n    return sorted(heap, reverse=True)\n",
    "MbppEval/69": "def is_sublist(l, s):\n    start = 0\n    for item in l:\n        if item == s[start]:\n            start += 1\n            if start == len(s):\n                return True\n    return False\n",
    "MbppEval/70": "def find_equal_tuple(Input):\n    \"\"\"\n    Write a function to find whether all the given tuples have equal length or not.\n\n    Examples:\n    find_equal_tuple([(11, 22, 33), (44, 55, 66)]) == 'All tuples have same length'\n    find_equal_tuple([(1, 2, 3), (4, 5, 6, 7)]) == 'All tuples do not have same length'\n    find_equal_tuple([(1, 2), (3, 4)]) == 'All tuples have same length'\n    find_equal_tuple([]) == 'Input should not be an empty list'\n    \"\"\"\n    if not Input:\n        return \"Input should not be an empty list\"\n\n    reference_length = None\n    for tup in Input:\n        if reference_length is None:\n            reference_length = len(tup)\n        elif len(tup) != reference_length:\n            return \"All tuples do not have same length\"\n\n    return \"All tuples have same length\"\n",
    "MbppEval/12": "def sort_matrix(M):\n    row_sums = [sum(row) for row in M]\n    row_tuples = [(row_sum, row) for row_sum, row in zip(row_sums, M)]\n    sorted_row_tuples = sorted(row_tuples)\n    sorted_matrix = [row for _, row in sorted_row_tuples]\n    return sorted_matrix\n",
    "MbppEval/6": "def differ_At_One_Bit_Pos(x, y):\n    xor_result = x ^ y\n    one_bit_count = bin(xor_result).count('1')\n    return one_bit_count == 1\n",
    "MbppEval/86": "def centered_hexagonal_number(n):\n    return n * (2 * n - 1)\n",
    "MbppEval/63": "def max_difference(test_list):\n    max_diff = 0\n    for a, b in test_list:\n        diff = abs(a - b)\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff\n",
    "MbppEval/90": "def len_log(list1):\n    longest_length = 0\n    for word in list1:\n        if len(word) > longest_length:\n            longest_length = len(word)\n    return longest_length\n",
    "MbppEval/82": "import math\n\ndef volume_sphere(r):\n    return (4/3) * math.pi * r**3\n",
    "MbppEval/84": "def sequence(n):\n    \"\"\"\n    Find the nth number in the Newman-Conway sequence using dynamic programming.\n    \n    Args:\n        n (int): The position of the number to be returned in the sequence.\n        \n    Returns:\n        int: The nth number in the Newman-Conway sequence.\n    \"\"\"\n    if n <= 2:\n        return 1\n    \n    memo = {1: 1, 2: 1}\n    \n    for i in range(3, n+1):\n        memo[i] = memo[i-1] + memo[i-2]\n    \n    return memo[n]\n",
    "MbppEval/87": "import collections as ct\n\ndef merge_dictionaries_three(dict1, dict2, dict3):\n    result = {}\n\n    for key, value in dict1.items():\n        result[key] = value\n\n    for key, value in dict2.items():\n        result[key] = value\n\n    for key, value in dict3.items():\n        result[key] = value\n\n    return result\n",
    "MbppEval/67": "def bell_number(n):\n    \"\"\"\n    Write a function to find the number of ways to partition a set of Bell numbers.\n\n    Examples:\n    bell_number(2) == 2\n    bell_number(10) == 115975\n    bell_number(56) == 6775685320645824322581483068371419745979053216268760300\n    \"\"\"\n    memo = {}\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        if n == 0:\n            return 1\n        result = sum(helper(k) * binomial(n, k) for k in range(n))\n        memo[n] = result\n        return result\n\n    return helper(n)\n\ndef binomial(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k).\n    \"\"\"\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef factorial(n):\n    \"\"\"\n    Calculate the factorial of a number.\n    \"\"\"\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n",
    "MbppEval/91": "def find_substring(str1, sub_str):\n    found = False\n    for s in str1:\n        if sub_str in s:\n            found = True\n            break\n    return found\n",
    "MbppEval/57": "def find_Max_Num(arr):\n    # Convert the list of digits into a list of strings\n    arr_str = [str(digit) for digit in arr]\n    \n    # Sort the list of strings in descending order\n    arr_str.sort(reverse=True)\n    \n    # Concatenate the sorted strings to form the largest number\n    largest_num = ''.join(arr_str)\n    \n    return int(largest_num)\n",
    "MbppEval/59": "def is_octagonal(n):\n    '''\n    Write a function to find the nth octagonal number.\n\n    Examples:\n    is_octagonal(5) == 65\n    is_octagonal(10) == 280\n    is_octagonal(15) == 645\n    '''\n    return n * (3 * n - 2)\n",
    "MbppEval/96": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count\n",
    "MbppEval/80": "def tetrahedral_number(n):\n    \"\"\"\n    Write a function to find the nth tetrahedral number.\n\n    Examples:\n    tetrahedral_number(5) == 35.0\n    tetrahedral_number(6) == 56.0\n    tetrahedral_number(7) == 84.0\n    \"\"\"\n    return (n * (n + 1) * (n + 2)) / 6\n",
    "MbppEval/97": "def frequency_lists(list1):\n    flattened_list = [item for sublist in list1 for item in sublist]\n    freq_dict = {}\n    for item in flattened_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict\n",
    "MbppEval/102": "def snake_to_camel(word):\n    camel_case = ''\n    words = word.split('_')\n    camel_case += words[0]\n    for w in words[1:]:\n        camel_case += w.capitalize()\n    return camel_case\n",
    "MbppEval/94": "from operator import itemgetter \n\ndef index_minimum(test_list):\n    return min(test_list, key=itemgetter(1))[0]\n",
    "MbppEval/99": "def decimal_to_binary(n):\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n //= 2\n    return binary if binary else '0'\n",
    "MbppEval/85": "import math\n\ndef surfacearea_sphere(r):\n    \"\"\"\n    Write a function to find the surface area of a sphere.\n\n    Examples:\n    surfacearea_sphere(10) == 1256.6370614359173\n    surfacearea_sphere(15) == 2827.4333882308138\n    surfacearea_sphere(20) == 5026.548245743669\n    \"\"\"\n    surface_area = 4 * math.pi * r**2\n    return surface_area\n",
    "MbppEval/89": "def closest_num(N):\n    \"\"\"\n    Write a function to find the closest smaller number than n.\n\n    Examples:\n    closest_num(11) == 10\n    closest_num(7) == 6\n    closest_num(12) == 11\n    \"\"\"\n    closest = N\n    for num in range(N - 1, -1, -1):\n        if abs(num - N) < abs(closest - N):\n            closest = num\n    return closest\n",
    "MbppEval/113": "def check_integer(text):\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n",
    "MbppEval/103": "def eulerian_num(n, m):\n    if m == 0:\n        return 1\n    if n == 0 or m > n:\n        return 0\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)\n",
    "MbppEval/98": "def multiply_num(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n",
    "MbppEval/95": "def Find_Min_Length(lst):\n    min_length = float('inf')\n    \n    for inner_list in lst:\n        current_length = len(inner_list)\n        if current_length < min_length:\n            min_length = current_length\n    \n    return min_length\n",
    "MbppEval/111": "def common_in_nested_lists(nestedlist):\n    if not nestedlist:\n        return []\n\n    common_elements = set(nestedlist[0])\n\n    for lst in nestedlist[1:]:\n        common_elements &= set(lst)\n\n    return list(common_elements)\n",
    "MbppEval/116": "def tuple_to_int(nums):\n    return int(''.join(map(str, nums)))\n",
    "MbppEval/93": "def power(a, b):\n    result = 1\n    for _ in range(b):\n        result *= a\n    return result\n",
    "MbppEval/101": "def kth_element(arr, n, k):\n    arr.sort()\n    return arr[k-1]\n",
    "MbppEval/106": "def add_lists(test_list, test_tup):\n    return test_tup + tuple(test_list)\n",
    "MbppEval/108": "import heapq\n\ndef merge_sorted_list(num1, num2, num3):\n    result = []\n    heap = []\n    for num in num1:\n        heapq.heappush(heap, num)\n    for num in num2:\n        heapq.heappush(heap, num)\n    for num in num3:\n        heapq.heappush(heap, num)\n    while heap:\n        result.append(heapq.heappop(heap))\n    return result\n",
    "MbppEval/124": "import cmath\n\ndef angle_complex(a, b):\n    \"\"\"\n    Write a function to get the angle of a complex number.\n\n    Examples:\n    angle_complex(0, 1j) == 1.5707963267948966\n    angle_complex(2, 1j) == 0.4636476090008061\n    angle_complex(0, 2j) == 1.5707963267948966\n    \"\"\"\n    return cmath.phase(complex(a, b))\n",
    "MbppEval/145": "def max_Abs_Diff(arr, n):\n    max_diff = 0\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            curr_diff = abs(arr[i] - arr[j])\n            max_diff = max(max_diff, curr_diff)\n    \n    return max_diff\n",
    "MbppEval/117": "def list_to_float(test_list):\n    result = []\n    for inner_list in test_list:\n        converted_list = []\n        for item in inner_list:\n            try:\n                converted_list.append(float(item))\n            except ValueError:\n                converted_list.append(item)\n        result.append(tuple(converted_list))\n    return str(result)\n",
    "MbppEval/141": "def pancake_sort(nums):\n    n = len(nums)\n    \n    for i in range(n, 0, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_idx = 0\n        for j in range(1, i):\n            if nums[j] > nums[max_idx]:\n                max_idx = j\n        \n        # Flip the sublist to bring the maximum element to the beginning\n        nums[:max_idx + 1] = reversed(nums[:max_idx + 1])\n        \n        # Flip the entire unsorted part to bring the maximum element to its correct position\n        nums[:i] = reversed(nums[:i])\n    \n    return nums\n",
    "MbppEval/128": "def long_words(n, string):\n    words = string.split()\n    long_words_list = []\n    for word in words:\n        if len(word) > n:\n            long_words_list.append(word)\n    return long_words_list\n",
    "MbppEval/68": "def is_Monotonic(A):\n    increasing = True\n    decreasing = True\n\n    for i in range(1, len(A)):\n        if A[i] > A[i - 1]:\n            decreasing = False\n        if A[i] < A[i - 1]:\n            increasing = False\n\n    return increasing or decreasing\n",
    "MbppEval/118": "def string_to_list(string):\n    return string.split()\n",
    "MbppEval/132": "def tup_string(tup1):\n    result_string = \"\"\n    for char in tup1:\n        result_string += char\n    return result_string\n",
    "MbppEval/126": "def sum(a, b):\n    \"\"\"\n    Write a python function to find the sum of common divisors of two given numbers.\n\n    Examples:\n    sum(10, 15) == 6\n    sum(100, 150) == 93\n    sum(4, 6) == 3\n    \"\"\"\n    divisors_a = [i for i in range(1, a+1) if a % i == 0]\n    divisors_b = [i for i in range(1, b+1) if b % i == 0]\n    common_divisors = [x for x in divisors_a if x in divisors_b]\n    return sum(common_divisors)\n",
    "MbppEval/100": "import sys\n\ndef next_smallest_palindrome(num):\n    '''\n    Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\n    Examples:\n    next_smallest_palindrome(99) == 101\n    next_smallest_palindrome(1221) == 1331\n    next_smallest_palindrome(120) == 121\n    '''\n    # Convert the input to a string\n    num_str = str(num)\n    \n    # Check if the number is already a palindrome\n    if num_str == num_str[::-1]:\n        # If it is, return the next odd palindrome\n        return num + 2\n    \n    # Find the middle index\n    middle = len(num_str) // 2\n    \n    # Construct the next palindrome\n    left_half = num_str[:middle]\n    if len(num_str) % 2 == 0:\n        right_half = num_str[middle:]\n    else:\n        right_half = num_str[middle+1:]\n    \n    next_palindrome_str = left_half + right_half[::-1]\n    \n    # Convert the result back to an integer and return it\n    return int(next_palindrome_str)\n",
    "MbppEval/119": "def search(arr):\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if (mid == 0 or arr[mid] != arr[mid-1]) and (mid == len(arr)-1 or arr[mid] != arr[mid+1]):\n            return arr[mid]\n        \n        if mid > 0 and arr[mid] == arr[mid-1]:\n            right = mid - 2\n        else:\n            left = mid + 1\n    \n    return -1\n",
    "MbppEval/125": "def find_length(string):\n    max_diff = 0\n    current_diff = 0\n    \n    for char in string:\n        if char == '1':\n            current_diff += 1\n        else:\n            current_diff -= 1\n        max_diff = max(max_diff, abs(current_diff))\n    \n    return max_diff\n",
    "MbppEval/143": "def find_lists(Input):\n    count = 0\n    \n    if not isinstance(Input, tuple):\n        return \"Input must be a tuple\"\n    \n    for element in Input:\n        if isinstance(element, list):\n            count += 1\n    \n    return count\n",
    "MbppEval/11": "def remove_Occ(s, ch):\n    result = \"\"\n    \n    # Skip the first occurrence of the character\n    if s[0] == ch:\n        result = s[1:]\n    else:\n        result = s\n    \n    # Remove the last occurrence of the character\n    last_index = result.rfind(ch)\n    if last_index != -1:\n        result = result[:last_index] + result[last_index+1:]\n    \n    return result\n",
    "MbppEval/140": "def extract_singly(test_list):\n    result_set = set()\n    for inner_list in test_list:\n        for num in inner_list:\n            result_set.add(num)\n    return list(result_set)\n",
    "MbppEval/109": "def odd_Equivalent(s, n):\n    num = int(s, 2)\n    count = 0\n    for _ in range(n):\n        if num & 1 == 1:\n            count += 1\n        num = (num >> 1) | (num << (len(s) - 1))\n    return count\n",
    "MbppEval/131": "def reverse_vowels(str1):\n    \"\"\"\n    Write a python function to reverse only the vowels of a given string (where y is not a vowel).\n\n    Examples:\n    reverse_vowels(\"Python\") == \"Python\"\n    reverse_vowels(\"USA\") == \"ASU\"\n    reverse_vowels(\"ab\") == \"ab\"\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    char_list = list(str1)\n    left, right = 0, len(char_list) - 1\n    while left < right:\n        if char_list[left] in vowels:\n            while right > left and char_list[right] not in vowels:\n                right -= 1\n            if right > left:\n                char_list[left], char_list[right] = char_list[right], char_list[left]\n                right -= 1\n        left += 1\n    return ''.join(char_list)\n",
    "MbppEval/163": "from math import tan, pi\n\ndef area_polygon(s, l):\n    area = (s * l**2) / (4 * tan(pi/s))\n    return round(area, 10)\n",
    "MbppEval/137": "from array import array\n\ndef zero_count(nums):\n    zero_count = 0\n    non_zero_count = 0\n    \n    for num in nums:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    total_count = zero_count + non_zero_count\n    ratio = zero_count / total_count\n    \n    return ratio\n",
    "MbppEval/161": "def remove_elements(list1, list2):\n    result = [item for item in list1 if item not in list2]\n    return result\n",
    "MbppEval/120": "def max_product_tuple(list1):\n    max_product = 0\n\n    for a, b in list1:\n        current_product = abs(a * b)\n        if current_product > max_product:\n            max_product = current_product\n\n    return max_product\n",
    "MbppEval/139": "import math\n\ndef circle_circumference(r):\n    circumference = 2 * math.pi * r\n    return round(circumference, 3)\n",
    "MbppEval/104": "def sort_sublists(input_list):\n    sorted_sublists = []\n    for sublist in input_list:\n        sorted_sublist = sorted(sublist)\n        sorted_sublists.append(sorted_sublist)\n    return sorted_sublists\n",
    "MbppEval/14": "def find_Volume(l, b, h):\n    \"\"\"\n    Write a python function to find the volume of a triangular prism.\n\n    Examples:\n    find_Volume(10, 8, 6) == 240\n    find_Volume(3, 2, 2) == 6\n    find_Volume(1, 2, 1) == 1\n\n    Args:\n        l (float): Length of the triangular prism.\n        b (float): Breadth of the triangular prism.\n        h (float): Height of the triangular prism.\n\n    Returns:\n        float: The volume of the triangular prism.\n    \"\"\"\n    return (1/2) * b * h * l\n",
    "MbppEval/168": "def frequency(a, x):\n    count = 0\n    for num in a:\n        if num == x:\n            count += 1\n    return count\n",
    "MbppEval/167": "def next_power_of_2(n):\n    \"\"\"\n    Write a python function to find the smallest power of 2 greater than or equal to n.\n\n    Examples:\n    next_Power_Of_2(0) == 1\n    next_Power_Of_2(5) == 8\n    next_Power_Of_2(17) == 32\n    \"\"\"\n    if n == 0:\n        return 1\n    return (n - 1) | (n - 1) + 1\n",
    "MbppEval/166": "def find_even_pair(A):\n    xor_set = set()\n    count = 0\n    \n    for num in A:\n        current_xor = num\n        if current_xor ^ current_xor in xor_set:\n            count += 1\n        xor_set.add(current_xor)\n    \n    return count\n",
    "MbppEval/172": "def count_occurance(s):\n    return s.lower().count('std')\n",
    "MbppEval/226": "def odd_values_string(str):\n    result = \"\"\n    for i, char in enumerate(str):\n        if i % 2 == 0:\n            result += char\n    return result\n",
    "MbppEval/230": "def replace_blank(str1, char):\n    new_str = \"\"\n    for char_in_str in str1:\n        if char_in_str == \" \":\n            new_str += char\n        else:\n            new_str += char_in_str\n    return new_str\n",
    "MbppEval/138": "def is_Sum_Of_Powers_Of_Two(n):\n    if n == 0 or (n & (n - 1)) == 0:\n        return True\n\n    result = True\n    binary_str = bin(n)[2:]\n\n    for i, char in enumerate(binary_str):\n        if char == '1' and 2 ** i != n:\n            result = False\n            break\n\n    return result\n",
    "MbppEval/222": "def check_type(test_tuple):\n    data_types = set()\n    for element in test_tuple:\n        data_types.add(type(element))\n    return len(data_types) == 1\n",
    "MbppEval/238": "def number_of_substrings(str):\n    return len(str) * (len(str) + 1) // 2\n",
    "MbppEval/244": "import math\n\ndef next_Perfect_Square(N):\n    square_root = math.sqrt(N)\n    next_square = math.ceil(square_root)\n    return next_square ** 2\n",
    "MbppEval/251": "def insert_element(list, element):\n    result = []\n    for item in list:\n        result.append(element)\n        result.append(item)\n    return result\n",
    "MbppEval/229": "def re_arrange_array(arr, n):\n    \"\"\"\n    Rearranges the first n elements of the given array so that all negative elements appear before positive ones,\n    while preserving the relative order among negative and positive elements.\n    \"\"\"\n    negative = []\n    positive = []\n    \n    for i in range(n):\n        if arr[i] < 0:\n            negative.append(arr[i])\n        else:\n            positive.append(arr[i])\n    \n    return negative + positive\n",
    "MbppEval/228": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    mask = (1 << (r-l+1)) - 1\n    return (n & mask) == mask\n",
    "MbppEval/162": "def sum_series(n):\n    total = 0\n    for i in range(n//2 + 1):\n        total += n - 2*i\n    return total\n",
    "MbppEval/246": "def babylonian_squareroot(number):\n    \"\"\"\n    Write a function for computing square roots using the Babylonian method.\n\n    Examples:\n    babylonian_squareroot(10) == 3.162277660168379\n    babylonian_squareroot(2) == 1.414213562373095\n    babylonian_squareroot(9) == 3.0\n    \"\"\"\n    guess = number / 2\n    previous_guess = 0\n\n    while abs(guess - previous_guess) > 1e-10:\n        previous_guess = guess\n        guess = (guess + number / guess) / 2\n\n    return guess\n",
    "MbppEval/142": "def count_samepair(list1, list2, list3):\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        return 0\n\n    count = 0\n\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n\n    return count\n",
    "MbppEval/170": "def sum_range_list(list1, m, n):\n    if not isinstance(list1, list):\n        raise TypeError(\"Input must be a list\")\n    if m < 0 or n >= len(list1):\n        raise IndexError(\"Indices out of range\")\n    if m > n:\n        raise ValueError(\"m must be less than or equal to n\")\n\n    sum_range = 0\n    for i in range(m, n+1):\n        sum_range += list1[i]\n    return sum_range\n",
    "MbppEval/260": "def newman_prime(n):\n    \"\"\"\n    Find the nth Newman-Shanks-Williams prime number.\n    \n    Args:\n        n (int): The index of the Newman-Shanks-Williams prime number to find.\n    \n    Returns:\n        int: The nth Newman-Shanks-Williams prime number.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    primes = []\n    i = 1\n    while len(primes) < n:\n        candidate = 2 ** i - 1\n        if all(candidate % p != 0 for p in primes):\n            primes.append(candidate)\n        i += 1\n    \n    return primes[n - 1]\n",
    "MbppEval/245": "def max_sum(arr):\n    n = len(arr)\n    increasing = [0] * n\n    decreasing = [0] * n\n\n    increasing[0] = arr[0]\n    for i in range(1, n):\n        increasing[i] = max(increasing[i-1] + arr[i], arr[i])\n\n    decreasing[n-1] = arr[n-1]\n    for i in range(n-2, -1, -1):\n        decreasing[i] = max(decreasing[i+1] + arr[i], arr[i])\n\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, increasing[i] + decreasing[i] - arr[i])\n\n    return max_sum\n",
    "MbppEval/250": "def count_X(tup, x):\n    count = 0\n    for element in tup:\n        if element == x:\n            count += 1\n    return count\n",
    "MbppEval/223": "def is_majority(arr, n, x):\n    \"\"\"\n    Write a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\n\n    Examples:\n    is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True\n    is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False\n    is_majority([1, 1, 1, 2, 2], 5, 1) == True\n    \"\"\"\n    # Find the first occurrence of x\n    left = 0\n    right = n - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == x:\n            if mid == 0 or arr[mid - 1] != x:\n                break\n            right = mid - 1\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    if left > n - 1 or arr[left] != x:\n        return False\n\n    first_idx = left\n\n    # Find the last occurrence of x\n    left = 0\n    right = n - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == x:\n            if mid == n - 1 or arr[mid + 1] != x:\n                break\n            left = mid + 1\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    last_idx = mid\n\n    return last_idx - first_idx + 1 > n // 2\n",
    "MbppEval/224": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n",
    "MbppEval/257": "def swap_numbers(a, b):\n    return (b, a)\n",
    "MbppEval/247": "def lps(str):\n    n = len(str)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n+1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if str[i] == str[j]:\n                dp[i][j] = 2 + dp[i+1][j-1]\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n\n    return dp[0][n-1]\n",
    "MbppEval/234": "def volume_cube(l):\n    \"\"\"\n    Write a function to find the volume of a cube given its side length.\n\n    Examples:\n    volume_cube(3) == 27\n    volume_cube(2) == 8\n    volume_cube(5) == 125\n    \"\"\"\n    return l ** 3\n",
    "MbppEval/253": "def count_integer(list1):\n    count = 0\n    for element in list1:\n        if isinstance(element, int):\n            count += 1\n    return count\n",
    "MbppEval/160": "def extended_gcd(a, b):\n    \"\"\"\n    Compute the extended Euclidean algorithm for a and b.\n    Returns (gcd, x, y) such that ax + by = gcd(a, b)\n    \"\"\"\n    x, y, u, v = 0, 1, 1, 0\n    while a != 0:\n        q, r = b // a, b % a\n        m, n = x - u * q, y - v * q\n        b, a, x, y, u, v = a, r, u, v, m, n\n    return b, x, y\n\ndef find_solution(a, b, n):\n    \"\"\"\n    Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return 'No solution' if no solution exists.\n\n    Examples:\n    find_solution(2, 3, 7) == ('x = ', 2, ', y = ', 1)\n    find_solution(4, 2, 7) == 'No solution'\n    find_solution(1, 13, 17) == ('x = ', 4, ', y = ', 1)\n    \"\"\"\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd != 0:\n        return 'No solution'\n    x0 = x * (n // gcd)\n    y0 = y * (n // gcd)\n    return ('x = ', x0, ', y = ', y0)\n",
    "MbppEval/262": "def split_two_parts(list1, L):\n    first_part = list1[:L]\n    second_part = list1[L:]\n    return (first_part, second_part)\n",
    "MbppEval/266": "def lateralsurface_cube(l):\n    return 4 * l ** 2\n",
    "MbppEval/255": "from itertools import combinations_with_replacement\n\ndef combinations_colors(l, n):\n    return list(combinations_with_replacement(l, n))\n",
    "MbppEval/249": "def intersection_array(array_nums1, array_nums2):\n    return list(set(array_nums1) & set(array_nums2))\n",
    "MbppEval/133": "def sum_negativenum(nums):\n    total = 0\n    for num in nums:\n        if num < 0:\n            total += num\n    return total\n",
    "MbppEval/269": "def ascii_value(k):\n    \"\"\"\n    Write a function to find the ASCII value of a character.\n\n    Examples:\n    ascii_value('A') == 65\n    ascii_value('R') == 82\n    ascii_value('S') == 83\n    \"\"\"\n    return ord(k)\n",
    "MbppEval/264": "def dog_age(h_age):\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years.\n\n    Examples:\n    dog_age(12) == 61\n    dog_age(15) == 73\n    dog_age(24) == 109\n    \"\"\"\n    if h_age <= 2:\n        return h_age * 10\n    else:\n        return 16 + (h_age - 2) * 4\n",
    "MbppEval/273": "def subtract_elements(test_tup1, test_tup2):\n    return tuple(a - b for a, b in zip(test_tup1, test_tup2))\n",
    "MbppEval/242": "def count_charac(str1):\n    total_chars = 0\n    for char in str1:\n        total_chars += 1\n    return total_chars\n",
    "MbppEval/272": "def rear_extract(test_list):\n    return [tup[-1] for tup in test_list]\n",
    "MbppEval/64": "def subject_marks(subjectmarks):\n    return sorted(subjectmarks, key=lambda x: x[1])\n",
    "MbppEval/267": "def square_Sum(n):\n    total = 0\n    i = 1\n    for _ in range(n):\n        total += i**2\n        i += 2\n    return total\n",
    "MbppEval/77": "def is_Diff(n):\n    \"\"\"\n    Write a python function to find whether a number is divisible by 11.\n\n    Examples:\n    is_Diff(12345) == False\n    is_Diff(1212112) == True\n    is_Diff(1212) == False\n    \"\"\"\n    sum1 = 0\n    sum2 = 0\n    n_str = str(n)\n    for i, digit in enumerate(n_str):\n        if i % 2 == 0:\n            sum1 += int(digit)\n        else:\n            sum2 += int(digit)\n    diff = abs(sum1 - sum2)\n    return diff % 11 == 0\n",
    "MbppEval/123": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Write a function to sum all amicable numbers from 1 to a specified number.\n\n    Examples:\n    amicable_numbers_sum(999) == 504\n    amicable_numbers_sum(9999) == 31626\n    amicable_numbers_sum(99) == 0\n    \"\"\"\n    amicable_numbers = set()\n\n    for num in range(1, limit):\n        divisors_sum = sum(div for div in range(1, num) if num % div == 0)\n        other_num_divisors_sum = sum(div for div in range(1, divisors_sum) if divisors_sum % div == 0)\n\n        if other_num_divisors_sum == num and num != divisors_sum:\n            amicable_numbers.add(num)\n            amicable_numbers.add(divisors_sum)\n\n    return sum(amicable_numbers)\n",
    "MbppEval/276": "import math\n\ndef volume_cylinder(r, h):\n    volume = math.pi * (r ** 2) * h\n    return volume\n",
    "MbppEval/239": "def get_total_number_of_sequences(m, n):\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    \n    # Base case: sequences of length 1\n    for i in range(1, m+1):\n        dp[i][1] = 1\n    \n    # Compute the number of sequences\n    for j in range(2, n+1):\n        for i in range(1, m+1):\n            for k in range(max(1, i//2), i):\n                dp[i][j] += dp[k][j-1]\n    \n    # Sum up the values in the last column\n    return sum(dp[i][n] for i in range(1, m+1))\n",
    "MbppEval/265": "def list_split(S, step):\n    result = []\n    for i in range(0, len(S), step):\n        result.append(S[i::step])\n    return result\n",
    "MbppEval/92": "def is_undulating(n):\n    \"\"\"\n    Check whether the given number is undulating or not.\n\n    Examples:\n    is_undulating(\"1212121\") == True\n    is_undulating(\"1991\") == False\n    is_undulating(\"121\") == True\n    \"\"\"\n    n_str = str(n)\n    \n    # Check if the length of the string is less than 3\n    if len(n_str) < 3:\n        return False\n    \n    is_undulating = True\n    \n    # Iterate through the digits, starting from the second digit\n    for i in range(1, len(n_str)):\n        if n_str[i] == n_str[i-1]:\n            is_undulating = False\n            break\n    \n    return is_undulating\n",
    "MbppEval/277": "def dict_filter(d, n):\n    return {k: v for k, v in d.items() if v >= n}\n",
    "MbppEval/129": "def magic_square_test(my_matrix):\n    sum_constant = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != sum_constant:\n            return False\n    for i in range(len(my_matrix)):\n        column_sum = 0\n        for row in my_matrix:\n            column_sum += row[i]\n        if column_sum != sum_constant:\n            return False\n    main_diagonal_sum = 0\n    for i in range(len(my_matrix)):\n        main_diagonal_sum += my_matrix[i][i]\n    if main_diagonal_sum != sum_constant:\n        return False\n    secondary_diagonal_sum = 0\n    for i in range(len(my_matrix)):\n        secondary_diagonal_sum += my_matrix[i][len(my_matrix) - i - 1]\n    if secondary_diagonal_sum != sum_constant:\n        return False\n    return True\n",
    "MbppEval/278": "def count_first_elements(test_tup):\n    for i, element in enumerate(test_tup):\n        if isinstance(element, tuple):\n            return i\n    return 0\n",
    "MbppEval/280": "def sequential_search(dlist, item):\n    found = False\n    index = -1\n    \n    for i, elem in enumerate(dlist):\n        if elem == item:\n            found = True\n            index = i\n            break\n    \n    return (found, index)\n",
    "MbppEval/72": "import math\n\ndef dif_Square(n):\n    if n % 4 != 1:\n        return False\n\n    x = int(math.ceil(math.sqrt(n)))\n    y = int(math.floor(math.sqrt(n)))\n    while x**2 - y**2 != n:\n        if x**2 - y**2 < n:\n            x += 1\n        else:\n            y -= 1\n\n    return True\n",
    "MbppEval/279": "def get_nth_decagonal(n):\n    return n * (3 * n - 2)\n",
    "MbppEval/294": "def max_val(listval):\n    \"\"\"\n    Write a function to find the maximum value in a given heterogeneous list.\n\n    Examples:\n    max_val(['Python', 3, 2, 4, 5, 'version']) == 5\n    max_val(['Python', 15, 20, 25]) == 25\n    max_val(['Python', 30, 20, 40, 50, 'version']) == 50\n    \"\"\"\n    if not listval:\n        return None\n\n    max_value = float('-inf')\n    for item in listval:\n        if isinstance(item, (int, float)):\n            max_value = max(max_value, item)\n\n    return max_value\n",
    "MbppEval/284": "def check_element(lst, element):\n    all_equal = True\n    for item in lst:\n        if item != element:\n            all_equal = False\n            break\n    return all_equal\n",
    "MbppEval/296": "def get_Inv_Count(arr):\n    return merge_sort(arr, len(arr))\n\ndef merge_sort(arr, n):\n    if n == 1:\n        return 0\n\n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left_inversions = merge_sort(left, mid)\n    right_inversions = merge_sort(right, n - mid)\n\n    i = j = 0\n    inversions = 0\n    for k in range(n):\n        if i < mid and (j >= n - mid or left[i] <= right[j]):\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inversions += mid - i\n\n    return left_inversions + right_inversions + inversions\n",
    "MbppEval/130": "from collections import defaultdict\n\ndef max_occurrences(nums):\n    count = defaultdict(int)\n    for num in nums:\n        count[num] += 1\n    max_count = max(count.values())\n    for item, freq in count.items():\n        if freq == max_count:\n            return (item, freq)\n",
    "MbppEval/259": "def maximize_elements(test_tup1, test_tup2):\n    maximized_tuples = []\n    for t1, t2 in zip(test_tup1, test_tup2):\n        maximized_tuples.append((max(t1[0], t2[0]), max(t1[1], t2[1])))\n    return tuple(maximized_tuples)\n",
    "MbppEval/301": "def dict_depth(d):\n    \"\"\"\n    Write a function to find the depth of a dictionary.\n\n    Examples:\n    dict_depth({'a':1, 'b': {'c': {'d': {}}}}) == 4\n    dict_depth({'a':1, 'b': {'c':'python'}}) == 2\n    dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}}) == 3\n    \"\"\"\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0\n",
    "MbppEval/233": "import math\n\ndef lateralsuface_cylinder(r, h):\n    lateral_surface_area = 2 * math.pi * r * h\n    return lateral_surface_area\n",
    "MbppEval/291": "def count_no_of_ways(n, k):\n    if n == 1:\n        return k\n    \n    same = k\n    different = k * (k - 1)\n    \n    for i in range(3, n+1):\n        new_same = different\n        new_different = (same + different) * (k - 1)\n        same = new_same\n        different = new_different\n    \n    return same + different\n",
    "MbppEval/235": "def even_bit_set_number(n):\n    mask = 0b10101010101010101010101010101010\n    return n | mask\n",
    "MbppEval/282": "def sub_list(nums1, nums2):\n    if len(nums1) != len(nums2):\n        return \"Error: The input lists must have the same length.\"\n\n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] - nums2[i])\n\n    return result\n",
    "MbppEval/292": "def find(n, m):\n    return n // m\n",
    "MbppEval/281": "def all_unique(test_list):\n    \"\"\"\n    Write a python function to check if the elements of a given list are unique or not.\n\n    Examples:\n    all_unique([1,2,3]) == True\n    all_unique([1,2,1,2]) == False\n    all_unique([1,2,3,4,5]) == True\n    \"\"\"\n    unique_elements = set()\n    for item in test_list:\n        unique_elements.add(item)\n    return len(unique_elements) == len(test_list)\n",
    "MbppEval/285": "import re\n\ndef text_match_two_three(text):\n    pattern = r'ab{2,3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
    "MbppEval/305": "import re\n\ndef start_withp(words):\n    result = []\n    for word in words:\n        if re.match(r'^p', word, re.IGNORECASE):\n            result.append(word)\n            if len(result) == 2:\n                break\n    return tuple(result)\n",
    "MbppEval/248": "def harmonic_sum(n):\n    result = 0\n    for i in range(1, n):\n        result += 1/i\n    return result\n",
    "MbppEval/287": "def square_Sum(n):\n    total_sum = 0\n    for i in range(1, n+1):\n        even_num = 2 * i\n        squared_num = even_num ** 2\n        total_sum += squared_num\n    return total_sum\n",
    "MbppEval/300": "def count_binary_seq(n):\n    if n == 1:\n        return 2.0\n    else:\n        return 2 * (count_binary_seq(n-1)) / 2\n",
    "MbppEval/307": "from copy import deepcopy\n\ndef colon_tuplex(tuplex, m, n):\n    new_tuple = deepcopy(tuplex)\n    if isinstance(new_tuple[m], list):\n        new_tuple[m] = [n]\n    return new_tuple\n",
    "MbppEval/227": "def min_of_three(a, b, c):\n    if a <= b and a <= c:\n        return a\n    elif b <= a and b <= c:\n        return b\n    else:\n        return c\n",
    "MbppEval/293": "import math\n\ndef otherside_rightangle(w, h):\n    return math.sqrt(w**2 + h**2)\n",
    "MbppEval/312": "import math\n\ndef volume_cone(r, h):\n    \"\"\"\n    Write a function to find the volume of a cone.\n\n    Examples:\n    volume_cone(5, 12) == 314.15926535897927\n    volume_cone(10, 15) == 1570.7963267948965\n    volume_cone(19, 17) == 6426.651371693521\n    \"\"\"\n    return (1/3) * math.pi * r**2 * h\n",
    "MbppEval/164": "import math\n\ndef div_sum(n):\n    \"\"\"\n    Write a function to determine the sum of the divisors of an integer.\n\n    Args:\n    n (int): The integer to find the divisor sum for.\n\n    Returns:\n    int: The sum of the divisors of n.\n    \"\"\"\n    divisors = []\n    for i in range(1, n+1):\n        if n % i == 0:\n            divisors.append(i)\n    return sum(divisors)\n\ndef areEquivalent(a, b):\n    \"\"\"\n    Determine if the sum of the divisors of two integers are the same.\n\n    Args:\n    a (int): The first integer.\n    b (int): The second integer.\n\n    Returns:\n    bool: True if the sum of the divisors of a and b are the same, False otherwise.\n    \"\"\"\n    return div_sum(a) == div_sum(b)\n",
    "MbppEval/309": "def maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b\n",
    "MbppEval/304": "def find_Element(arr, ranges, rotations, index):\n    for start, end in ranges:\n        arr[start:end] = arr[start+rotations:end] + arr[start:start+rotations]\n    return arr[index]\n",
    "MbppEval/390": "def add_string(list_, string):\n    result = []\n    for element in list_:\n        formatted_string = string.format(element)\n        result.append(formatted_string)\n    return result\n",
    "MbppEval/252": "import cmath\n\ndef convert(number):\n    magnitude, phase = cmath.polar(number)\n    return (magnitude, phase)\n",
    "MbppEval/391": "def convert_list_dictionary(l1, l2, l3):\n    result = []\n    for key, name, value in zip(l1, l2, l3):\n        result.append({key: {name: value}})\n    return result\n",
    "MbppEval/388": "def highest_Power_of_2(n):\n    power_of_2 = 1\n    while power_of_2 * 2 <= n:\n        power_of_2 *= 2\n    return power_of_2\n",
    "MbppEval/286": "def max_sub_array_sum_repeated(a, n, k):\n    max_subarray_sum = float('-inf')\n    total_sum = 0\n    \n    # Calculate the total sum of the original array\n    for num in a:\n        total_sum += num\n    \n    # Find the maximum subarray sum in the original array\n    curr_sum = 0\n    for num in a:\n        curr_sum = max(num, curr_sum + num)\n        max_subarray_sum = max(max_subarray_sum, curr_sum)\n    \n    # Calculate the maximum subarray sum in the repeated array\n    if total_sum >= 0:\n        return max_subarray_sum * k\n    else:\n        return max(max_subarray_sum, max_subarray_sum + (k - 1) * total_sum)\n",
    "MbppEval/299": "from collections import defaultdict\n\ndef max_aggregate(stdata):\n    aggregates = defaultdict(int)\n    for name, score in stdata:\n        aggregates[name] += score\n    return max(aggregates.items(), key=lambda x: x[1])\n",
    "MbppEval/392": "def get_max_sum(n):\n    \"\"\"\n    Find the maximum sum possible by using the given equation f(n) = max((f(n//2) + f(n//3) + f(n//4) + f(n//5)), n).\n    \"\"\"\n    if n <= 1:\n        return n\n    if n <= 2:\n        return n\n    \n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n",
    "MbppEval/237": "from collections import Counter \n\ndef check_occurrences(test_list):\n    return dict(Counter(test_list))\n",
    "MbppEval/393": "def max_length_list(input_list):\n    \"\"\"\n    Write a function to find the list with maximum length.\n\n    Examples:\n    max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    max_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]]) == (5,[1,2,3,4,5])\n    max_length_list([[3,4,5],[6,7,8,9],[10,11,12]]) == (4,[6,7,8,9])\n    \"\"\"\n    if not isinstance(input_list, list) or not all(isinstance(inner_list, list) for inner_list in input_list):\n        raise ValueError(\"Input must be a list of lists\")\n\n    max_length = 0\n    max_list = []\n\n    for inner_list in input_list:\n        if len(inner_list) > max_length:\n            max_length = len(inner_list)\n            max_list = inner_list\n\n    return max_length, max_list\n",
    "MbppEval/394": "def check_distinct(test_tup):\n    return len(set(test_tup)) == len(test_tup)\n",
    "MbppEval/409": "def min_product_tuple(list1):\n    min_product = float('inf')\n    for a, b in list1:\n        product = a * b\n        if product < min_product:\n            min_product = product\n    return min_product\n",
    "MbppEval/414": "def overlapping(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    return len(set1.intersection(set2)) > 0\n",
    "MbppEval/105": "def count(lst):\n    count = 0\n    for element in lst:\n        if element:\n            count += 1\n    return count\n",
    "MbppEval/407": "def rearrange_bigger(n):\n    \"\"\"\n    Write a function to create the next bigger number by rearranging the digits of a given number.\n    \n    Examples:\n    rearrange_bigger(12) == 21\n    rearrange_bigger(10) == False\n    rearrange_bigger(102) == 120\n    \"\"\"\n    digits = list(str(n))\n    \n    # Find the first digit from the right that is smaller than the digit to its right\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i+1]:\n        i -= 1\n    \n    if i < 0:\n        return False\n    \n    # Find the smallest digit to the right of the digit found in the previous step\n    # that is greater than it\n    j = len(digits) - 1\n    while j > i and digits[j] <= digits[i]:\n        j -= 1\n    \n    # Swap the two digits\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Reverse the digits to the right of the swapped digits\n    digits[i+1:] = digits[i+1:][::-1]\n    \n    return int(''.join(digits))\n",
    "MbppEval/411": "def snake_to_camel(word):\n    camel_case = \"\"\n    words = word.split('_')\n    camel_case += words[0]\n    for w in words[1:]:\n        camel_case += w.capitalize()\n    return camel_case\n",
    "MbppEval/412": "def remove_odd(l):\n    new_list = []\n    for num in l:\n        if num % 2 == 0:\n            new_list.append(num)\n    return new_list\n",
    "MbppEval/232": "import heapq\n\ndef larg_nnum(list1, n):\n    return heapq.nlargest(n, list1)\n",
    "MbppEval/396": "import re\n\ndef check_char(string):\n    if re.match(r'^[a-z]$|^([a-z]).*\\1$', string):\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n",
    "MbppEval/410": "def min_val(listval):\n    min_value = float('inf')\n    for element in listval:\n        if isinstance(element, (int, float)):\n            min_value = min(min_value, element)\n    return min_value\n",
    "MbppEval/418": "def Find_Max(lst):\n    max_length = 0\n    max_element = None\n    \n    for element in lst:\n        if len(element) > max_length:\n            max_length = len(element)\n            max_element = element\n    \n    return max_element\n",
    "MbppEval/295": "def sum_div(number):\n    divisors_sum = 0\n    for i in range(1, number+1):\n        if number % i == 0:\n            divisors_sum += i\n    return divisors_sum\n",
    "MbppEval/261": "def division_elements(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    result = []\n    for i in range(len(test_tup1)):\n        division = test_tup1[i] / test_tup2[i]\n        result.append(division)\n\n    return tuple(result)\n",
    "MbppEval/389": "def find_lucas(n):\n    \"\"\"\n    Write a function to find the n'th Lucas number.\n\n    Examples:\n    find_lucas(9) == 76\n    find_lucas(4) == 7\n    find_lucas(3) == 4\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for i in range(2, n+1):\n            a, b = b, a + b\n        return b\n",
    "MbppEval/306": "def max_sum_increasing_subseq(a, n, index, k):\n    dp = [0] * n\n    dp[0] = a[0]\n\n    for i in range(1, index + 1):\n        if a[i] > a[i-1]:\n            dp[i] = dp[i-1] + a[i]\n        else:\n            dp[i] = dp[i-1]\n\n    for i in range(index + 1, k + 1):\n        dp[i] = max(dp[i], dp[index] + a[i])\n\n    return dp[k]\n",
    "MbppEval/421": "def concatenate_tuple(test_tup):\n    result = \"\"\n    for i, item in enumerate(test_tup):\n        if i > 0:\n            result += \"-\"\n        result += str(item)\n    return result\n",
    "MbppEval/420": "def cube_Sum(n):\n    total = 0\n    for i in range(2, 2*n+1, 2):\n        total += i**3\n    return total\n",
    "MbppEval/401": "def add_nested_tuples(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same number of inner tuples.\")\n\n    result = []\n    for i in range(len(test_tup1)):\n        new_tuple = (test_tup1[i][0] + test_tup2[i][0], test_tup1[i][1] + test_tup2[i][1])\n        result.append(new_tuple)\n\n    return tuple(result)\n",
    "MbppEval/413": "def extract_nth_element(list1, n):\n    return [item[n] for item in list1]\n",
    "MbppEval/297": "def flatten_list(list1):\n    flattened_list = []\n    \n    for item in list1:\n        if isinstance(item, list):\n            flattened_list.extend(flatten_list(item))\n        else:\n            flattened_list.append(item)\n    \n    return flattened_list\n",
    "MbppEval/419": "def round_and_sum(list1):\n    total_sum = 0\n    for num in list1:\n        total_sum += round(num)\n    return total_sum * len(list1)\n",
    "MbppEval/424": "def extract_rear(test_tuple):\n    rear_elements = []\n    for string in test_tuple:\n        rear_elements.append(string[-1])\n    return rear_elements\n",
    "MbppEval/415": "def max_Product(arr):\n    if not arr:\n        return None\n    \n    max1 = float('-inf')\n    max2 = float('-inf')\n    min1 = float('inf')\n    min2 = float('inf')\n    \n    for num in arr:\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n        \n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n    \n    if min1 * min2 > max1 * max2:\n        return (min1, min2)\n    else:\n        return (max1, max2)\n",
    "MbppEval/426": "def filter_oddnumbers(nums):\n    odd_nums = []\n    for num in nums:\n        if num % 2 == 1:\n            odd_nums.append(num)\n    return odd_nums\n",
    "MbppEval/398": "def sum_of_digits(nums):\n    total_sum = 0\n    for num in nums:\n        for char in str(num):\n            if char.isdigit():\n                total_sum += int(char)\n    return total_sum\n",
    "MbppEval/425": "def count_element_in_list(list1, x):\n    count = 0\n    for sub_list in list1:\n        if x in sub_list:\n            count += 1\n    return count\n",
    "MbppEval/417": "def group_tuples(input_list):\n    result = {}\n    for tup in input_list:\n        first_element = tup[0]\n        if first_element in result:\n            result[first_element].append(tup[1])\n        else:\n            result[first_element] = [tup[1]]\n    return [(key, *value) for key, value in result.items()]\n",
    "MbppEval/395": "def first_non_repeating_character(str1):\n    \"\"\"\n    Write a python function to find the first non-repeated character in a given string.\n\n    Examples:\n    first_non_repeating_character(\"abcabc\") == None\n    first_non_repeating_character(\"abc\") == \"a\"\n    first_non_repeating_character(\"ababc\") == \"c\"\n    \"\"\"\n    char_count = {}\n    first_occurrence = {}\n\n    for i, char in enumerate(str1):\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n            first_occurrence[char] = i\n\n    for char, count in char_count.items():\n        if count == 1:\n            return str1[first_occurrence[char]]\n\n    return None\n",
    "MbppEval/310": "def string_to_tuple(str1):\n    result = tuple(str1)\n    return result\n",
    "MbppEval/283": "def validate(n):\n    num_str = str(n)\n    freq_dict = {}\n\n    for digit in num_str:\n        if digit in freq_dict:\n            freq_dict[digit] += 1\n        else:\n            freq_dict[digit] = 1\n\n    for digit, count in freq_dict.items():\n        if count > int(digit):\n            return False\n\n    return True\n",
    "MbppEval/429": "def and_tuples(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length\")\n    \n    result = ()\n    for i in range(len(test_tup1)):\n        result_element = test_tup1[i] & test_tup2[i]\n        result += (result_element,)\n    \n    return result\n",
    "MbppEval/437": "def remove_odd(str1):\n    result = \"\"\n    for i, char in enumerate(str1):\n        if i % 2 == 0:\n            result += char\n    return result\n",
    "MbppEval/256": "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n\n    Examples:\n    count_Primes_nums(5) == 2\n    count_Primes_nums(10) == 4\n    count_Primes_nums(100) == 25\n    \"\"\"\n    if n < 2:\n        return 0\n    \n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count\n\ndef is_prime(x):\n    \"\"\"\n    Helper function to check if a number is prime.\n    \"\"\"\n    if x < 2:\n        return False\n    for i in range(2, int(x ** 0.5) + 1):\n        if x % i == 0:\n            return False\n    return True\n",
    "MbppEval/443": "def largest_neg(list1):\n    largest_neg = float('-inf')\n    for num in list1:\n        if num < 0 and num > largest_neg:\n            largest_neg = num\n    return largest_neg\n",
    "MbppEval/439": "def multiple_to_single(L):\n    if not L:\n        return 0\n    \n    result = 0\n    for i, num in enumerate(L):\n        result = result * 10 + num\n    \n    return result\n",
    "MbppEval/433": "def check_greater(arr, number):\n    greater_count = 0\n    for element in arr:\n        if element < number:\n            greater_count += 1\n    \n    if greater_count == len(arr):\n        return \"Yes, the entered number is greater than those in the array\"\n    else:\n        return \"No, the entered number is not greater than those in the array\"\n",
    "MbppEval/455": "def check_monthnumb_number(monthnum2):\n    \"\"\"\n    Write a function to check whether the given month number contains 31 days or not.\n\n    Examples:\n    check_monthnumb_number(5) == True\n    check_monthnumb_number(2) == False\n    check_monthnumb_number(6) == False\n    \"\"\"\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n    if monthnum2 in months_with_31_days:\n        return True\n    else:\n        return False\n",
    "MbppEval/428": "def shell_sort(my_list):\n    n = len(my_list)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list\n",
    "MbppEval/427": "import re\n\ndef change_date_format(dt):\n    \"\"\"\n    Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n\n    Examples:\n    change_date_format(\"2026-01-02\") == '02-01-2026'\n    change_date_format(\"2020-11-13\") == '13-11-2020'\n    change_date_format(\"2021-04-26\") == '26-04-2021'\n    \"\"\"\n    match = re.match(r\"(\\d{4})-(\\d{2})-(\\d{2})\", dt)\n    if match:\n        year, month, day = match.groups()\n        return f\"{day}-{month}-{year}\"\n    else:\n        raise ValueError(\"Invalid date format. Expected 'yyyy-mm-dd'.\")\n",
    "MbppEval/434": "import re\n\ndef text_match_one(text):\n    if re.search(r'a[b]+$', text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
    "MbppEval/308": "def large_product(nums1, nums2, N):\n    largest_products = []\n\n    for num1 in nums1:\n        for num2 in nums2:\n            product = num1 * num2\n            if len(largest_products) < N:\n                largest_products.append(product)\n            else:\n                min_product = min(largest_products)\n                if product > min_product:\n                    largest_products.remove(min_product)\n                    largest_products.append(product)\n\n    largest_products.sort(reverse=True)\n    return largest_products[:N]\n",
    "MbppEval/444": "def trim_tuple(test_list, K):\n    trimmed_tuples = [tup[K:] for tup in test_list]\n    return str(trimmed_tuples)\n",
    "MbppEval/436": "def neg_nos(list1):\n    negative_nums = [num for num in list1 if num < 0]\n    return negative_nums\n",
    "MbppEval/448": "def cal_sum(n):\n    \"\"\"\n    Write a function to calculate the sum of Perrin numbers.\n\n    Examples:\n    cal_sum(9) == 49\n    cal_sum(10) == 66\n    cal_sum(11) == 88\n    \"\"\"\n    perrin = [3, 0, 2]\n    for i in range(3, n+1):\n        perrin.append(perrin[i-2] + perrin[i-3])\n    return sum(perrin)\n",
    "MbppEval/435": "def last_Digit(n):\n    return n % 10\n",
    "MbppEval/440": "import re\n\ndef find_adverb_position(text):\n    adverb_match = re.search(r'\\w+ly', text)\n    if adverb_match:\n        start = adverb_match.start()\n        end = adverb_match.end()\n        adverb = adverb_match.group()\n        return (start, end, adverb)\n    else:\n        return None\n",
    "MbppEval/445": "def index_multiplication(test_tup1, test_tup2):\n    result = []\n    for t1, t2 in zip(test_tup1, test_tup2):\n        temp = tuple(a * b for a, b in zip(t1, t2))\n        result.append(temp)\n    return tuple(result)\n",
    "MbppEval/454": "import re\n\ndef text_match_wordz(text):\n    pattern = r'\\bz\\w*\\b'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
    "MbppEval/458": "def rectangle_area(length, breadth):\n    \"\"\"\n    Write a function to find the area of a rectangle.\n\n    Examples:\n    rectangle_area(10, 20) == 200\n    rectangle_area(10, 5) == 50\n    rectangle_area(4, 2) == 8\n    \"\"\"\n    return length * breadth\n",
    "MbppEval/456": "def reverse_string_list(stringlist):\n    reversed_strings = []\n    for string in stringlist:\n        reversed_strings.append(string[::-1])\n    return reversed_strings\n",
    "MbppEval/457": "def Find_Min(lst):\n    min_length = float('inf')\n    min_sublist = None\n\n    for sublst in lst:\n        if len(sublst) < min_length:\n            min_length = len(sublst)\n            min_sublist = sublst\n\n    return min_sublist\n",
    "MbppEval/459": "import re\n\ndef remove_uppercase(str1):\n    return re.sub(r'[A-Z]+', '', str1)\n",
    "MbppEval/461": "def upper_ctr(str):\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count\n",
    "MbppEval/406": "def find_Parity(x):\n    \"\"\"\n    Write a python function to find whether the parity of a given number is odd.\n\n    Examples:\n    find_Parity(12) == \"Even Parity\"\n    find_Parity(7) == \"Odd Parity\"\n    find_Parity(10) == \"Even Parity\"\n    \"\"\"\n    x = int(x)\n    if x & 1 == 1:\n        return \"Odd Parity\"\n    else:\n        return \"Even Parity\"\n",
    "MbppEval/446": "from collections import Counter\n\ndef count_Occurrence(tup, lst):\n    tup_counter = Counter(tup)\n    total_count = 0\n    for element in lst:\n        total_count += tup_counter[element]\n    return total_count\n",
    "MbppEval/450": "def extract_string(str, l):\n    extracted_strings = []\n    for s in str:\n        if len(s) == l:\n            extracted_strings.append(s)\n    return extracted_strings\n",
    "MbppEval/453": "import math\n\ndef sumofFactors(n):\n    \"\"\"\n    Write a python function to find the sum of even factors of a number.\n    \n    Examples:\n    sumofFactors(18) == 26\n    sumofFactors(30) == 48\n    sumofFactors(6) == 8\n    \"\"\"\n    total = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                total += i\n            if (n // i) % 2 == 0 and (n // i) != i:\n                total += (n // i)\n    if n % 2 == 0:\n        total += n\n    return total\n",
    "MbppEval/468": "def max_product(arr):\n    max_product = 1\n    current_product = 1\n\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            current_product *= arr[i]\n            max_product = max(max_product, current_product)\n        else:\n            current_product = 1\n\n    return max_product\n",
    "MbppEval/465": "def drop_empty(dict1):\n    new_dict = {k:v for k, v in dict1.items() if v is not None}\n    return new_dict\n",
    "MbppEval/463": "def max_subarray_product(arr):\n    if not arr:\n        return 0\n\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        temp = max_so_far\n        max_so_far = max(max(arr[i], max_so_far * arr[i], min_so_far * arr[i]), result)\n        min_so_far = min(min(arr[i], temp * arr[i], min_so_far * arr[i]), result)\n        result = max(result, max_so_far)\n\n    return result\n",
    "MbppEval/477": "def is_lower(string):\n    return string.lower()\n",
    "MbppEval/452": "def loss_amount(actual_cost, sale_amount):\n    if sale_amount < actual_cost:\n        return actual_cost - sale_amount\n    else:\n        return 0\n",
    "MbppEval/447": "def cube_nums(nums):\n    return [num ** 3 for num in nums]\n",
    "MbppEval/399": "def bitwise_xor(test_tup1, test_tup2):\n    \"\"\"\n    Write a function to perform the mathematical bitwise xor operation across the given tuples.\n\n    Examples:\n    bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)\n    bitwise_xor((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)\n    bitwise_xor((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)\n    \"\"\"\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length.\")\n    return tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n",
    "MbppEval/556": "def find_Odd_Pair(A, N):\n    odd_count = 0\n    even_count = 0\n    \n    for num in A:\n        if num % 2 == 1:\n            odd_count += 1\n        else:\n            even_count += 1\n    \n    return odd_count * even_count\n",
    "MbppEval/559": "def max_sub_array_sum(a, size):\n    max_sum = a[0]\n    current_sum = a[0]\n    \n    for i in range(1, size):\n        current_sum = max(a[i], current_sum + a[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n",
    "MbppEval/555": "def difference(n):\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    sum_of_numbers = sum(range(1, n+1))\n    return sum_of_cubes - sum_of_numbers\n",
    "MbppEval/438": "def count_bidirectional(test_list):\n    pair_count = {}\n\n    for pair in test_list:\n        reverse_pair = (pair[1], pair[0])\n        if reverse_pair in pair_count:\n            pair_count[reverse_pair] += 1\n        else:\n            pair_count[pair] = 1\n            pair_count[reverse_pair] = 1\n\n    bidirectional_count = sum(1 for count in pair_count.values() if count > 1)\n    return str(bidirectional_count)\n",
    "MbppEval/470": "def add_pairwise(test_tup):\n    result = []\n    for i in range(0, len(test_tup) - 1, 2):\n        result.append(test_tup[i] + test_tup[i + 1])\n    return tuple(result)\n",
    "MbppEval/558": "def digit_distance_nums(n1, n2):\n    \"\"\"\n    Write a python function to find the sum of the per-digit difference between two integers.\n\n    Examples:\n    digit_distance_nums(1,2) == 1\n    digit_distance_nums(23,56) == 6\n    digit_distance_nums(123,256) == 7\n    \"\"\"\n    n1_str = str(n1)\n    n2_str = str(n2)\n\n    distance = 0\n\n    for i in range(max(len(n1_str), len(n2_str))):\n        d1 = int(n1_str[i]) if i < len(n1_str) else 0\n        d2 = int(n2_str[i]) if i < len(n2_str) else 0\n        distance += abs(d1 - d2)\n\n    return distance\n",
    "MbppEval/564": "def count_Pairs(arr, n):\n    unique_elements = set(arr)\n    return n * (n - 1) // 2 - len(unique_elements)\n",
    "MbppEval/451": "import re\n\ndef remove_whitespaces(text1):\n    return re.sub(r'\\s+', '', text1)\n",
    "MbppEval/464": "def check_value(dict, n):\n    return len(set(dict.values())) == 1 and all(value == n for value in dict.values())\n",
    "MbppEval/473": "def tuple_intersection(test_list1, test_list2):\n    tuple_set = set()\n    \n    for tup in test_list1:\n        if tup in test_list2 or (tup[1], tup[0]) in test_list2:\n            tuple_set.add(tup)\n    \n    return tuple_set\n",
    "MbppEval/404": "def minimum(a, b):\n    \"\"\"\n    Write a python function to find the minimum of two numbers.\n\n    Examples:\n    minimum(1, 2) == 1\n    minimum(-5, -4) == -5\n    minimum(0, 0) == 0\n    \"\"\"\n    return min(a, b)\n",
    "MbppEval/165": "def count_char_position(str1):\n    count = 0\n    for i, char in enumerate(str1.lower()):\n        if i == ord(char) - ord('a'):\n            count += 1\n    return count\n",
    "MbppEval/471": "def find_remainder(arr, n):\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n\n",
    "MbppEval/432": "def median_trapezium(base1, base2, height):\n    median_length = (base1 + base2) / 2\n    return median_length\n",
    "MbppEval/479": "def first_Digit(n):\n    n_str = str(n)\n    first_digit = int(n_str[0])\n    return first_digit\n",
    "MbppEval/568": "def empty_list(length):\n    result = [{} for _ in range(length)]\n    return result\n",
    "MbppEval/566": "def sum_digits(n):\n    total_sum = 0\n    for digit in str(n):\n        total_sum += int(digit)\n    return total_sum\n",
    "MbppEval/560": "def union_elements(test_tup1, test_tup2):\n    return tuple(sorted(set(test_tup1) | set(test_tup2)))\n",
    "MbppEval/462": "def combinations_list(list1):\n    result = []\n    def generate_combinations(lst, remaining):\n        if not remaining:\n            result.append(lst[:])\n        else:\n            for x in remaining:\n                lst.append(x)\n                generate_combinations(lst, remaining[remaining.index(x)+1:])\n                lst.pop()\n    generate_combinations([], list1)\n    return result\n",
    "MbppEval/563": "import re\n\ndef extract_values(text):\n    values = re.findall(r'\"([^\"]*)\"', text)\n    return values\n",
    "MbppEval/565": "def split(word):\n    chars = []\n    for char in word:\n        chars.append(char)\n    return chars\n",
    "MbppEval/472": "def check_Consecutive(l):\n    \"\"\"\n    Write a python function to check whether the given list contains consecutive numbers or not.\n\n    Examples:\n    check_Consecutive([1,2,3,4,5]) == True\n    check_Consecutive([1,2,3,5,6]) == False\n    check_Consecutive([1,2,1]) == False\n    \"\"\"\n    if len(l) < 2:\n        return True\n\n    l.sort()\n    for i in range(1, len(l)):\n        if l[i] - l[i-1] != 1:\n            return False\n    return True\n",
    "MbppEval/574": "import math\n\ndef surfacearea_cylinder(r, h):\n    surface_area = 2 * math.pi * r * (r + h)\n    return round(surface_area, 2)\n",
    "MbppEval/573": "def unique_product(list_data):\n    unique_nums = set()\n    product = 1\n    \n    for num in list_data:\n        if num not in unique_nums:\n            unique_nums.add(num)\n            product *= num\n    \n    return product\n",
    "MbppEval/569": "def sort_sublists(list1):\n    sorted_list = []\n    for sub_list in list1:\n        sorted_sub_list = sorted(sub_list)\n        sorted_list.append(sorted_sub_list)\n    return sorted_list\n",
    "MbppEval/567": "def issort_list(list1):\n    is_sorted = True\n    for i in range(len(list1) - 1):\n        if list1[i] > list1[i + 1]:\n            is_sorted = False\n            break\n    return is_sorted\n",
    "MbppEval/577": "def last_Digit_Factorial(n):\n    last_digit_cycle = [1, 2, 6, 4]\n    return last_digit_cycle[n % 4]\n",
    "MbppEval/579": "def find_dissimilar(test_tup1, test_tup2):\n    dissimilar_elements = set()\n    \n    for element in test_tup1:\n        if element not in test_tup2:\n            dissimilar_elements.add(element)\n    \n    for element in test_tup2:\n        if element not in test_tup1:\n            dissimilar_elements.add(element)\n    \n    return tuple(dissimilar_elements)\n",
    "MbppEval/582": "def my_dict(dict1):\n    if len(dict1) == 0:\n        return True\n    else:\n        return False\n",
    "MbppEval/474": "def replace_char(str1, ch, newch):\n    new_str = \"\"\n    for c in str1:\n        if c == ch:\n            new_str += newch\n        else:\n            new_str += c\n    return new_str\n",
    "MbppEval/554": "def Split(list_of_integers):\n    odd_numbers = []\n    for num in list_of_integers:\n        if num % 2 != 0:\n            odd_numbers.append(num)\n    return odd_numbers\n",
    "MbppEval/442": "def positive_count(nums):\n    positive_count = 0\n    for num in nums:\n        if num > 0:\n            positive_count += 1\n    return positive_count / len(nums)\n",
    "MbppEval/576": "def is_Sub_Array(A, B):\n    i, j = 0, 0\n    while i < len(A) and j < len(B):\n        if A[i] == B[j]:\n            i += 1\n            j += 1\n            if j == len(B):\n                return True\n        else:\n            i += 1\n    return False\n",
    "MbppEval/588": "def big_diff(nums):\n    max_num = max(nums)\n    min_num = min(nums)\n    return max_num - min_num\n",
    "MbppEval/595": "def min_Swaps(str1, str2):\n    if len(str1) != len(str2):\n        return \"Not Possible\"\n\n    diff_count = 0\n    for i in range(len(str1)):\n        if str1[i] != str2[i]:\n            diff_count += 1\n\n    if diff_count % 2 != 0:\n        return \"Not Possible\"\n\n    return diff_count // 2\n",
    "MbppEval/578": "def interleave_lists(list1, list2, list3):\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        return []\n\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n\n    return result\n",
    "MbppEval/557": "def toggle_string(string):\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char.lower()\n        else:\n            result += char.upper()\n    return result\n",
    "MbppEval/585": "import heapq\n\ndef expensive_items(items, n):\n    \"\"\"\n    Find the n most expensive items in a given dataset.\n    \"\"\"\n    # Create a max heap to store the n most expensive items\n    heap = []\n\n    # Iterate through the items and update the heap\n    for item in items:\n        if len(heap) < n:\n            heapq.heappush(heap, (-item['price'], item))\n        elif -heap[0][0] < item['price']:\n            heapq.heappop(heap)\n            heapq.heappush(heap, (-item['price'], item))\n\n    # Return the n most expensive items\n    return [item for _, item in heap]\n",
    "MbppEval/589": "import math\n\ndef perfect_squares(a, b):\n    perfect_squares_list = []\n\n    for num in range(a, b + 1):\n        if int(math.sqrt(num)) ** 2 == num:\n            perfect_squares_list.append(num)\n\n    return perfect_squares_list\n",
    "MbppEval/441": "def surfacearea_cube(l):\n    return 6 * l**2\n",
    "MbppEval/586": "def split_Arr(l, n):\n    return l[n:] + l[:n]\n",
    "MbppEval/599": "def sum_average(number):\n    \"\"\"\n    Write a function to find the sum and average of the first n natural numbers.\n\n    Examples:\n    sum_average(10) == (55, 5.5)\n    sum_average(15) == (120, 8.0)\n    sum_average(20) == (210, 10.5)\n    \"\"\"\n    total_sum = (number * (number + 1)) // 2\n    average = total_sum / number\n    return (total_sum, average)\n",
    "MbppEval/600": "def is_Even(n):\n    if n % 2 == 0:\n        return True\n    else:\n        return False\n",
    "MbppEval/587": "def list_tuple(listx):\n    return tuple(listx)\n",
    "MbppEval/583": "def catalan_number(num):\n    \"\"\"\n    Returns the nth Catalan number.\n\n    Args:\n        num (int): The index of the Catalan number to calculate.\n\n    Returns:\n        int: The nth Catalan number.\n    \"\"\"\n    def factorial(n):\n        \"\"\"Helper function to calculate the factorial of a number.\"\"\"\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n\n    numerator = factorial(2*num)\n    denominator = factorial(num+1) * factorial(num)\n    return numerator // denominator\n",
    "MbppEval/611": "def max_of_nth(test_list, N):\n    max_value = float('-inf')\n    \n    for row in test_list:\n        max_value = max(max_value, row[N])\n    \n    return max_value\n",
    "MbppEval/572": "def two_unique_nums(nums):\n    unique_nums = set()\n    for num in nums:\n        unique_nums.add(num)\n    return list(unique_nums)\n",
    "MbppEval/592": "def sum_Of_product(n):\n    return n * (2 ** n - 1)\n",
    "MbppEval/584": "import re\n\ndef find_adverbs(text):\n    pattern = r'\\w+ly'\n    match = re.search(pattern, text)\n    if match:\n        adverb = match.group()\n        start = match.start()\n        end = match.end()\n        return f\"{start}-{end}: {adverb}\"\n    else:\n        return None\n",
    "MbppEval/606": "import math\n\ndef radian_degree(degree):\n    \"\"\"\n    Write a function to convert degrees to radians.\n\n    Examples:\n    radian_degree(90) == 1.5707963267948966\n    radian_degree(60) == 1.0471975511965976\n    radian_degree(120) == 2.0943951023931953\n    \"\"\"\n    return math.radians(degree)\n",
    "MbppEval/478": "import re\n\ndef remove_lowercase(str1):\n    pattern = r'[a-z]+'\n    result = re.sub(pattern, '', str1)\n    return result\n",
    "MbppEval/616": "def tuple_modulo(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length\")\n    \n    result = []\n    for a, b in zip(test_tup1, test_tup2):\n        result.append(a % b)\n    \n    return tuple(result)\n",
    "MbppEval/591": "def swap_List(new_list):\n    first = new_list[0]\n    last = new_list[-1]\n    new_list[0] = last\n    new_list[-1] = first\n    return new_list\n",
    "MbppEval/590": "import cmath\n\ndef polar_rect(x, y):\n    r = cmath.sqrt(x**2 + y**2)\n    theta = cmath.atan2(y, x)\n    x_rect = r * cmath.cos(theta)\n    y_rect = r * cmath.sin(theta)\n    return ((x_rect, y_rect), complex(x_rect, y_rect))\n",
    "MbppEval/594": "def diff_even_odd(list1):\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None:\n        first_even = 0\n    if first_odd is None:\n        first_odd = 0\n    \n    return abs(first_even - first_odd)\n",
    "MbppEval/608": "from math import e, factorial\n\ndef bell_Number(n):\n    \"\"\"\n    Find the nth Bell number.\n    \n    Parameters:\n    n (int): The index of the Bell number to find.\n    \n    Returns:\n    int: The nth Bell number.\n    \"\"\"\n    return round(e ** sum((-1)**k * factorial(n) / (factorial(k) * factorial(n-k)) for k in range(n+1)))\n",
    "MbppEval/604": "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n",
    "MbppEval/612": "def merge(lst):\n    first_elements = []\n    second_elements = []\n\n    for sub_list in lst:\n        first_elements.append(sub_list[0])\n        second_elements.append(sub_list[1])\n\n    return [first_elements, second_elements]\n",
    "MbppEval/597": "def find_kth(arr1, arr2, k):\n    i, j = 0, 0\n    count = 0\n\n    while count < k - 1:\n        if i < len(arr1) and (j >= len(arr2) or arr1[i] < arr2[j]):\n            i += 1\n        else:\n            j += 1\n        count += 1\n\n    if i < len(arr1) and (j >= len(arr2) or arr1[i] < arr2[j]):\n        return arr1[i]\n    else:\n        return arr2[j]\n",
    "MbppEval/610": "def remove_kth_element(list1, k):\n    new_list = []\n    for i in range(len(list1)):\n        if i != k-1:\n            new_list.append(list1[i])\n    return new_list\n",
    "MbppEval/619": "def move_num(test_str):\n    non_numeric = \"\"\n    numeric = \"\"\n    \n    for char in test_str:\n        if char.isdigit():\n            numeric += char\n        else:\n            non_numeric += char\n    \n    return non_numeric + numeric\n",
    "MbppEval/596": "import sys\n\ndef tuple_size(tuple_list):\n    \"\"\"\n    Write a function to find the size in bytes of the given tuple.\n\n    Examples:\n    tuple_size((\"A\", 1, \"B\", 2, \"C\", 3)) == 72\n    tuple_size((1, \"Raju\", 2, \"Nikhil\", 3, \"Deepanshu\")) == 192\n    tuple_size(((1, \"Lion\"), (2, \"Tiger\"), (3, \"Fox\"), (4, \"Wolf\"))) == 160\n    \"\"\"\n    total_size = 0\n    for element in tuple_list:\n        total_size += sys.getsizeof(element)\n    return total_size\n",
    "MbppEval/598": "def armstrong_number(number):\n    \"\"\"\n    Write a function to check whether the given number is armstrong or not.\n\n    Examples:\n    armstrong_number(153) == True\n    armstrong_number(259) == False\n    armstrong_number(4458) == False\n    \"\"\"\n    num_str = str(number)\n    length = len(num_str)\n    sum_of_cubes = 0\n\n    for digit in num_str:\n        sum_of_cubes += int(digit) ** length\n\n    return number == sum_of_cubes\n",
    "MbppEval/624": "def is_upper(string):\n    return string.upper()\n",
    "MbppEval/625": "def swap_List(newList):\n    if len(newList) < 2:\n        return newList\n\n    first_element = newList[0]\n    newList[0] = newList[-1]\n    newList[-1] = first_element\n\n    return newList\n",
    "MbppEval/581": "def surface_Area(b, s):\n    base_area = b ** 2\n    face_area = 4 * ((b * s) / 2)\n    total_area = base_area + face_area\n    return total_area\n",
    "MbppEval/607": "import re\n\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return None\n",
    "MbppEval/603": "def get_ludic(n):\n    ludic_numbers = [1]\n    current_ludic = 1\n    \n    while current_ludic <= n:\n        next_ludic = current_ludic + len(ludic_numbers)\n        ludic_numbers.append(next_ludic)\n        current_ludic = next_ludic\n    \n    return ludic_numbers[:-1]\n",
    "MbppEval/618": "def div_list(nums1, nums2):\n    \"\"\"\n    Write a function to divide two lists element-wise.\n\n    Examples:\n    div_list([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]\n    div_list([3, 2], [1, 4]) == [3.0, 0.5]\n    div_list([90, 120], [50, 70]) == [1.8, 1.7142857142857142]\n    \"\"\"\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    return [a / b for a, b in zip(nums1, nums2)]\n",
    "MbppEval/622": "def get_median(arr1, arr2, n):\n    i, j = 0, 0\n    count = 0\n    median = 0\n\n    while i < n and j < n:\n        if arr1[i] < arr2[j]:\n            count += 1\n            if count == (n - 1) // 2:\n                median = arr1[i]\n            i += 1\n        else:\n            count += 1\n            if count == (n - 1) // 2:\n                median = arr2[j]\n            j += 1\n\n    if n % 2 == 0:\n        if i < n:\n            median = (median + arr1[i]) / 2\n        else:\n            median = (median + arr2[j]) / 2\n\n    return median\n",
    "MbppEval/620": "def largest_subset(a):\n    a.sort()\n    subset = [a[0]]\n    max_size = 1\n\n    for i in range(1, len(a)):\n        if all(a[i] % num == 0 or num % a[i] == 0 for num in subset):\n            subset.append(a[i])\n            max_size = max(max_size, len(subset))\n\n    return max_size\n",
    "MbppEval/631": "def replace_spaces(text):\n    new_text = \"\"\n    for char in text:\n        if char.isspace():\n            new_text += \"_\"\n        elif char == \"_\":\n            new_text += \" \"\n        else:\n            new_text += char\n    return new_text\n",
    "MbppEval/644": "def reverse_Array_Upto_K(input_array, k):\n    reversed_array = []\n    for i in range(k):\n        reversed_array.append(input_array[k-i-1])\n    for i in range(k, len(input_array)):\n        reversed_array.append(input_array[i])\n    return reversed_array\n",
    "MbppEval/722": "def filter_data(students, h, w):\n    filtered_students = {}\n    for student, (height, weight) in students.items():\n        if height >= h and weight >= w:\n            filtered_students[student] = (height, weight)\n    return filtered_students\n",
    "MbppEval/721": "def maxAverageOfPath(cost):\n    n = len(cost)\n    dp = [[0] * n for _ in range(n)]\n    max_average = 0\n\n    # Initialize the top-left cell\n    dp[0][0] = cost[0][0]\n\n    # Compute the maximum average cost for each cell\n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n            elif i == 0:\n                dp[i][j] = (dp[i][j-1] + cost[i][j]) / (j + 1)\n            elif j == 0:\n                dp[i][j] = (dp[i-1][j] + cost[i][j]) / (i + 1)\n            else:\n                dp[i][j] = max((dp[i-1][j] + cost[i][j]) / (i + 1),\n                              (dp[i][j-1] + cost[i][j]) / (j + 1))\n            max_average = max(max_average, dp[i][j])\n\n    return max_average\n",
    "MbppEval/637": "def noprofit_noloss(actual_cost, sale_amount):\n    profit_loss = sale_amount - actual_cost\n    return profit_loss == 0\n",
    "MbppEval/639": "def sample_nam(sample_names):\n    uppercase_names = []\n    for name in sample_names:\n        if name[0].isupper():\n            uppercase_names.append(name)\n    return sum(len(name) for name in uppercase_names)\n",
    "MbppEval/614": "def cummulative_sum(test_list):\n    total = 0\n    for tup in test_list:\n        total += sum(tup)\n    return total\n",
    "MbppEval/724": "def power_base_sum(base, power):\n    result = base ** power\n    result_str = str(result)\n    sum_of_digits = 0\n    for digit in result_str:\n        sum_of_digits += int(digit)\n    return sum_of_digits\n",
    "MbppEval/627": "def find_First_Missing(array, start=0, array_length=None):\n    '''\n    Write a python function to find the smallest missing number from a sorted list of natural numbers.\n\n    Examples:\n    find_First_Missing([0,1,2,3],0,3) == 4\n    find_First_Missing([0,1,2,6,9],0,4) == 3\n    find_First_Missing([2,3,5,8,9],0,4) == 0\n    '''\n    \n    # Check if the array is empty\n    if not array:\n        return 0\n    \n    # Check if the array starts with 0 and has length 1\n    if array[0] == 0 and len(array) == 1:\n        return 1\n    \n    # If array_length is not provided, set it to the length of the array\n    if array_length is None:\n        array_length = len(array)\n    \n    # Iterate through the array\n    for i in range(start, array_length):\n        if array[i] != i:\n            return i\n    \n    # If no missing number is found, return the length of the array\n    return array_length\n",
    "MbppEval/643": "import re\n\ndef text_match_wordz_middle(text):\n    pattern = r'\\b\\w*z\\w*\\b'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
    "MbppEval/728": "def sum_list(lst1, lst2):\n    result = []\n    for i in range(len(lst1)):\n        result.append(lst1[i] + lst2[i])\n    return result\n",
    "MbppEval/431": "def common_element(list1, list2):\n    has_common = False\n    for element in list1:\n        if element in list2:\n            has_common = True\n            break\n    return has_common\n",
    "MbppEval/629": "def Split(lst):\n    even_numbers = []\n    for num in lst:\n        if num % 2 == 0:\n            even_numbers.append(num)\n    return even_numbers\n",
    "MbppEval/640": "import re\n\ndef remove_parenthesis(items):\n    result = []\n    for item in items:\n        modified_item = re.sub(r'\\([^)]*\\)', '', item)\n        result.append(modified_item)\n    return result\n",
    "MbppEval/726": "def multiply_elements(test_tup):\n    output = ()\n    for i in range(len(test_tup) - 1):\n        output += (test_tup[i] * test_tup[i+1],)\n    return output\n",
    "MbppEval/635": "import heapq as hq\n\ndef heap_sort(iterable):\n    \"\"\"\n    Write a function to sort the given list.\n\n    Examples:\n    heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    heap_sort([25, 35, 22, 85, 14, 65, 75, 25, 58]) == [14, 22, 25, 25, 35, 58, 65, 75, 85]\n    heap_sort([7, 1, 9, 5]) == [1, 5, 7, 9]\n    \"\"\"\n    heap = list(iterable)\n    hq.heapify(heap)\n    return [hq.heappop(heap) for _ in range(len(heap))]\n",
    "MbppEval/633": "def pair_xor_Sum(arr, n):\n    total_sum = 0\n    for i in range(n):\n        temp_xor = 0\n        for j in range(i+1, n):\n            temp_xor ^= arr[j]\n        total_sum += temp_xor\n    return total_sum\n",
    "MbppEval/638": "import math\n\ndef wind_chill(v, t):\n    \"\"\"\n    Write a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\n    Examples:\n    wind_chill(120, 35) == 40\n    wind_chill(40, 70) == 86\n    wind_chill(10, 100) == 116\n    \"\"\"\n    wind_chill = 13.12 + 0.6215 * t - 11.37 * v**0.16 + 0.3965 * t * v**0.16\n    return math.ceil(wind_chill)\n",
    "MbppEval/605": "def prime_num(num):\n    \"\"\"\n    Write a function to check if the given integer is a prime number.\n\n    Examples:\n    prime_num(13) == True\n    prime_num(7) == True\n    prime_num(-1010) == False\n    \"\"\"\n    is_prime = True\n\n    # Handle negative numbers\n    if num < 0:\n        is_prime = False\n        return is_prime\n\n    # Handle 0 and 1\n    if num in [0, 1]:\n        is_prime = False\n        return is_prime\n\n    # Check if the number is divisible by any number from 2 to the square root of the number\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            is_prime = False\n            break\n\n    return is_prime\n",
    "MbppEval/602": "def first_repeated_char(str1):\n    unique_chars = set()\n    for char in str1:\n        if char in unique_chars:\n            return char\n        unique_chars.add(char)\n    return \"None\"\n",
    "MbppEval/593": "import re\n\ndef removezero_ip(ip):\n    octets = ip.split('.')\n    cleaned_octets = [str(int(octet)) for octet in octets]\n    cleaned_ip = '.'.join(cleaned_octets)\n    return cleaned_ip\n",
    "MbppEval/736": "import bisect\n\ndef left_insertion(a, x):\n    return bisect.bisect_left(a, x)\n",
    "MbppEval/737": "import re\n\nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\n\ndef check_str(string):\n    if re.match(regex, string):\n        return 'Valid'\n    else:\n        return 'Invalid'\n",
    "MbppEval/731": "import math\n\ndef lateralsurface_cone(r, h):\n    l = math.sqrt(r**2 + h**2)\n    lateral_surface_area = math.pi * r * l\n    return lateral_surface_area\n",
    "MbppEval/725": "import re\n\ndef extract_quotation(text1):\n    quoted_strings = re.findall(r'\"(.*?)\"', text1)\n    return quoted_strings\n",
    "MbppEval/732": "import re\n\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)\n",
    "MbppEval/623": "def nth_nums(nums, n):\n    return [num ** n for num in nums]\n",
    "MbppEval/730": "from itertools import groupby\n\ndef consecutive_duplicates(nums):\n    return [k for k, _ in groupby(nums)]\n",
    "MbppEval/739": "import math\n\ndef find_Index(n):\n    k = 1\n    while True:\n        triangular_number = k * (k + 1) // 2\n        if int(math.log10(triangular_number)) + 1 >= n:\n            return k\n        k += 1\n",
    "MbppEval/744": "def check_none(test_tup):\n    for element in test_tup:\n        if element is None:\n            return True\n    return False\n",
    "MbppEval/738": "def geometric_sum(n):\n    return 2 - (0.5 ** (n - 1))\n",
    "MbppEval/734": "def sum_Of_Subarray_Prod(arr):\n    n = len(arr)\n    result = 0\n    \n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            result += product\n    \n    return result\n",
    "MbppEval/741": "def all_Characters_Same(s):\n    unique_chars = set(s)\n    return len(unique_chars) == 1\n",
    "MbppEval/735": "def set_middle_bits(n):\n    binary_str = format(n, 'b')\n    mask = int('10' + '0' * (len(binary_str) - 2) + '1', 2)\n    result = n ^ mask\n    return result\n",
    "MbppEval/733": "def find_first_occurrence(A, x):\n    left = 0\n    right = len(A) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if A[mid] == x:\n            if mid == 0 or A[mid-1] != x:\n                return mid\n            else:\n                right = mid - 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n",
    "MbppEval/632": "def move_zero(num_list):\n    \"\"\"\n    Write a python function to move all zeroes to the end of the given list.\n\n    Examples:\n    move_zero([1,0,2,0,3,4]) == [1,2,3,4,0,0]\n    move_zero([2,3,2,0,0,4,0,5,0]) == [2,3,2,4,5,0,0,0,0]\n    move_zero([0,1,0,1,1]) == [1,1,1,0,0]\n    \"\"\"\n    result = [x for x in num_list if x != 0]\n    result.extend([0] * num_list.count(0))\n    return result\n",
    "MbppEval/742": "import math\n\ndef area_tetrahedron(side):\n    return math.sqrt(3) * side**2\n",
    "MbppEval/745": "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(digit) for digit in str(num)]\n        is_divisible = all(num % digit == 0 for digit in digits)\n        if is_divisible:\n            result.append(num)\n    return result\n",
    "MbppEval/764": "def number_ctr(str):\n    digit_count = 0\n    for char in str:\n        if char.isdigit():\n            digit_count += 1\n    return digit_count\n",
    "MbppEval/757": "def count_reverse_pairs(test_list):\n    reverse_dict = {}\n    count = 0\n    for s in test_list:\n        reverse_s = s[::-1]\n        if reverse_s in reverse_dict:\n            count += 1\n            reverse_dict[reverse_s] += 1\n        else:\n            reverse_dict[reverse_s] = 1\n    return str(count)\n",
    "MbppEval/743": "def rotate_right(lst, m, n):\n    length = len(lst)\n    rotations = m * n % length\n    new_lst = lst[-rotations:] + lst[:-rotations]\n    return new_lst\n",
    "MbppEval/580": "def even_ele(test_tuple, even_fnc):\n    result = ()\n    for element in test_tuple:\n        if isinstance(element, tuple):\n            result += (even_ele(element, even_fnc),)\n        elif even_fnc(element):\n            result += (element,)\n    return result\n",
    "MbppEval/753": "def min_k(test_list, K):\n    \"\"\"\n    Write a function to find minimum k records from tuple list.\n    Examples:\n    min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]\n    min_k([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]\n    min_k([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]\n    \"\"\"\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    return sorted_list[:K]\n",
    "MbppEval/630": "def adjac(ele):\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given coordinate tuple.\n\n    Examples:\n    adjac((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n    adjac((4, 5)) == [[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]\n    adjac((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]\n    \"\"\"\n    return [[x, y] for x in range(ele[0] - 1, ele[0] + 2) for y in range(ele[1] - 1, ele[1] + 2) if (x, y) != ele]\n",
    "MbppEval/766": "def pair_wise(l1):\n    pairs = []\n    for i in range(len(l1) - 1):\n        pairs.append((l1[i], l1[i+1]))\n    return pairs\n",
    "MbppEval/760": "def unique_Element(arr):\n    unique_set = set(arr)\n    if len(unique_set) == 1:\n        return 'YES'\n    else:\n        return 'NO'\n",
    "MbppEval/752": "def jacobsthal_num(n):\n    \"\"\"\n    Find the nth Jacobsthal number.\n\n    Args:\n        n (int): The index of the Jacobsthal number to find.\n\n    Returns:\n        int: The nth Jacobsthal number.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return jacobsthal_num(n-1) + jacobsthal_num(n-2) + 1\n",
    "MbppEval/769": "def Diff(li1, li2):\n    result = []\n    \n    # Iterate through the first list and add elements not in the second list\n    for item in li1:\n        if item not in li2:\n            result.append(item)\n    \n    # Iterate through the second list and add elements not in the first list\n    for item in li2:\n        if item not in li1:\n            result.append(item)\n    \n    return result\n",
    "MbppEval/772": "def remove_length(test_str, K):\n    words = test_str.split()\n    new_words = [word for word in words if len(word) != K]\n    return ' '.join(new_words)\n",
    "MbppEval/765": "import math\n\ndef is_polite(n):\n    \"\"\"\n    Find the nth polite number.\n    \"\"\"\n    polite_numbers = [1]  # Start with the base case of 1\n    i = 1\n    while len(polite_numbers) < n:\n        # Add the next power of 2\n        polite_numbers.append(2 ** i)\n        \n        # Find all the possible sums of distinct powers of 2 less than or equal to the current power of 2\n        for j in range(i):\n            polite_numbers.append(2 ** j + 2 ** i)\n        \n        i += 1\n    \n    return polite_numbers[n-1]\n",
    "MbppEval/751": "def check_min_heap_helper(arr, i):\n    left_child_idx = 2 * i + 1\n    right_child_idx = 2 * i + 2\n    \n    # Check if the current node is smaller than its left and right child nodes\n    if left_child_idx < len(arr) and arr[i] > arr[left_child_idx]:\n        return False\n    if right_child_idx < len(arr) and arr[i] > arr[right_child_idx]:\n        return False\n    \n    # Recursively check the left and right subtrees\n    if left_child_idx < len(arr):\n        if not check_min_heap_helper(arr, left_child_idx):\n            return False\n    if right_child_idx < len(arr):\n        if not check_min_heap_helper(arr, right_child_idx):\n            return False\n    \n    return True\n",
    "MbppEval/763": "def find_min_diff(arr, n):\n    if n < 2:\n        return 0\n\n    # Initialize min_diff to a very large value\n    min_diff = float('inf')\n\n    # Sort the input array\n    arr.sort()\n\n    # Iterate through the sorted array, calculating the difference between adjacent elements\n    for i in range(1, n):\n        diff = abs(arr[i] - arr[i - 1])\n        if diff < min_diff:\n            min_diff = diff\n\n    return min_diff\n",
    "MbppEval/756": "import re\n\ndef text_match_zero_one(text):\n    pattern = r'ab+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
    "MbppEval/755": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None\n    \n    smallest = float('inf')\n    second_smallest = float('inf')\n    \n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    \n    return second_smallest\n",
    "MbppEval/758": "def unique_sublists(list1):\n    sublist_counts = {}\n    for sublist in list1:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_counts:\n            sublist_counts[sublist_tuple] += 1\n        else:\n            sublist_counts[sublist_tuple] = 1\n    return sublist_counts\n",
    "MbppEval/748": "import re\n\ndef capital_words_spaces(str1):\n    result = \"\"\n    for i, char in enumerate(str1):\n        if i > 0 and char.isupper() and str1[i-1] != \" \":\n            result += \" \"\n        result += char\n    return result\n",
    "MbppEval/723": "from operator import eq\n\ndef count_same_pair(nums1, nums2):\n    if len(nums1) != len(nums2):\n        return 0\n\n    match_indices = {}\n    count = 0\n\n    for i in range(len(nums1)):\n        if eq(nums1[i], nums2[i]):\n            match_indices[i] = True\n            count += 1\n\n    return count\n",
    "MbppEval/767": "def get_pairs_count(arr, target_sum):\n    arr.sort()\n    count = 0\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target_sum:\n            count += 1\n            left += 1\n            right -= 1\n            \n            # Skip over duplicates\n            while left < right and arr[left] == arr[left - 1]:\n                left += 1\n            while left < right and arr[right] == arr[right + 1]:\n                right -= 1\n        elif current_sum < target_sum:\n            left += 1\n        else:\n            right -= 1\n    \n    return count\n",
    "MbppEval/762": "def check_monthnumber_number(monthnum3):\n    months_with_30_days = [4, 6, 9, 11]\n    return monthnum3 in months_with_30_days\n",
    "MbppEval/771": "from collections import deque\n\ndef check_expression(exp):\n    stack = deque()\n    opening_brackets = '{[('\n    closing_brackets = '}])'\n    bracket_pairs = {'}': '{', ']': '[', ')': '('}\n\n    for char in exp:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack:\n                return False\n            top_bracket = stack.pop()\n            if bracket_pairs[char] != top_bracket:\n                return False\n\n    return len(stack) == 0\n",
    "MbppEval/776": "def count_vowels(test_str):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    \n    for i in range(len(test_str)):\n        if test_str[i] in vowels:\n            if (i > 0 and test_str[i-1] in vowels) or (i < len(test_str)-1 and test_str[i+1] in vowels):\n                count += 1\n    \n    return count\n",
    "MbppEval/746": "import math\n\ndef sector_area(r, a):\n    '''\n    Write a function to find area of a sector. The function takes the radius and angle as inputs. Function should return None if the angle is larger than 360 degrees.\n\n    Examples:\n    sector_area(4, 45) == 6.285714285714286\n    sector_area(9, 45) == 31.82142857142857\n    sector_area(9, 360) == None\n    '''\n    if a > 360:\n        return None\n    \n    theta = math.radians(a)\n    area = (r ** 2 * theta) / 2\n    return area\n",
    "MbppEval/770": "def odd_num_sum(n):\n    total_sum = 0\n    for i in range(1, 2 * n, 2):\n        total_sum += i ** 4\n    return total_sum\n",
    "MbppEval/779": "def unique_sublists(list1):\n    result = {}\n    for sublist in list1:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        else:\n            result[sublist_tuple] = 1\n    return result\n",
    "MbppEval/773": "import re\n\ndef occurance_substring(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return None\n",
    "MbppEval/750": "def add_tuple(test_list, test_tup):\n    return test_list + list(test_tup)\n",
    "MbppEval/749": "def sort_numeric_strings(nums_str):\n    sorted_nums = []\n    for num_str in nums_str:\n        sorted_nums.append(int(num_str))\n    sorted_nums.sort()\n    return sorted_nums\n",
    "MbppEval/747": "def lcs_of_three(X, Y, Z):\n    m, n, o = len(X), len(Y), len(Z)\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                if X[i - 1] == Y[j - 1] == Z[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n\n    return dp[m][n][o]\n",
    "MbppEval/759": "import re\n\ndef is_decimal(num):\n    return bool(re.match(r'^\\d+\\.\\d{2}$', num))\n",
    "MbppEval/803": "def is_perfect_square(n):\n    sqrt = n ** 0.5\n    return sqrt.is_integer()\n",
    "MbppEval/787": "import re\n\ndef text_match_three(text):\n    pattern = r'ab{3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
    "MbppEval/799": "def left_rotate(n, d):\n    bin_n = format(n, '032b')\n    rotated_bits = bin_n[d:] + bin_n[:d]\n    return int(rotated_bits, 2)\n",
    "MbppEval/786": "import bisect\n\ndef right_insertion(a, x):\n    return bisect.bisect_right(a, x)\n",
    "MbppEval/802": "def count_rotation(arr, n):\n    low = 0\n    high = n - 1\n    \n    while low < high:\n        mid = (low + high) // 2\n        \n        if arr[mid] > arr[high]:\n            low = mid + 1\n        else:\n            high = mid\n    \n    return high\n",
    "MbppEval/796": "def return_sum(dictionary):\n    total = 0\n    for value in dictionary.values():\n        total += value\n    return total\n",
    "MbppEval/791": "def remove_nested(test_tup):\n    result = []\n    for item in test_tup:\n        if not isinstance(item, tuple):\n            result.append(item)\n    return tuple(result)\n",
    "MbppEval/783": "import math\n\ndef rgb_to_hsv(r, g, b):\n    r, g, b = r/255.0, g/255.0, b/255.0\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx - mn\n    if mx == 0:\n        s = 0\n    else:\n        s = (df/mx)*100\n    if df == 0:\n        h = 0\n    elif mx == r:\n        h = (60 * ((g-b)/df)+360)%360\n    elif mx == g:\n        h = (60 * ((b-r)/df)+120)%360\n    elif mx == b:\n        h = (60 * ((r-g)/df)+240)%360\n    v = mx*100\n    return h, s, v\n",
    "MbppEval/775": "def odd_position(nums):\n    result = True\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            result = False\n            break\n    return result\n",
    "MbppEval/805": "def max_sum_list(lists):\n    max_sum = 0\n    max_list = None\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list\n",
    "MbppEval/778": "from itertools import groupby\n\ndef pack_consecutive_duplicates(list1):\n    result = []\n    for _, group in groupby(list1):\n        result.append(list(group))\n    return result\n",
    "MbppEval/740": "def tuple_to_dict(test_tup):\n    result = {}\n    for i in range(0, len(test_tup), 2):\n        if i + 1 < len(test_tup):\n            key = test_tup[i]\n            value = test_tup[i+1]\n            result[key] = value\n    return result\n",
    "MbppEval/798": "def _sum(arr):\n    total = 0\n    for num in arr:\n        total += num\n    return total\n",
    "MbppEval/475": "from collections import Counter\n\ndef sort_counter(dict1):\n    return sorted(Counter(dict1).items(), key=lambda x: x[1], reverse=True)\n",
    "MbppEval/797": "def sum_odd(l, r):\n    sum = 0\n    for num in range(l, r+1):\n        if num % 2 != 0:\n            sum += num\n    return sum\n",
    "MbppEval/790": "def even_position(nums):\n    is_even_pos = True\n    for i in range(len(nums)):\n        if i % 2 == 0 and nums[i] % 2 != 0:\n            is_even_pos = False\n            break\n    return is_even_pos\n",
    "MbppEval/785": "def tuple_str_int(test_str):\n    return tuple(int(x) for x in test_str.strip(\"()\").split(\", \"))\n",
    "MbppEval/615": "def average_tuple(nums):\n    averages = []\n    for tup in nums:\n        avg = sum(tup) / len(tup)\n        averages.append(avg)\n    return averages\n",
    "MbppEval/784": "def mul_even_odd(list1):\n    first_even = None\n    first_odd = None\n    product = 1\n\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n\n    if first_even is not None and first_odd is not None:\n        product = first_even * first_odd\n\n    return product\n",
    "MbppEval/804": "def is_product_even(arr):\n    product = 1\n    for num in arr:\n        product *= num\n    return product % 2 == 0\n",
    "MbppEval/807": "def first_odd(nums):\n    first_odd_num = None\n    for num in nums:\n        if num % 2 != 0:\n            first_odd_num = num\n            break\n    return first_odd_num\n",
    "MbppEval/806": "def max_run_uppercase(test_str):\n    max_run = 0\n    current_run = 0\n    for char in test_str:\n        if char.isupper():\n            current_run += 1\n        else:\n            current_run = 0\n        max_run = max(max_run, current_run)\n    return max_run\n",
    "MbppEval/793": "def last(arr, x, n):\n    left = 0\n    right = n - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == x:\n            right = mid - 1\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    if left > right:\n        return -1\n    else:\n        return right + 1\n",
    "MbppEval/808": "def check_K(test_tup, K):\n    contains_K = False\n    for element in test_tup:\n        if element == K:\n            contains_K = True\n            break\n    return contains_K\n",
    "MbppEval/809": "def check_smaller(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        return False\n    for i in range(len(test_tup1)):\n        if test_tup2[i] >= test_tup1[i]:\n            return False\n    return True\n",
    "MbppEval/792": "def count_list(input_list):\n    return sum(isinstance(element, list) for element in input_list)\n",
    "MbppEval/794": "import re\n\ndef text_starta_endb(text):\n    pattern = r'a.*b$'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
    "MbppEval/777": "def find_sum(arr):\n    total = 0\n    unique_elements = set()\n\n    for num in arr:\n        if num not in unique_elements:\n            unique_elements.add(num)\n            total += num\n\n    return total\n",
    "MbppEval/781": "import math\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    \n    if count % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n",
    "MbppEval/240": "def replace_list(list1, list2):\n    return list1[:-1] + list2\n",
    "MbppEval/780": "def find_combinations(test_list):\n    combinations_list = []\n    for tup in test_list:\n        sum1 = tup[0]\n        sum2 = tup[1]\n        combinations_list.append((sum1, sum2))\n    return combinations_list\n",
    "MbppEval/782": "def odd_length_sum(arr):\n    total_sum = 0\n    current_sum = 0\n    current_length = 0\n    for num in arr:\n        current_sum += num\n        current_length += 1\n        if current_length % 2 == 1:\n            total_sum += current_sum\n        else:\n            current_sum = 0\n    return total_sum\n",
    "MbppEval/290": "def max_length(list1):\n    max_len = 0\n    max_list = None\n\n    for inner_list in list1:\n        if len(inner_list) > max_len:\n            max_len = len(inner_list)\n            max_list = inner_list\n\n    return (max_len, max_list)\n",
    "MbppEval/754": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    \n    for i in range(len(l1)):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements\n",
    "MbppEval/400": "def extract_freq(test_list):\n    unique_tuples = set()\n    for tup in test_list:\n        unique_tuples.add(tup)\n    return len(unique_tuples)\n",
    "MbppEval/408": "import heapq\n\ndef k_smallest_pairs(nums1, nums2, k):\n    if not nums1 or not nums2:\n        return []\n\n    minheap = []\n    for num1 in nums1:\n        heapq.heappush(minheap, (num1 + nums2[0], num1, nums2[0]))\n\n    result = []\n    while k > 0 and minheap:\n        _, num1, num2 = heapq.heappop(minheap)\n        result.append([num1, num2])\n        k -= 1\n\n        if len(nums2) > 1:\n            heapq.heappush(minheap, (num1 + nums2[1], num1, nums2[1]))\n\n    return result\n",
    "MbppEval/71": "def comb_sort(nums):\n    n = len(nums)\n    gap = n\n    swapped = True\n\n    while gap > 1 or swapped:\n        gap = int(gap / 1.25)\n        if gap < 1:\n            gap = 1\n        swapped = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n\n    return nums\n",
    "MbppEval/270": "def sum_even_and_even_index(arr):\n    even_sum = 0\n    for i in range(0, len(arr), 2):\n        if arr[i] % 2 == 0:\n            even_sum += arr[i]\n    return even_sum\n",
    "MbppEval/476": "def big_sum(nums):\n    smallest = min(nums)\n    largest = max(nums)\n    return smallest + largest\n",
    "MbppEval/268": "def find_star_num(n):\n    \"\"\"\n    Write a function to find the n'th star number.\n\n    Examples:\n    find_star_num(3) == 37\n    find_star_num(4) == 73\n    find_star_num(5) == 121\n    \"\"\"\n    if n == 1:\n        return 1\n    \n    star_num = 1\n    for i in range(2, n+1):\n        star_num += i\n    \n    return star_num\n",
    "MbppEval/422": "def find_Average_Of_Cube(n):\n    sum_of_cubes = 0\n    for i in range(1, n+1):\n        sum_of_cubes += i**3\n    return sum_of_cubes / n\n",
    "MbppEval/271": "def even_Power_Sum(n):\n    return (2 * n * (2 * n + 1) * (2 * n + 2) * (2 * n + 3) * (2 * n + 4)) // 5",
    "MbppEval/641": "def is_nonagonal(n):\n    return (n * (7 * n - 5)) // 2\n",
    "MbppEval/460": "def Extract(lst):\n    result = []\n    for sublst in lst:\n        result.append(sublst[0])\n    return result\n",
    "MbppEval/127": "def multiply_int(x, y):\n    if not isinstance(x, int) or not isinstance(y, int):\n        return \"Error: Both arguments must be integers.\"\n    return x * y\n",
    "MbppEval/405": "def check_tuplex(tuplex, tuple1):\n    return tuple1 in tuplex\n",
    "MbppEval/397": "def median_numbers(a, b, c):\n    numbers = [a, b, c]\n    numbers.sort()\n    return numbers[1]\n",
    "MbppEval/788": "def new_tuple(test_list, test_str):\n    return tuple(test_list + (test_str,))\n",
    "MbppEval/115": "def empty_dit(list1):\n    \"\"\"\n    Write a function to check whether all dictionaries in a list are empty or not.\n\n    Examples:\n    empty_dit([{},{},{}]) == True\n    empty_dit([{1,2},{},{}]) == False\n    empty_dit({}) == True\n    \"\"\"\n    all_empty = True\n    for item in list1:\n        if isinstance(item, dict):\n            if len(item) > 0:\n                all_empty = False\n                break\n    return all_empty\n",
    "MbppEval/800": "import re\n\ndef remove_all_spaces(text):\n    return re.sub(r'\\s+', '', text)\n",
    "MbppEval/628": "def replace_spaces(string):\n    result = \"\"\n    for char in string:\n        if char == \" \":\n            result += \"%20\"\n        else:\n            result += char\n    return result\n",
    "MbppEval/626": "def triangle_area(r):\n    if r == 0:\n        return 0\n    elif r < 0:\n        return -1\n    else:\n        return r ** 2\n",
    "MbppEval/430": "def parabola_directrix(a, b, c):\n    p = -1 / (4 * a)\n    return -p\n",
    "MbppEval/274": "import math\n\ndef even_binomial_Coeff_Sum(n):\n    sum_even = 0\n    for i in range(0, n+1, 2):\n        sum_even += math.comb(n, i)\n    return sum_even\n",
    "MbppEval/801": "def test_three_equal(x, y, z):\n    count = 0\n    \n    if x == y == z:\n        count = 3\n    elif x == y or y == z or x == z:\n        count = 2\n    else:\n        count = 0\n    \n    return count\n",
    "MbppEval/171": "import math\n\ndef perimeter_pentagon(a):\n    perimeter = a * 5\n    return perimeter\n",
    "MbppEval/562": "def Find_Max_Length(lst):\n    max_length = 0\n    for sublst in lst:\n        current_length = len(sublst)\n        if current_length > max_length:\n            max_length = current_length\n    return max_length\n",
    "MbppEval/311": "def set_left_most_unset_bit(n):\n    \"\"\"\n    Set the leftmost unset bit in the given integer n.\n    \"\"\"\n    # Find the rightmost set bit\n    rightmost_set_bit = n & -n\n    \n    # Shift the rightmost set bit all the way to the left\n    leftmost_unset_bit = rightmost_set_bit << 1\n    \n    # Set the leftmost unset bit\n    return n | leftmost_unset_bit\n",
    "MbppEval/720": "def add_dict_to_tuple(test_tup, test_dict):\n    return test_tup + (test_dict,)\n",
    "MbppEval/135": "def hexagonal_num(n):\n    \"\"\"\n    Write a function to find the nth hexagonal number.\n\n    Examples:\n    hexagonal_num(10) == 190\n    hexagonal_num(5) == 45\n    hexagonal_num(7) == 91\n    \"\"\"\n    return n * (2 * n - 1)\n",
    "MbppEval/617": "import math\n\ndef min_Jumps(steps, d):\n    n = 1\n    while True:\n        total_distance = n * steps * math.sqrt(2)\n        if total_distance == d:\n            return n\n        elif total_distance < d:\n            n += 1\n        else:\n            return n + (d - (n-1) * steps * math.sqrt(2)) / (steps * math.sqrt(2))\n"
}
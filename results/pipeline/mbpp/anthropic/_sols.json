{
    "MbppEval/2": [
        "def similar_elements(test_tup1, test_tup2):\n    shared_elements = set()\n    for element in test_tup1:\n        shared_elements.add(element)\n    result = set()\n    for element in test_tup2:\n        if element in shared_elements:\n            result.add(element)\n    return tuple(result)\n",
        "def similar_elements(test_tup1, test_tup2):\n    common_elements = []\n    \n    for element in test_tup1:\n        if element in test_tup2:\n            common_elements.append(element)\n    \n    return tuple(common_elements)\n",
        "def similar_elements(test_tup1, test_tup2):\n    shared_elements = set(test_tup1) & set(test_tup2)\n    return tuple(shared_elements)\n",
        "def similar_elements(test_tup1, test_tup2):\n    shared_elements = set(test_tup1) & set(test_tup2)\n    return tuple(shared_elements)\n",
        "def similar_elements(test_tup1, test_tup2):\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    common_elements = tuple(set1.intersection(set2))\n    return common_elements\n"
    ],
    "MbppEval/3": [
        "import math\n\ndef is_not_prime(n):\n    '''\n    Write a python function to identify non-prime numbers.\n\n    Examples:\n    is_not_prime(2) == False\n    is_not_prime(10) == True\n    is_not_prime(35) == True\n    '''\n    if n <= 1:\n        return True\n    \n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return True\n    \n    return False\n",
        "import math\n\ndef is_not_prime(n):\n    '''\n    Write a python function to identify non-prime numbers.\n\n    Examples:\n    is_not_prime(2) == False\n    is_not_prime(10) == True\n    is_not_prime(35) == True\n    '''\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return True\n    return False\n",
        "import math\n\ndef is_not_prime(n):\n    '''\n    Write a python function to identify non-prime numbers.\n\n    Examples:\n    is_not_prime(2) == False\n    is_not_prime(10) == True\n    is_not_prime(35) == True\n    '''\n    if n < 2:\n        return True\n    \n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return True\n    \n    return False\n",
        "import math\n\ndef is_not_prime(n):\n    if n <= 1:\n        return True\n    \n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return True\n    \n    return False\n",
        "import math\n\ndef is_not_prime(n):\n    \"\"\"\n    Write a python function to identify non-prime numbers.\n\n    Examples:\n    is_not_prime(2) == False\n    is_not_prime(10) == True\n    is_not_prime(35) == True\n    \"\"\"\n    if n < 2:\n        return True\n    \n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return True\n    \n    return False\n"
    ],
    "MbppEval/4": [
        "import heapq as hq\n\ndef heap_queue_largest(nums, n):\n    return sorted(hq.nlargest(n, nums), reverse=True)\n",
        "import heapq as hq\n\ndef heap_queue_largest(nums, n):\n    return sorted(hq.nlargest(n, nums), reverse=True)\n",
        "import heapq as hq\n\ndef heap_queue_largest(nums, n):\n    heap = []\n    for num in nums:\n        hq.heappush(heap, num)\n        if len(heap) > n:\n            hq.heappop(heap)\n    return sorted(heap, reverse=True)\n",
        "import heapq as hq\n\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Write a function to find the n largest integers from a given list of numbers, returned in descending order.\n\n    Examples:\n    heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]\n    heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 2) == [85, 75]\n    heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 5) == [85, 75, 65, 58, 35]\n    \"\"\"\n    hq.heapify(nums)\n    return hq.nlargest(n, nums)\n",
        "import heapq as hq\n\ndef heap_queue_largest(nums, n):\n    hq.heapify(nums)\n    result = []\n    for _ in range(n):\n        if nums:\n            result.append(hq.heappop(nums))\n    result.reverse()\n    return result\n"
    ],
    "MbppEval/6": [
        "def is_Power_Of_Two(x):\n    \"\"\"\n    Check if a number is a power of two.\n    \n    Args:\n        x (int): The number to check.\n    \n    Returns:\n        bool: True if x is a power of two, False otherwise.\n    \"\"\"\n    if x <= 0:\n        return False\n    return (x & (x - 1)) == 0\n",
        "def differ_At_One_Bit_Pos(x, y):\n    xor_result = x ^ y\n    if bin(xor_result).count('1') == 1:\n        return True\n    else:\n        return False\n",
        "def differ_At_One_Bit_Pos(x, y):\n    xor_result = x ^ y\n    one_bit_count = bin(xor_result).count('1')\n    return one_bit_count == 1\n",
        "def differ_At_One_Bit_Pos(x, y):\n    \"\"\"\n    Check whether the two numbers differ at one bit position only.\n    \n    Args:\n        x (int): The first number.\n        y (int): The second number.\n    \n    Returns:\n        bool: True if the numbers differ at one bit position only, False otherwise.\n    \"\"\"\n    xor_result = x ^ y\n    set_bits = bin(xor_result).count('1')\n    return set_bits == 1\n",
        "def is_Power_Of_Two(x):\n    \"\"\"\n    Check whether the given number is a power of 2.\n    \n    Args:\n        x (int): The number to check.\n    \n    Returns:\n        bool: True if the number is a power of 2, False otherwise.\n    \"\"\"\n    return x > 0 and (x & (x - 1)) == 0\n"
    ],
    "MbppEval/7": [
        "import re\n\ndef find_char_long(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n",
        "import re\n\ndef find_char_long(text):\n    words = re.findall(r'\\b\\w{4,}\\b', text)\n    return words\n",
        "import re\n\ndef find_char_long(text):\n    words = re.findall(r'\\b\\w{4,}\\b', text)\n    return words\n",
        "def find_char_long(text):\n    return [word for word in text.split() if len(word) >= 4]\n",
        "def find_char_long(text):\n    words = text.split()\n    long_words = [word for word in words if len(word) >= 4]\n    return long_words\n"
    ],
    "MbppEval/8": [
        "def square_nums(nums):\n    squared_nums = [num ** 2 for num in nums]\n    return squared_nums\n",
        "def square_nums(nums):\n    squared_nums = []\n    for num in nums:\n        squared_nums.append(num ** 2)\n    return squared_nums\n",
        "def square_nums(nums):\n    squared_nums = []\n    for num in nums:\n        squared_nums.append(num ** 2)\n    return squared_nums\n",
        "def square_nums(nums):\n    squared_nums = []\n    for num in nums:\n        squared_nums.append(num ** 2)\n    return squared_nums\n",
        "def square_nums(nums):\n    squared_nums = []\n    for num in nums:\n        squared_nums.append(num ** 2)\n    return squared_nums\n"
    ],
    "MbppEval/9": [
        "def find_Rotations(s):\n    rotations = 0\n    temp_str = s + s\n    \n    for i in range(len(s)):\n        if s == temp_str[i:i+len(s)]:\n            return rotations\n        rotations += 1\n    \n    return len(s)\n",
        "def find_Rotations(str):\n    return len(str) if str * 2 == str * 2 + str else 1\n",
        "def find_Rotations(s):\n    if not s:\n        return 0\n    \n    doubled_s = s + s\n    for i in range(1, len(s)):\n        if s == doubled_s[i:i+len(s)]:\n            return i\n    \n    return len(s)\n",
        "def find_Rotations(str):\n    min_rotations = len(str)\n    for i in range(1, len(str)):\n        rotated_str = str[i:] + str[:i]\n        if rotated_str == str:\n            min_rotations = i + 1\n            break\n    return min_rotations\n",
        "def find_Rotations(str):\n    doubled_str = str + str\n    index = doubled_str.find(str)\n    return len(str) - index\n"
    ],
    "MbppEval/11": [
        "def remove_Occ(s, ch):\n    result = \"\"\n    first_occurrence = True\n    for c in s:\n        if c != ch:\n            result += c\n        elif c == ch and first_occurrence:\n            first_occurrence = False\n        elif c == ch and not first_occurrence:\n            continue\n    return result\n",
        "def remove_Occ(s, ch):\n    if not s:\n        return s\n\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n\n    if first_index == last_index:\n        return s.replace(ch, \"\", 1)\n    else:\n        return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n",
        "def remove_Occ(s, ch):\n    result = \"\"\n    \n    # Skip the first occurrence of the character\n    if s[0] == ch:\n        result = s[1:]\n    else:\n        result = s\n    \n    # Remove the last occurrence of the character\n    last_index = result.rfind(ch)\n    if last_index != -1:\n        result = result[:last_index] + result[last_index+1:]\n    \n    return result\n",
        "def remove_Occ(s, ch):\n    if not s:\n        return s\n    \n    first_idx = s.index(ch)\n    last_idx = s.rindex(ch)\n    \n    return s[:first_idx] + s[first_idx+1:last_idx] + s[last_idx+1:]\n",
        "def remove_Occ(s, ch):\n    first_idx = s.find(ch)\n    last_idx = s.rfind(ch)\n\n    if first_idx == -1:\n        return s\n\n    return s[:first_idx] + s[first_idx+1:last_idx] + s[last_idx+1:]\n"
    ],
    "MbppEval/12": [
        "def sort_matrix(M):\n    row_sums = [sum(row) for row in M]\n    sorted_matrix = [row for _, row in sorted(zip(row_sums, M))]\n    return sorted_matrix\n",
        "def sort_matrix(M):\n    row_sums = []\n    for row in M:\n        row_sum = sum(row)\n        row_sums.append(row_sum)\n    sorted_matrix = []\n    for row_sum in sorted(row_sums):\n        index = row_sums.index(row_sum)\n        sorted_matrix.append(M[index])\n    return sorted_matrix\n",
        "def sort_matrix(M):\n    row_sums = [sum(row) for row in M]\n    row_tuples = [(row_sum, row) for row_sum, row in zip(row_sums, M)]\n    sorted_row_tuples = sorted(row_tuples)\n    sorted_matrix = [row for _, row in sorted_row_tuples]\n    return sorted_matrix\n",
        "def sort_matrix(M):\n    row_sums = [sum(row) for row in M]\n    sorted_indices = sorted(range(len(row_sums)), key=lambda i: row_sums[i])\n    sorted_matrix = [M[i] for i in sorted_indices]\n    return sorted_matrix\n",
        "def sort_matrix(M):\n    row_sums = []\n    for row in M:\n        row_sum = sum(row)\n        row_sums.append(row_sum)\n    zipped_rows = list(zip(M, row_sums))\n    zipped_rows.sort(key=lambda x: x[1])\n    sorted_rows = [row[0] for row in zipped_rows]\n    return sorted_rows\n"
    ],
    "MbppEval/14": [
        "def find_Volume(l, b, h):\n    \"\"\"\n    Write a python function to find the volume of a triangular prism.\n\n    Parameters:\n    l (int or float): The length of the triangular prism.\n    b (int or float): The base of the triangular prism.\n    h (int or float): The height of the triangular prism.\n\n    Returns:\n    int or float: The volume of the triangular prism.\n\n    Examples:\n    find_Volume(10, 8, 6) == 240\n    find_Volume(3, 2, 2) == 6\n    find_Volume(1, 2, 1) == 1\n    \"\"\"\n    volume = 1/2 * b * h * l\n    return volume\n",
        "def find_Volume(l, b, h):\n    volume = (1/2) * b * h * l\n    return volume\n",
        "def find_Volume(l, b, h):\n    \"\"\"\n    Write a python function to find the volume of a triangular prism.\n\n    Examples:\n    find_Volume(10, 8, 6) == 240\n    find_Volume(3, 2, 2) == 6\n    find_Volume(1, 2, 1) == 1\n\n    Args:\n        l (float): Length of the triangular prism.\n        b (float): Breadth of the triangular prism.\n        h (float): Height of the triangular prism.\n\n    Returns:\n        float: The volume of the triangular prism.\n    \"\"\"\n    return (1/2) * b * h * l\n",
        "def find_Volume(l, b, h):\n    return (1/4) * l * b * h\n",
        "def find_Volume(l, b, h):\n    base_area = 0.5 * b * h\n    volume = base_area * l\n    return volume\n"
    ],
    "MbppEval/16": [
        "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
        "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n",
        "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'^[a-z]+_[a-z]+$'\n    if re.match(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
        "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'^[a-z]+_[a-z]+$'\n    if re.match(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n"
    ],
    "MbppEval/17": [
        "def square_perimeter(a):\n    perimeter = a * 4\n    return perimeter\n",
        "def square_perimeter(a):\n    return 4 * a\n",
        "def square_perimeter(a):\n    return 4 * a\n",
        "def square_perimeter(a):\n    return 4 * a\n",
        "def square_perimeter(a):\n    return 4 * a\n"
    ],
    "MbppEval/18": [
        "def remove_dirty_chars(string1, string2):\n    \"\"\"\n    Removes characters from the first string that are present in the second string.\n    \n    Args:\n        string1 (str): The first input string.\n        string2 (str): The second input string.\n    \n    Returns:\n        str: The first string with the characters from the second string removed.\n    \"\"\"\n    char_list = list(string1)\n    for char in string2:\n        while char in char_list:\n            char_list.remove(char)\n    return ''.join(char_list)\n",
        "def remove_dirty_chars(string, chars_to_remove):\n    removal_set = set(chars_to_remove)\n    result = ''.join(char for char in string if char not in removal_set)\n    return result\n",
        "NO_OF_CHARS = 256\n\ndef str_to_list(string, dirty_chars):\n    \"\"\"\n    Write a function to remove characters from the first string which are present in the second string.\n\n    Examples:\n    remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'\n    remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'\n    remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles'\n    \"\"\"\n    keep_chars = []\n    for char in string:\n        if char not in dirty_chars:\n            keep_chars.append(char)\n    return ''.join(keep_chars)\n",
        "def remove_dirty_chars(first_string, second_string):\n    \"\"\"\n    Write a function to remove characters from the first string which are present in the second string.\n\n    Examples:\n    remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'\n    remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'\n    remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles'\n    \"\"\"\n    result = \"\"\n    for char in first_string:\n        if char not in second_string:\n            result += char\n    return result\n",
        "def remove_dirty_chars(string, dirty_chars):\n    \"\"\"\n    Write a function to remove characters from the first string which are present in the second string.\n\n    Examples:\n    remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'\n    remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'\n    remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles'\n    \"\"\"\n    cleaned_chars = []\n    for char in string:\n        if char not in dirty_chars:\n            cleaned_chars.append(char)\n    return ''.join(cleaned_chars)\n"
    ],
    "MbppEval/19": [
        "def test_duplicate(arraynums):\n    unique_set = set()\n    for num in arraynums:\n        if num in unique_set:\n            return True\n        unique_set.add(num)\n    return False\n",
        "def test_duplicate(arraynums):\n    unique_elements = set()\n    for num in arraynums:\n        if num in unique_elements:\n            return True\n        unique_elements.add(num)\n    return False\n",
        "def test_duplicate(arraynums):\n    unique_elements = set()\n    for num in arraynums:\n        if num in unique_elements:\n            return True\n        unique_elements.add(num)\n    return False\n",
        "def test_duplicate(arraynums):\n    unique_elements = set()\n    for num in arraynums:\n        if num in unique_elements:\n            return True\n        unique_elements.add(num)\n    return False\n",
        "def test_duplicate(arraynums):\n    unique_set = set(arraynums)\n    return len(unique_set) != len(arraynums)\n"
    ],
    "MbppEval/20": [
        "def is_woodall(x):\n    n = 0\n    i = 0\n    while 2**i - 1 < x:\n        n += 2**i - 1\n        i += 1\n    return n == x\n",
        "def is_woodall(x):\n    woodall_number = 2 ** x + 1\n    return woodall_number == x\n",
        "import math\n\ndef is_woodall(x):\n    \"\"\"\n    Check if the given number is a Woodall number.\n\n    Args:\n        x (int): The number to be checked.\n\n    Returns:\n        bool: True if x is a Woodall number, False otherwise.\n    \"\"\"\n    n = math.log2(x + 1) - 1\n    return x == 2 ** int(n) + int(n) - 1\n",
        "import math\n\ndef is_woodall(x):\n    result = 2 ** x + x\n    sqrt = int(math.sqrt(result))\n    return sqrt * sqrt == result\n",
        "def is_woodall(x):\n    \"\"\"\n    Write a function to check if the given number is woodall or not.\n\n    Examples:\n    is_woodall(383) == True\n    is_woodall(254) == False\n    is_woodall(200) == False\n    \"\"\"\n    n = 0\n    while 2 ** n - 1 <= x:\n        if 2 ** n - 1 == x:\n            return True\n        n += 1\n    return False\n"
    ],
    "MbppEval/56": [
        "def rev(num):\n    reversed_num = int(str(num)[::-1])\n    return num == 2 * reversed_num - 1\n",
        "def rev(num):\n    \"\"\"\n    Write a python function to check if a given number is one less than twice its reverse.\n\n    Examples:\n    rev(70) == False\n    rev(23) == False\n    rev(73) == True\n    \"\"\"\n    reversed_num = int(str(num)[::-1])\n    return num == 2 * reversed_num - 1\n",
        "def rev(num):\n    reverse = 0\n    while num > 0:\n        digit = num % 10\n        reverse = reverse * 10 + digit\n        num //= 10\n    return num == 2 * reverse - 1\n",
        "def get_reverse(n):\n    \"\"\"\n    Helper function to get the reverse of a number.\n    \"\"\"\n    return int(str(n)[::-1])\n\ndef rev(num):\n    \"\"\"\n    Write a python function to check if a given number is one less than twice its reverse.\n\n    Examples:\n    check(70) == False\n    check(23) == False\n    check(73) == True\n    \"\"\"\n    reverse_num = get_reverse(num)\n    return num == 2 * reverse_num - 1\n",
        "def rev(num):\n    rev_num = 0\n    while num > 0:\n        rev_num = rev_num * 10 + num % 10\n        num //= 10\n    \n    return num == 2 * rev_num - 1\n"
    ],
    "MbppEval/57": [
        "def find_Max_Num(arr, n):\n    if not isinstance(arr, list) or not all(isinstance(digit, int) for digit in arr) or len(arr) != n:\n        raise ValueError(\"Invalid input. The input should be a list of integers with length equal to the given 'n' value.\")\n    \n    arr.sort(reverse=True)\n    max_num = int(''.join(map(str, arr)))\n    return max_num\n",
        "def find_Max_Num(arr, n):\n    arr.sort(reverse=True)\n    largest_num = ''.join(map(str, arr))\n    return int(largest_num)\n",
        "def find_Max_Num(arr):\n    # Convert the list of digits into a list of strings\n    arr_str = [str(digit) for digit in arr]\n    \n    # Sort the list of strings in descending order\n    arr_str.sort(reverse=True)\n    \n    # Concatenate the sorted strings to form the largest number\n    largest_num = ''.join(arr_str)\n    \n    return int(largest_num)\n",
        "def find_Max_Num(arr):\n    arr.sort(reverse=True)\n    result = ''.join(map(str, arr))\n    return int(result)\n",
        "def find_Max_Num(arr, n):\n    digits_str = ''.join(map(str, arr))\n    sorted_digits = sorted(digits_str, reverse=True)\n    return int(''.join(sorted_digits))\n"
    ],
    "MbppEval/58": [
        "def opposite_Signs(x, y):\n    if (x < 0 and y >= 0) or (x >= 0 and y < 0):\n        return True\n    else:\n        return False\n",
        "def opposite_Signs(x, y):\n    return x * y < 0\n",
        "def opposite_Signs(x, y):\n    if (x > 0 and y < 0) or (x < 0 and y > 0):\n        return True\n    else:\n        return False\n",
        "def opposite_Signs(x, y):\n    if (x < 0 and y >= 0) or (x >= 0 and y < 0):\n        return True\n    else:\n        return False\n",
        "def opposite_Signs(x, y):\n    if x * y < 0:\n        return True\n    else:\n        return False\n"
    ],
    "MbppEval/59": [
        "def is_octagonal(n):\n    return n * (2 * n - 1)\n",
        "def is_octagonal(n):\n    return n * (3 * n - 2)\n",
        "def is_octagonal(n):\n    '''\n    Write a function to find the nth octagonal number.\n\n    Examples:\n    is_octagonal(5) == 65\n    is_octagonal(10) == 280\n    is_octagonal(15) == 645\n    '''\n    return n * (3 * n - 2)\n",
        "def is_octagonal(n):\n    return n * (2 * n - 1)\n",
        "def is_octagonal(n):\n    return n * (2 * n - 1)\n"
    ],
    "MbppEval/61": [
        "from collections import defaultdict\n\ndef count_Substrings(s):\n    count = defaultdict(int)\n    for i in range(len(s)):\n        curr_sum = 0\n        for j in range(i, len(s)):\n            curr_sum += int(s[j])\n            count[curr_sum] += 1\n    return sum(count.values())\n",
        "from collections import defaultdict\n\ndef count_Substrings(s):\n    count_dict = defaultdict(int)\n\n    for i in range(1, len(s) + 1):\n        for j in range(len(s) - i + 1):\n            substring = s[j:j+i]\n            if sum(int(digit) for digit in substring) == i:\n                count_dict[i] += 1\n\n    return sum(count_dict.values())\n",
        "from collections import defaultdict\n\ndef count_Substrings(s):\n    digit_counts = defaultdict(int)\n    running_sum = 0\n\n    for char in s:\n        running_sum += int(char)\n        digit_counts[running_sum] += 1\n\n    return sum(digit_counts.values())\n",
        "from collections import defaultdict\n\ndef count_Substrings(s):\n    count = defaultdict(int)\n    running_sum = 0\n    for i, digit in enumerate(s):\n        running_sum += int(digit)\n        if running_sum == i + 1:\n            count[running_sum] += 1\n    return sum(count.values())\n",
        "from collections import defaultdict\n\ndef count_Substrings(s):\n    count = defaultdict(int)\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            substring = s[i:j+1]\n            digit_sum = sum(int(digit) for digit in substring)\n            if digit_sum == len(substring):\n                count[len(substring)] += 1\n    return sum(count.values())\n"
    ],
    "MbppEval/62": [
        "def smallest_num(xs):\n    smallest = xs[0]\n    for x in xs[1:]:\n        if x < smallest:\n            smallest = x\n    return smallest\n",
        "def smallest_num(xs):\n    \"\"\"\n    Write a python function to find the smallest number in a list.\n\n    Examples:\n    smallest_num([10, 20, 1, 45, 99]) == 1\n    smallest_num([1, 2, 3]) == 1\n    smallest_num([45, 46, 50, 60]) == 45\n    \"\"\"\n    smallest = xs[0]\n    for num in xs[1:]:\n        if num < smallest:\n            smallest = num\n    return smallest\n",
        "def smallest_num(xs):\n    smallest = xs[0]\n    for x in xs[1:]:\n        if x < smallest:\n            smallest = x\n    return smallest\n",
        "def smallest_num(xs):\n    smallest = xs[0]\n    for x in xs[1:]:\n        if x < smallest:\n            smallest = x\n    return smallest\n",
        "def smallest_num(xs):\n    smallest = xs[0]\n    for num in xs:\n        if num < smallest:\n            smallest = num\n    return smallest\n"
    ],
    "MbppEval/63": [
        "def max_difference(test_list):\n    max_diff = 0\n    for a, b in test_list:\n        diff = abs(a - b)\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff\n",
        "def max_difference(test_list):\n    max_diff = 0\n    for a, b in test_list:\n        diff = abs(a - b)\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff\n",
        "def max_difference(test_list):\n    max_diff = 0\n    for a, b in test_list:\n        diff = abs(a - b)\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff\n",
        "def max_difference(test_list):\n    \"\"\"\n    Write a function to find the maximum difference between available pairs in the given tuple list.\n\n    Examples:\n    max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7\n    max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15\n    max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23\n    \"\"\"\n    max_diff = 0\n    for a, b in test_list:\n        diff = abs(max(a, b) - min(a, b))\n        max_diff = max(max_diff, diff)\n    return max_diff\n",
        "def max_difference(test_list):\n    max_diff = 0\n    for a, b in test_list:\n        diff = abs(a - b)\n        max_diff = max(max_diff, diff)\n    return max_diff\n"
    ],
    "MbppEval/64": [
        "def subject_marks(subjectmarks):\n    sorted_marks = sorted(subjectmarks, key=lambda x: x[1])\n    return sorted_marks\n",
        "def subject_marks(subjectmarks):\n    sorted_marks = sorted(subjectmarks, key=lambda x: x[1])\n    return sorted_marks\n",
        "def subject_marks(subjectmarks):\n    return sorted(subjectmarks, key=lambda x: x[1])\n",
        "def subject_marks(subjectmarks):\n    sorted_marks = sorted(subjectmarks, key=lambda x: x[1])\n    return sorted_marks\n",
        "def subject_marks(subjectmarks):\n    sorted_marks = sorted(subjectmarks, key=lambda x: x[1])\n    return sorted_marks\n"
    ],
    "MbppEval/65": [
        "def recursive_list_sum(data_list):\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total\n",
        "def _recursive_list_sum(data):\n    total = 0\n    for element in data:\n        if isinstance(element, list):\n            total += _recursive_list_sum(element)\n        else:\n            total += element\n    return total\n\ndef recursive_list_sum(data_list):\n    return _recursive_list_sum(data_list)\n",
        "def recursive_list_sum(data_list):\n    total = 0\n    for item in data_list:\n        if isinstance(item, list):\n            total += recursive_list_sum(item)\n        else:\n            total += item\n    return total\n",
        "def recursive_list_sum(data_list):\n    total = 0\n    for item in data_list:\n        if isinstance(item, list):\n            total += recursive_list_sum(item)\n        else:\n            total += item\n    return total\n",
        "def recursive_list_sum(data_list):\n    total_sum = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total_sum += recursive_list_sum(element)\n        else:\n            total_sum += element\n    return total_sum\n"
    ],
    "MbppEval/66": [
        "def pos_count(lst):\n    count = 0\n    for num in lst:\n        if num > 0:\n            count += 1\n    return count\n",
        "def pos_count(lst):\n    count = 0\n    for num in lst:\n        if num > 0:\n            count += 1\n    return count\n",
        "def pos_count(list_of_numbers):\n    positive_count = 0\n    for num in list_of_numbers:\n        if num > 0:\n            positive_count += 1\n    return positive_count\n",
        "def pos_count(lst):\n    count = 0\n    for num in lst:\n        if num > 0:\n            count += 1\n    return count\n",
        "def pos_count(lst):\n    count = 0\n    for num in lst:\n        if num > 0:\n            count += 1\n    return count\n"
    ],
    "MbppEval/67": [
        "def bell_number(n):\n    \"\"\"\n    Calculates the Bell number for the given input n.\n    \n    Args:\n        n (int): The input for which the Bell number needs to be calculated.\n    \n    Returns:\n        int: The Bell number for the given input n.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    \n    bell_sum = 0\n    for k in range(n):\n        bell_sum += binomial_coefficient(n-1, k) * bell_number(k)\n    \n    return bell_sum\n\ndef binomial_coefficient(n, k):\n    \"\"\"\n    Calculates the binomial coefficient C(n, k).\n    \n    Args:\n        n (int): The total number of elements.\n        k (int): The number of elements to choose.\n    \n    Returns:\n        int: The binomial coefficient C(n, k).\n    \"\"\"\n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef factorial(n):\n    \"\"\"\n    Calculates the factorial of the given number n.\n    \n    Args:\n        n (int): The number for which the factorial needs to be calculated.\n    \n    Returns:\n        int: The factorial of the given number n.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    return n * factorial(n-1)\n",
        "from math import comb\n\ndef bell_number(n):\n    bell_list = [0] * (n + 1)\n    bell_list[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            bell_list[i] += bell_list[j] * comb(i - 1, j)\n\n    return bell_list[n]\n",
        "def bell_number(n):\n    \"\"\"\n    Write a function to find the number of ways to partition a set of Bell numbers.\n\n    Examples:\n    bell_number(2) == 2\n    bell_number(10) == 115975\n    bell_number(56) == 6775685320645824322581483068371419745979053216268760300\n    \"\"\"\n    memo = {}\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        if n == 0:\n            return 1\n        result = sum(helper(k) * binomial(n, k) for k in range(n))\n        memo[n] = result\n        return result\n\n    return helper(n)\n\ndef binomial(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k).\n    \"\"\"\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef factorial(n):\n    \"\"\"\n    Calculate the factorial of a number.\n    \"\"\"\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n",
        "def bell_number(n):\n    \"\"\"\n    Computes the Bell number B(n).\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    \n    result = 0\n    for k in range(n):\n        result += bell_number(k) * binomial(n, k)\n    \n    return result\n\ndef binomial(n, k):\n    \"\"\"\n    Computes the binomial coefficient C(n, k).\n    \"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef factorial(n):\n    \"\"\"\n    Computes the factorial of a number.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    return n * factorial(n - 1)\n",
        "def bell_number(n):\n    \"\"\"\n    Calculate the Bell number for the given input n.\n    \n    Args:\n        n (int): The input value to calculate the Bell number for.\n    \n    Returns:\n        int: The Bell number for the given input n.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    bell = [0] * (n + 1)\n    bell[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            bell[i] += bell[j] * binomial(i, j)\n    \n    return bell[n]\n\ndef binomial(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k).\n    \n    Args:\n        n (int): The total number of elements.\n        k (int): The number of elements to choose.\n    \n    Returns:\n        int: The binomial coefficient C(n, k).\n    \"\"\"\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef factorial(n):\n    \"\"\"\n    Calculate the factorial of the given number n.\n    \n    Args:\n        n (int): The number to calculate the factorial for.\n    \n    Returns:\n        int: The factorial of the given number n.\n    \"\"\"\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n"
    ],
    "MbppEval/68": [
        "def is_Monotonic(A):\n    is_increasing = True\n    is_decreasing = True\n    \n    for i in range(len(A) - 1):\n        if A[i] < A[i+1]:\n            is_decreasing = False\n        if A[i] > A[i+1]:\n            is_increasing = False\n    \n    return is_increasing or is_decreasing\n",
        "def is_Monotonic(A):\n    is_increasing = True\n    is_decreasing = True\n    \n    for i in range(1, len(A)):\n        if A[i] > A[i-1]:\n            is_decreasing = False\n        if A[i] < A[i-1]:\n            is_increasing = False\n    \n    return is_increasing or is_decreasing\n",
        "def is_Monotonic(A):\n    increasing = True\n    decreasing = True\n\n    for i in range(1, len(A)):\n        if A[i] > A[i - 1]:\n            decreasing = False\n        if A[i] < A[i - 1]:\n            increasing = False\n\n    return increasing or decreasing\n",
        "def is_Monotonic(A):\n    if not A:\n        return True\n\n    increasing = decreasing = True\n\n    for i in range(len(A) - 1):\n        if A[i] < A[i+1]:\n            decreasing = False\n        if A[i] > A[i+1]:\n            increasing = False\n\n        if not increasing and not decreasing:\n            return False\n\n    return increasing or decreasing\n",
        "def is_Monotonic(A):\n    \"\"\"\n    Check whether the given array is monotonic or not.\n\n    Args:\n        A (list): The input list to be checked.\n\n    Returns:\n        bool: True if the list is monotonic, False otherwise.\n    \"\"\"\n    is_increasing = True\n    is_decreasing = True\n\n    for i in range(1, len(A)):\n        if A[i] > A[i-1]:\n            is_decreasing = False\n        if A[i] < A[i-1]:\n            is_increasing = False\n\n    return is_increasing or is_decreasing\n"
    ],
    "MbppEval/69": [
        "def is_sublist(l, s):\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i+len(s)] == s:\n            return True\n    return False\n",
        "def is_sublist(l, s):\n    return s in l\n",
        "def is_sublist(l, s):\n    start = 0\n    for item in l:\n        if item == s[start]:\n            start += 1\n            if start == len(s):\n                return True\n    return False\n",
        "def is_sublist(l, s):\n    i = 0\n    j = 0\n    \n    while i < len(l):\n        if l[i] == s[j]:\n            j += 1\n            if j == len(s):\n                return True\n        else:\n            j = 0\n        i += 1\n    \n    return False\n",
        "def is_sublist(l, s):\n    return str(s) in str(l)\n"
    ],
    "MbppEval/70": [
        "def find_equal_tuple(Input):\n    length = len(Input[0])\n    for tup in Input:\n        if len(tup) != length:\n            return \"All tuples do not have same length\"\n    return \"All tuples have same length\"\n",
        "def find_equal_tuple(Input):\n    length = len(Input[0])\n    for tup in Input:\n        if len(tup) != length:\n            return \"All tuples do not have same length\"\n    return \"All tuples have same length\"\n",
        "def find_equal_tuple(Input):\n    \"\"\"\n    Write a function to find whether all the given tuples have equal length or not.\n\n    Examples:\n    find_equal_tuple([(11, 22, 33), (44, 55, 66)]) == 'All tuples have same length'\n    find_equal_tuple([(1, 2, 3), (4, 5, 6, 7)]) == 'All tuples do not have same length'\n    find_equal_tuple([(1, 2), (3, 4)]) == 'All tuples have same length'\n    find_equal_tuple([]) == 'Input should not be an empty list'\n    \"\"\"\n    if not Input:\n        return \"Input should not be an empty list\"\n\n    reference_length = None\n    for tup in Input:\n        if reference_length is None:\n            reference_length = len(tup)\n        elif len(tup) != reference_length:\n            return \"All tuples do not have same length\"\n\n    return \"All tuples have same length\"\n",
        "def find_equal_tuple(Input):\n    expected_length = len(Input[0])\n    for tup in Input:\n        if len(tup) != expected_length:\n            return 'All tuples do not have same length'\n    return 'All tuples have same length'\n",
        "def find_equal_tuple(Input):\n    \"\"\"\n    Write a function to find whether all the given tuples have equal length or not.\n\n    Examples:\n    find_equal_tuple([(11, 22, 33), (44, 55, 66)], 3) == 'All tuples have same length'\n    find_equal_tuple([(1, 2, 3), (4, 5, 6, 7)], 3) == 'All tuples do not have same length'\n    find_equal_tuple([(1, 2), (3, 4)], 2) == 'All tuples have same length'\n    \"\"\"\n    length_set = set()\n    for tup in Input:\n        length_set.add(len(tup))\n    if len(length_set) == 1:\n        return \"All tuples have same length\"\n    else:\n        return \"All tuples do not have same length\"\n"
    ],
    "MbppEval/71": [
        "def comb_sort(nums):\n    gap = len(nums)\n    swapped = True\n\n    while gap > 1 or swapped:\n        gap = int(gap / 1.61803398875)\n        if gap < 1:\n            gap = 1\n        swapped = False\n\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n\n    return nums\n",
        "def comb_sort(nums):\n    n = len(nums)\n    gap = n\n    swaps = True\n\n    while gap > 1 or swaps:\n        gap = max(1, int(gap / 1.25))\n        swaps = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swaps = True\n\n    return nums\n",
        "def comb_sort(nums):\n    n = len(nums)\n    gap = n\n    swapped = True\n\n    while gap > 1 or swapped:\n        gap = int(gap / 1.25)\n        if gap < 1:\n            gap = 1\n        swapped = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n\n    return nums\n",
        "def comb_sort(nums):\n    gap = len(nums)\n    swapped = True\n    \n    while gap > 1 or swapped:\n        swapped = False\n        gap = int(gap / 1.25)\n        if gap < 1:\n            gap = 1\n        \n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n    \n    return nums\n",
        "def comb_sort(nums):\n    n = len(nums)\n    gap = n\n    swaps = True\n\n    while gap > 1 or swaps:\n        gap = max(1, int(gap / 1.25))  # Shrink the gap\n        swaps = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swaps = True\n\n    return nums\n"
    ],
    "MbppEval/72": [
        "def dif_Square(n):\n    a = 0\n    b = 1\n    while b**2 - a**2 < n:\n        a += 1\n        b += 1\n    return b**2 - a**2 == n\n",
        "import math\n\ndef dif_Square(n):\n    \"\"\"\n    Check whether the given number can be represented as the difference of two squares.\n    \n    Args:\n        n (int): The number to be checked.\n    \n    Returns:\n        bool: True if n can be represented as the difference of two squares, False otherwise.\n    \"\"\"\n    sqrt_n = int(math.sqrt(n))\n    for x in range(sqrt_n + 1):\n        if n == x**2 - (x+1)**2:\n            return True\n    return False\n",
        "import math\n\ndef dif_Square(n):\n    if n % 4 != 1:\n        return False\n\n    x = int(math.ceil(math.sqrt(n)))\n    y = int(math.floor(math.sqrt(n)))\n    while x**2 - y**2 != n:\n        if x**2 - y**2 < n:\n            x += 1\n        else:\n            y -= 1\n\n    return True\n",
        "def dif_Square(n):\n    \"\"\"\n    Write a python function to check whether the given number can be represented as the difference of two squares or not.\n\n    Examples:\n    dif_Square(5) == True\n    dif_Square(10) == False\n    dif_Square(15) == True\n    \"\"\"\n    for a in range(int(n**0.5) + 1):\n        b = a + 1\n        if n == a**2 - b**2:\n            return True\n    return False\n",
        "import math\n\ndef dif_Square(n):\n    for x in range(int(math.sqrt(n)) + 1):\n        if n == x**2 - (x-1)**2:\n            return True\n    return False\n"
    ],
    "MbppEval/74": [
        "def is_samepatterns(colors, patterns):\n    if len(colors) != len(patterns):\n        return False\n\n    color_map = {}\n    for i, pattern in enumerate(patterns):\n        if pattern not in color_map:\n            color_map[pattern] = colors[i]\n        elif color_map[pattern] != colors[i]:\n            return False\n\n    return True\n",
        "def is_samepatterns(colors, patterns):\n    if len(colors) != len(patterns):\n        return False\n\n    color_to_pattern = {}\n    for i in range(len(colors)):\n        color = colors[i]\n        pattern = patterns[i]\n\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n\n    return True\n",
        "def is_samepatterns(colors, patterns):\n    if len(colors) != len(patterns):\n        return False\n\n    pattern_to_color = {}\n\n    for i in range(len(colors)):\n        pattern = patterns[i]\n        color = colors[i]\n\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n\n    return True\n",
        "def is_samepatterns(colors, patterns):\n    if len(colors) != len(patterns):\n        return False\n\n    pattern_to_color = {}\n\n    for i in range(len(colors)):\n        pattern = patterns[i]\n        color = colors[i]\n\n        if pattern not in pattern_to_color:\n            if color in pattern_to_color.values():\n                return False\n            pattern_to_color[pattern] = color\n        elif pattern_to_color[pattern] != color:\n            return False\n\n    return True\n",
        "def is_samepatterns(colors, patterns):\n    if len(colors) != len(patterns):\n        return False\n\n    color_to_pattern = {}\n\n    for i in range(len(colors)):\n        color, pattern = colors[i], patterns[i]\n        if color not in color_to_pattern:\n            if pattern in color_to_pattern.values():\n                return False\n            color_to_pattern[color] = pattern\n        elif color_to_pattern[color] != pattern:\n            return False\n\n    return True\n"
    ],
    "MbppEval/75": [
        "def find_tuples(test_list, K):\n    result = [tup for tup in test_list if all(x % K == 0 for x in tup)]\n    return str(result)\n",
        "def find_tuples(test_list, K):\n    result = []\n    for tup in test_list:\n        if all(x % K == 0 for x in tup):\n            result.append(tup)\n    return str(result)\n",
        "def find_tuples(test_list, K):\n    result = []\n    for tup in test_list:\n        if all(x % K == 0 for x in tup):\n            result.append(tup)\n    return str(result)\n",
        "def find_tuples(test_list, K):\n    result = []\n    for tup in test_list:\n        if all(x % K == 0 for x in tup):\n            result.append(tup)\n    return str(result)\n",
        "def find_tuples(test_list, K):\n    result = []\n    for tup in test_list:\n        if all(x % K == 0 for x in tup):\n            result.append(tup)\n    return str(result)\n"
    ],
    "MbppEval/77": [
        "def is_divisible_by_11(n):\n    \"\"\"\n    Write a python function to find whether a number is divisible by 11.\n\n    Examples:\n    is_divisible_by_11(12345) == False\n    is_divisible_by_11(1212112) == True\n    is_divisible_by_11(1212) == False\n    \"\"\"\n    # Convert the input number to a string\n    num_str = str(n)\n    \n    # Calculate the sum of digits at even positions and odd positions\n    even_sum = sum(int(num_str[i]) for i in range(0, len(num_str), 2))\n    odd_sum = sum(int(num_str[i]) for i in range(1, len(num_str), 2))\n    \n    # Calculate the difference between the two sums\n    diff = even_sum - odd_sum\n    \n    # Check if the difference is 0 or a multiple of 11\n    return diff == 0 or diff % 11 == 0\n",
        "def is_Diff(n):\n    \"\"\"\n    Write a python function to find whether a number is divisible by 11.\n\n    Examples:\n    is_Diff(12345) == False\n    is_Diff(1212112) == True\n    is_Diff(1212) == False\n    \"\"\"\n    num_str = str(n)\n    odd_sum = 0\n    even_sum = 0\n    for i, digit in enumerate(num_str):\n        if i % 2 == 0:\n            even_sum += int(digit)\n        else:\n            odd_sum += int(digit)\n    diff = abs(odd_sum - even_sum)\n    return diff % 11 == 0\n",
        "def is_Diff(n):\n    \"\"\"\n    Write a python function to find whether a number is divisible by 11.\n\n    Examples:\n    is_Diff(12345) == False\n    is_Diff(1212112) == True\n    is_Diff(1212) == False\n    \"\"\"\n    sum1 = 0\n    sum2 = 0\n    n_str = str(n)\n    for i, digit in enumerate(n_str):\n        if i % 2 == 0:\n            sum1 += int(digit)\n        else:\n            sum2 += int(digit)\n    diff = abs(sum1 - sum2)\n    return diff % 11 == 0\n",
        "def is_Diff(n):\n    n_str = str(n)\n    even_sum = 0\n    odd_sum = 0\n    \n    for i, digit in enumerate(n_str):\n        if i % 2 == 0:\n            even_sum += int(digit)\n        else:\n            odd_sum += int(digit)\n    \n    diff = abs(even_sum - odd_sum)\n    return diff % 11 == 0\n",
        "def is_Diff(n):\n    return n % 11 == 0\n"
    ],
    "MbppEval/79": [
        "def word_len(s):\n    if len(s) % 2 != 0:\n        return True\n    else:\n        return False\n",
        "def word_len(s):\n    return len(s) % 2 == 1\n",
        "def word_len(s):\n    return len(s) % 2 == 1\n",
        "def word_len(s):\n    return len(s) % 2 != 0\n",
        "def word_len(s):\n    word_length = len(s)\n    return word_length % 2 == 1\n"
    ],
    "MbppEval/80": [
        "def tetrahedral_number(n):\n    return (n * (n + 1) * (n + 2)) / 6\n",
        "def tetrahedral_number(n):\n    return (n * (n + 1) * (n + 2)) / 6\n",
        "def tetrahedral_number(n):\n    \"\"\"\n    Write a function to find the nth tetrahedral number.\n\n    Examples:\n    tetrahedral_number(5) == 35.0\n    tetrahedral_number(6) == 56.0\n    tetrahedral_number(7) == 84.0\n    \"\"\"\n    return (n * (n + 1) * (n + 2)) / 6\n",
        "def tetrahedral_number(n):\n    return (n * (n + 1) * (n + 2)) / 6\n",
        "def tetrahedral_number(n):\n    return (n * (n + 1) * (n + 2)) / 6\n"
    ],
    "MbppEval/82": [
        "import math\n\ndef volume_sphere(r):\n    return (4/3) * math.pi * (r**3)\n",
        "import math\n\ndef volume_sphere(r):\n    return (4/3) * math.pi * r**3\n",
        "import math\n\ndef volume_sphere(r):\n    return (4/3) * math.pi * r**3\n",
        "import math\n\ndef volume_sphere(r):\n    '''\n    Write a function to find the volume of a sphere.\n\n    Parameters:\n    r (float): The radius of the sphere.\n\n    Returns:\n    float: The volume of the sphere.\n\n    Examples:\n    volume_sphere(10) == 4188.790204786391\n    volume_sphere(25) == 65449.84694978735\n    volume_sphere(20) == 33510.32163829113\n    '''\n    return (4/3) * math.pi * r**3\n",
        "import math\n\ndef volume_sphere(r):\n    return (4/3) * math.pi * r**3\n"
    ],
    "MbppEval/83": [
        "def get_Char(strr):\n    \"\"\"\n    Write a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.\n\n    Examples:\n    get_Char(\"abc\") == \"f\"\n    get_Char(\"gfg\") == \"t\"\n    get_Char(\"ab\") == \"c\"\n    \"\"\"\n    total_ascii = 0\n    for char in strr:\n        total_ascii += ord(char)\n    return chr((total_ascii % 26) + ord('A'))\n",
        "def get_Char(strr):\n    \"\"\"\n    Write a python function to find the character made by adding the ASCII value of all the alphabetic characters of the given string modulo 26.\n\n    Examples:\n    get_Char(\"abc\") == \"f\"\n    get_Char(\"gfg\") == \"t\"\n    get_Char(\"ab\") == \"c\"\n    get_Char(\"a1b!c2\") == \"f\"\n    \"\"\"\n    total = 0\n    for char in strr:\n        if char.isalpha():\n            total += ord(char.lower())\n    return chr(total % 26 + 65)\n",
        "def get_Char(strr):\n    total_ascii = 0\n    for char in strr:\n        total_ascii += ord(char)\n    return chr(total_ascii % 26 + 97)\n",
        "def get_Char(strr):\n    total = 0\n    for char in strr:\n        total += ord(char)\n    return chr(total % 26 + 97)\n",
        "def get_Char(strr):\n    total_ascii = 0\n    for char in strr:\n        total_ascii += ord(char)\n    final_char = chr(total_ascii % 26 + ord('a'))\n    return final_char\n"
    ],
    "MbppEval/84": [
        "def sequence(n):\n    \"\"\"\n    Find the nth number in the Newman-Conway sequence.\n\n    Args:\n        n (int): The position of the number in the sequence.\n\n    Returns:\n        int: The nth number in the Newman-Conway sequence.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return 1 + sum(1 for k in range(1, n) if n % k == 0)\n",
        "def sequence(n):\n    if n <= 2:\n        return 1\n    else:\n        return len(set(str(sequence(n-1))))\n",
        "def sequence(n):\n    \"\"\"\n    Find the nth number in the Newman-Conway sequence using dynamic programming.\n    \n    Args:\n        n (int): The position of the number to be returned in the sequence.\n        \n    Returns:\n        int: The nth number in the Newman-Conway sequence.\n    \"\"\"\n    if n <= 2:\n        return 1\n    \n    memo = {1: 1, 2: 1}\n    \n    for i in range(3, n+1):\n        memo[i] = memo[i-1] + memo[i-2]\n    \n    return memo[n]\n",
        "def sequence(n):\n    \"\"\"\n    Write a function to find the nth number in the newman conway sequence.\n\n    Examples:\n    sequence(10) == 6\n    sequence(2) == 1\n    sequence(3) == 2\n    \"\"\"\n    seq = [1, 1]\n    for i in range(2, n):\n        seq.append(bin(seq[-1]).count('1'))\n    return seq[n - 1]\n",
        "def sequence(n):\n    if n == 1:\n        return 1\n    else:\n        return 1 + sequence(sequence(n-1))\n"
    ],
    "MbppEval/85": [
        "import math\n\ndef surfacearea_sphere(r):\n    surface_area = 4 * math.pi * r**2\n    return surface_area\n",
        "import math\n\ndef surfacearea_sphere(r):\n    '''\n    Write a function to find the surface area of a sphere.\n\n    Examples:\n    surfacearea_sphere(10) == 1256.6370614359173\n    surfacearea_sphere(15) == 2827.4333882308138\n    surfacearea_sphere(20) == 5026.548245743669\n    '''\n    return 4 * math.pi * r ** 2\n",
        "import math\n\ndef surfacearea_sphere(r):\n    \"\"\"\n    Write a function to find the surface area of a sphere.\n\n    Examples:\n    surfacearea_sphere(10) == 1256.6370614359173\n    surfacearea_sphere(15) == 2827.4333882308138\n    surfacearea_sphere(20) == 5026.548245743669\n    \"\"\"\n    surface_area = 4 * math.pi * r**2\n    return surface_area\n",
        "import math\n\ndef surfacearea_sphere(r):\n    \"\"\"\n    Write a function to find the surface area of a sphere.\n\n    Examples:\n    surfacearea_sphere(10) == 1256.6370614359173\n    surfacearea_sphere(15) == 2827.4333882308138\n    surfacearea_sphere(20) == 5026.548245743669\n    \"\"\"\n    return 4 * math.pi * r**2\n",
        "import math\n\ndef surfacearea_sphere(r):\n    '''\n    Write a function to find the surface area of a sphere.\n\n    Examples:\n    surfacearea_sphere(10) == 1256.6370614359173\n    surfacearea_sphere(15) == 2827.4333882308138\n    surfacearea_sphere(20) == 5026.548245743669\n    '''\n    return 4 * math.pi * r ** 2\n"
    ],
    "MbppEval/86": [
        "def centered_hexagonal_number(n):\n    return n * (2 * n - 1)\n",
        "def centered_hexagonal_number(n):\n    return n * (5 * n - 3)\n",
        "def centered_hexagonal_number(n):\n    return n * (2 * n - 1)\n",
        "def centered_hexagonal_number(n):\n    return n * (2 * n - 1)\n",
        "def centered_hexagonal_number(n):\n    return n * (2 * n - 1)\n"
    ],
    "MbppEval/87": [
        "import collections as ct\n\ndef merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {}\n\n    for key, value in dict1.items():\n        merged_dict[key] = value\n\n    for key, value in dict2.items():\n        merged_dict[key] = value\n\n    for key, value in dict3.items():\n        merged_dict[key] = value\n\n    return merged_dict\n",
        "import collections as ct\n\ndef merge_dictionaries_three(dict1, dict2, dict3):\n    result = {}\n    \n    for key, value in dict1.items():\n        result[key] = value\n    \n    for key, value in dict2.items():\n        result[key] = value\n    \n    for key, value in dict3.items():\n        result[key] = value\n    \n    return result\n",
        "import collections as ct\n\ndef merge_dictionaries_three(dict1, dict2, dict3):\n    result = {}\n\n    for key, value in dict1.items():\n        result[key] = value\n\n    for key, value in dict2.items():\n        result[key] = value\n\n    for key, value in dict3.items():\n        result[key] = value\n\n    return result\n",
        "import collections as ct\n\ndef merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {}\n    \n    for key, value in dict1.items():\n        merged_dict[key] = value\n        \n    for key, value in dict2.items():\n        merged_dict[key] = value\n        \n    for key, value in dict3.items():\n        merged_dict[key] = value\n        \n    return merged_dict\n",
        "import collections as ct\n\ndef merge_dictionaries_three(dict1, dict2, dict3):\n    result = {}\n    \n    for key, value in dict1.items():\n        result[key] = value\n    \n    for key, value in dict2.items():\n        result[key] = value\n    \n    for key, value in dict3.items():\n        result[key] = value\n    \n    return result\n"
    ],
    "MbppEval/88": [
        "import collections\n\ndef freq_count(list1):\n    return dict(collections.Counter(list1))\n",
        "import collections\n\ndef freq_count(list1):\n    return dict(collections.Counter(list1))\n",
        "import collections\n\ndef freq_count(list1):\n    return dict(collections.Counter(list1))\n",
        "import collections\n\ndef freq_count(list1):\n    freq = collections.Counter(list1)\n    return dict(freq)\n",
        "import collections\n\ndef freq_count(list1):\n    return dict(collections.Counter(list1))\n"
    ],
    "MbppEval/89": [
        "def closest_num(N):\n    \"\"\"\n    Write a function to find the closest smaller number than n.\n\n    Examples:\n    closest_num(11) == 10\n    closest_num(7) == 6\n    closest_num(12) == 11\n    \"\"\"\n    # Handle edge cases\n    if N <= 0:\n        return None\n\n    # Convert N to a string and remove the last digit\n    N_str = str(N)\n    if len(N_str) == 1:\n        return None\n    closest_str = N_str[:-1]\n\n    # Convert the resulting string back to an integer\n    closest = int(closest_str)\n\n    return closest\n",
        "def closest_num(N):\n    if N < 0:\n        return N - 1\n    \n    N_str = str(N)\n    last_digit = int(N_str[-1])\n    \n    if last_digit == 0:\n        return N - 1\n    else:\n        new_last_digit = last_digit - 1\n        new_N_str = N_str[:-1] + str(new_last_digit)\n        return int(new_N_str)\n",
        "def closest_num(N):\n    \"\"\"\n    Write a function to find the closest smaller number than n.\n\n    Examples:\n    closest_num(11) == 10\n    closest_num(7) == 6\n    closest_num(12) == 11\n    \"\"\"\n    closest = N\n    for num in range(N - 1, -1, -1):\n        if abs(num - N) < abs(closest - N):\n            closest = num\n    return closest\n",
        "def closest_num(N):\n    \"\"\"\n    Write a function to find the closest smaller number than n.\n\n    Examples:\n    closest_num(11) == 10\n    closest_num(7) == 6\n    closest_num(12) == 11\n    closest_num(0) == None\n    \"\"\"\n    if N <= 0:\n        return None\n    return N - 1\n",
        "def closest_num(N):\n    \"\"\"\n    Write a function to find the closest smaller number than n.\n    \n    Examples:\n    closest_num(11) == 10\n    closest_num(7) == 6\n    closest_num(12) == 11\n    \"\"\"\n    if N == 1:\n        return 0\n    \n    closest = N - 1\n    \n    for i in range(N - 1, 0, -1):\n        if i < N:\n            closest = i\n            break\n    \n    return closest\n"
    ],
    "MbppEval/90": [
        "def len_log(list1):\n    max_length = 0\n    for word in list1:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length\n",
        "def len_log(list1):\n    max_length = 0\n    for word in list1:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length\n",
        "def len_log(list1):\n    longest_length = 0\n    for word in list1:\n        if len(word) > longest_length:\n            longest_length = len(word)\n    return longest_length\n",
        "def len_log(list1):\n    max_length = 0\n    for word in list1:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length\n",
        "def len_log(list1):\n    \"\"\"\n    Write a python function to find the length of the longest word.\n\n    Examples:\n    len_log([\"python\",\"PHP\",\"bigdata\"]) == 7\n    len_log([\"a\",\"ab\",\"abc\"]) == 3\n    len_log([\"small\",\"big\",\"tall\"]) == 5\n    \"\"\"\n    max_length = 0\n    for word in list1:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length\n"
    ],
    "MbppEval/91": [
        "def find_substring(str1, sub_str):\n    found = False\n    for s in str1:\n        if sub_str in s:\n            found = True\n            break\n    return found\n",
        "def find_substring(str1, sub_str):\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False\n",
        "def find_substring(str1, sub_str):\n    found = False\n    for s in str1:\n        if sub_str in s:\n            found = True\n            break\n    return found\n",
        "def find_substring(str1, sub_str):\n    found = False\n    for s in str1:\n        if sub_str in s:\n            found = True\n            break\n    return found\n",
        "def find_substring(str1, sub_str):\n    return any(sub_str in s for s in str1)\n"
    ],
    "MbppEval/92": [
        "import re\n\ndef is_undulating(n):\n    num_str = str(n)\n    if len(num_str) < 2:\n        return False\n    for i in range(1, len(num_str)):\n        if abs(int(num_str[i]) - int(num_str[i-1])) != 1:\n            return False\n    if not re.match(r\"(12)+|(21)+\", num_str):\n        return False\n    return True\n",
        "def is_undulating(n):\n    if not isinstance(n, str):\n        n = str(n)\n    if not n:\n        return False\n    for i in range(len(n) - 1):\n        if n[i] == n[i+1]:\n            return False\n    return True\n",
        "def is_undulating(n):\n    \"\"\"\n    Check whether the given number is undulating or not.\n\n    Examples:\n    is_undulating(\"1212121\") == True\n    is_undulating(\"1991\") == False\n    is_undulating(\"121\") == True\n    \"\"\"\n    n_str = str(n)\n    \n    # Check if the length of the string is less than 3\n    if len(n_str) < 3:\n        return False\n    \n    is_undulating = True\n    \n    # Iterate through the digits, starting from the second digit\n    for i in range(1, len(n_str)):\n        if n_str[i] == n_str[i-1]:\n            is_undulating = False\n            break\n    \n    return is_undulating\n",
        "def is_undulating(n):\n    digits = [int(d) for d in n]\n    is_up = None\n    trend_changes = 0\n    prev_digit = None\n\n    for i in range(1, len(digits)):\n        if digits[i] > digits[i-1]:\n            if is_up is False:\n                trend_changes += 1\n            is_up = True\n        elif digits[i] < digits[i-1]:\n            if is_up is True:\n                trend_changes += 1\n            is_up = False\n        prev_digit = digits[i-1]\n\n    return trend_changes == len(digits) - 1\n",
        "def is_undulating(n):\n    \"\"\"\n    Check whether the given number is undulating or not.\n\n    Examples:\n    is_undulating(\"1212121\") == True\n    is_undulating(\"1991\") == False\n    is_undulating(\"121\") == True\n    is_undulating(1212121) == True\n    is_undulating(1991) == False\n    is_undulating(121) == True\n    is_undulating(\"\") == False\n    is_undulating(1) == False\n    \"\"\"\n    # Convert the input to a string if it's a number\n    n_str = str(n)\n    \n    # Check for edge cases\n    if len(n_str) < 2:\n        return False\n    \n    # Iterate through the digits, checking the alternating pattern\n    is_undulating = True\n    for i in range(len(n_str) - 2):\n        if (int(n_str[i]) - int(n_str[i+1])) * (int(n_str[i+1]) - int(n_str[i+2])) >= 0:\n            is_undulating = False\n            break\n    \n    return is_undulating\n"
    ],
    "MbppEval/93": [
        "def power(a, b):\n    \"\"\"\n    Write a function to calculate the value of 'a' to the power 'b'.\n\n    Examples:\n    power(3,4) == 81\n    power(2,3) == 8\n    power(5,5) == 3125\n    \"\"\"\n    if b == 0:\n        return 1\n    elif b == 1:\n        return a\n    elif b % 2 == 0:\n        return power(a * a, b // 2)\n    else:\n        return a * power(a * a, b // 2)\n",
        "def power(a, b):\n    if b == 0:\n        return 1\n    \n    result = 1\n    for _ in range(b):\n        result *= a\n    \n    return result\n",
        "def power(a, b):\n    result = 1\n    for _ in range(b):\n        result *= a\n    return result\n",
        "def power(a, b):\n    return a ** b\n",
        "def power(a, b):\n    result = 1\n    for _ in range(b):\n        result *= a\n    return result\n"
    ],
    "MbppEval/94": [
        "from operator import itemgetter \n\ndef index_minimum(test_list):\n    sorted_list = sorted(test_list, key=itemgetter(1))\n    return sorted_list[0][0]\n",
        "from operator import itemgetter\n\ndef index_minimum(test_list):\n    sorted_list = sorted(test_list, key=itemgetter(1))\n    return sorted_list[0][0]\n",
        "from operator import itemgetter \n\ndef index_minimum(test_list):\n    return min(test_list, key=itemgetter(1))[0]\n",
        "from operator import itemgetter\n\ndef index_minimum(test_list):\n    sorted_list = sorted(test_list, key=itemgetter(1))\n    return sorted_list[0][0]\n",
        "from operator import itemgetter \n\ndef index_minimum(test_list):\n    sorted_list = sorted(test_list, key=itemgetter(1))\n    return sorted_list[0][0]\n"
    ],
    "MbppEval/95": [
        "def Find_Min_Length(lst):\n    min_length = float('inf')\n    for inner_list in lst:\n        current_length = len(inner_list)\n        if current_length < min_length:\n            min_length = current_length\n    return min_length\n",
        "def Find_Min_Length(lst):\n    min_length = float('inf')\n    for inner_list in lst:\n        length = len(inner_list)\n        if length < min_length:\n            min_length = length\n    return min_length\n",
        "def Find_Min_Length(lst):\n    min_length = float('inf')\n    \n    for inner_list in lst:\n        current_length = len(inner_list)\n        if current_length < min_length:\n            min_length = current_length\n    \n    return min_length\n",
        "def Find_Min_Length(lst):\n    if not lst:\n        return 0\n\n    min_length = float('inf')\n    for inner_list in lst:\n        min_length = min(min_length, len(inner_list))\n\n    return min_length\n",
        "def Find_Min_Length(lst):\n    min_length = float('inf')\n    \n    for inner_list in lst:\n        length = len(inner_list)\n        if length < min_length:\n            min_length = length\n    \n    return min_length\n"
    ],
    "MbppEval/96": [
        "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count\n",
        "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count\n",
        "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count\n",
        "def divisor(n):\n    \"\"\"\n    Write a python function to find the number of divisors of a given integer.\n\n    Examples:\n    divisor(15) == 4\n    divisor(12) == 6\n    divisor(9) == 3\n    \"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count\n",
        "def divisor(n):\n    \"\"\"\n    Write a python function to find the number of divisors of a given integer.\n\n    Examples:\n    divisor(15) == 4\n    divisor(12) == 6\n    divisor(9) == 3\n    \"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count\n"
    ],
    "MbppEval/97": [
        "from collections import Counter\n\ndef frequency_lists(list1):\n    \"\"\"\n    Write a function to find the frequency of each element in a flattened list of lists,\n    returned in a dictionary.\n    \"\"\"\n    flattened_list = [item for inner_list in list1 for item in inner_list]\n    freq_dict = dict(Counter(flattened_list))\n    return freq_dict\n",
        "def frequency_lists(list1):\n    \"\"\"\n    Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n    \"\"\"\n    freq_dict = {}\n    \n    for inner_list in list1:\n        for element in inner_list:\n            if element in freq_dict:\n                freq_dict[element] += 1\n            else:\n                freq_dict[element] = 1\n    \n    return freq_dict\n",
        "def frequency_lists(list1):\n    flattened_list = [item for sublist in list1 for item in sublist]\n    freq_dict = {}\n    for item in flattened_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict\n",
        "def frequency_lists(list1):\n    freq_dict = {}\n    \n    for inner_list in list1:\n        for element in inner_list:\n            if element in freq_dict:\n                freq_dict[element] += 1\n            else:\n                freq_dict[element] = 1\n    \n    return freq_dict\n",
        "def frequency_lists(list1):\n    flat_list = [item for sublist in list1 for item in sublist]\n    freq_dict = {}\n    for item in flat_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict\n"
    ],
    "MbppEval/98": [
        "def multiply_num(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n",
        "def multiply_num(numbers):\n    product = 1\n    length = len(numbers)\n    \n    for num in numbers:\n        product *= num\n    \n    return product / length\n",
        "def multiply_num(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n",
        "def multiply_num(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n",
        "def multiply_num(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n"
    ],
    "MbppEval/99": [
        "def decimal_to_binary(n):\n    binary_str = ''\n    \n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n //= 2\n    \n    return binary_str or '0'\n",
        "def decimal_to_binary(n):\n    binary_str = \"\"\n    \n    while n > 0:\n        remainder = n % 2\n        binary_str = str(remainder) + binary_str\n        n //= 2\n    \n    if not binary_str:\n        return '0'\n    \n    return binary_str\n",
        "def decimal_to_binary(n):\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n //= 2\n    return binary if binary else '0'\n",
        "def decimal_to_binary(n):\n    binary_str = \"\"\n    \n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n //= 2\n    \n    return binary_str or '0'\n",
        "def decimal_to_binary(n):\n    binary_str = \"\"\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n //= 2\n    return binary_str or \"0\"\n"
    ],
    "MbppEval/100": [
        "def next_smallest_palindrome(num):\n    num_str = str(num)\n    \n    # If the number is already a palindrome, return the next odd number\n    if num_str == num_str[::-1]:\n        return num + 1\n    \n    # Find the middle index of the string\n    middle = len(num_str) // 2\n    \n    # Create the new palindrome string\n    left = num_str[:middle]\n    right = num_str[middle:][::-1]\n    \n    # Combine the left and right halves\n    new_num_str = left + right\n    \n    # Convert the new string back to an integer and return it\n    return int(new_num_str)\n",
        "def next_smallest_palindrome(num):\n    \"\"\"\n    Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\n    Examples:\n    next_smallest_palindrome(99) == 101\n    next_smallest_palindrome(1221) == 1331\n    next_smallest_palindrome(120) == 121\n    \"\"\"\n    # Convert the input number to a string\n    num_str = str(num)\n\n    # Determine the length of the number\n    length = len(num_str)\n\n    # If the length is odd, find the middle digit and increment it by 1 if it's not 9\n    if length % 2 == 1:\n        middle = length // 2\n        if num_str[middle] != '9':\n            num_str = num_str[:middle] + str(int(num_str[middle]) + 1) + num_str[middle+1:]\n        else:\n            num_str = num_str[:middle] + '0' + num_str[middle+1:]\n    # If the length is even, find the middle two digits and increment the right digit by 1 if it's not 9\n    else:\n        middle = length // 2 - 1\n        if num_str[middle+1] != '9':\n            num_str = num_str[:middle+1] + str(int(num_str[middle+1]) + 1) + num_str[middle+2:]\n        else:\n            num_str = num_str[:middle+1] + '0' + num_str[middle+2:]\n\n    # Construct the new number by mirroring the left half to the right half\n    left_half = num_str[:length//2]\n    if length % 2 == 1:\n        return int(num_str[:middle+1] + left_half[::-1])\n    else:\n        return int(left_half + left_half[::-1])\n",
        "import sys\n\ndef next_smallest_palindrome(num):\n    '''\n    Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\n    Examples:\n    next_smallest_palindrome(99) == 101\n    next_smallest_palindrome(1221) == 1331\n    next_smallest_palindrome(120) == 121\n    '''\n    # Convert the input to a string\n    num_str = str(num)\n    \n    # Check if the number is already a palindrome\n    if num_str == num_str[::-1]:\n        # If it is, return the next odd palindrome\n        return num + 2\n    \n    # Find the middle index\n    middle = len(num_str) // 2\n    \n    # Construct the next palindrome\n    left_half = num_str[:middle]\n    if len(num_str) % 2 == 0:\n        right_half = num_str[middle:]\n    else:\n        right_half = num_str[middle+1:]\n    \n    next_palindrome_str = left_half + right_half[::-1]\n    \n    # Convert the result back to an integer and return it\n    return int(next_palindrome_str)\n",
        "def is_palindrome(n):\n    \"\"\"\n    Check if a number is a palindrome.\n    \"\"\"\n    original_n = n\n    reversed_n = 0\n    while n > 0:\n        reversed_n = reversed_n * 10 + n % 10\n        n //= 10\n    return original_n == reversed_n\n\ndef next_smallest_palindrome(num):\n    \"\"\"\n    Find the next smallest palindrome of a given integer.\n    \"\"\"\n    if is_palindrome(num):\n        return num\n    \n    num += 1\n    while not is_palindrome(num):\n        num += 1\n    \n    return num\n",
        "def next_smallest_palindrome(num):\n    num_str = str(num)\n    \n    if num_str == num_str[::-1]:\n        return num\n    \n    if len(num_str) % 2 == 1:\n        middle_digit = int(num_str[len(num_str) // 2])\n        new_middle_digit = middle_digit + 1\n        new_num_str = num_str[:len(num_str) // 2] + str(new_middle_digit) + num_str[len(num_str) // 2 + 1:][::-1]\n    else:\n        left_half = num_str[:len(num_str) // 2]\n        right_half = num_str[len(num_str) // 2:]\n        if int(left_half[-1]) < int(right_half[0]):\n            new_right_half = str(int(right_half[0]) + 1) + right_half[1:]\n        else:\n            new_right_half = str(int(right_half[0])) + right_half[1:]\n        new_num_str = left_half + new_right_half[::-1]\n    \n    return int(new_num_str)\n"
    ],
    "MbppEval/101": [
        "def kth_element(arr, k):\n    \"\"\"\n    Find the kth element in the given array using 1-based indexing.\n    \n    Args:\n        arr (list): The input array.\n        k (int): The 1-based index of the element to find.\n        \n    Returns:\n        The kth element of the array.\n        \n    Raises:\n        ValueError: If k is not within the valid range of the array size (1 <= k <= len(arr)).\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k is not within the valid range of the array size (1 <= k <= len(arr))\")\n    return arr[k-1]\n",
        "def kth_element(arr, k):\n    \"\"\"\n    Write a function to find the kth element in the given array using 1-based indexing.\n\n    Examples:\n    kth_element([12,3,5,7,19], 5, 2) == 3\n    kth_element([17,24,8,23], 4, 3) == 8\n    kth_element([16,21,25,36,4], 5, 4) == 36\n    \"\"\"\n    if not arr or k < 1 or k > len(arr):\n        return None\n\n    return _quickselect(arr, 0, len(arr) - 1, k - 1)\n\n\ndef _quickselect(arr, left, right, k):\n    \"\"\"\n    Helper function to find the kth smallest element using the quick-select algorithm.\n    \"\"\"\n    pivot = arr[right]\n    i = left\n\n    for j in range(left, right):\n        if arr[j] < pivot:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n\n    arr[i], arr[right] = arr[right], arr[i]\n\n    if i == k:\n        return arr[i]\n    elif i > k:\n        return _quickselect(arr, left, i - 1, k)\n    else:\n        return _quickselect(arr, i + 1, right, k)\n",
        "def kth_element(arr, n, k):\n    arr.sort()\n    return arr[k-1]\n",
        "def kth_element(arr, k, index=1):\n    \"\"\"\n    Find the kth element in the given array using 1-based indexing.\n\n    Args:\n        arr (list): The input array.\n        k (int): The value of k.\n        index (int, optional): The 1-based index. Defaults to 1.\n\n    Returns:\n        int: The kth element in the array.\n    \"\"\"\n    if k < 1 or k > len(arr):\n        return \"Error: k is not within the valid range of the array length.\"\n\n    def partition(left, right, pivot_index):\n        pivot = arr[pivot_index]\n        arr[pivot_index], arr[right] = arr[right], arr[pivot_index]\n        store_index = left\n        for i in range(left, right):\n            if arr[i] < pivot:\n                arr[i], arr[store_index] = arr[store_index], arr[i]\n                store_index += 1\n        arr[right], arr[store_index] = arr[store_index], arr[right]\n        return store_index\n\n    def select(left, right, k_smallest):\n        if left == right:\n            return arr[left]\n\n        pivot_index = left\n        pivot_index = partition(left, right, pivot_index)\n\n        if k_smallest == pivot_index + 1:\n            return arr[pivot_index]\n        elif k_smallest < pivot_index + 1:\n            return select(left, pivot_index - 1, k_smallest)\n        else:\n            return select(pivot_index + 1, right, k_smallest)\n\n    return select(0, len(arr) - 1, k)\n",
        "def kth_element(arr, k):\n    if not arr:\n        raise ValueError(\"Input array cannot be empty.\")\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k must be within the range [1, len(arr)].\")\n    \n    sorted_arr = sorted(arr)\n    return sorted_arr[k - 1]\n"
    ],
    "MbppEval/102": [
        "def snake_to_camel(word):\n    words = word.split('_')\n    camel_case = ''.join(w.capitalize() for w in words)\n    return camel_case\n",
        "def snake_to_camel(word):\n    words = word.split('_')\n    first_word = words[0].capitalize()\n    other_words = [w.capitalize() for w in words[1:]]\n    camel_case = first_word + ''.join(other_words)\n    return camel_case\n",
        "def snake_to_camel(word):\n    camel_case = ''\n    words = word.split('_')\n    camel_case += words[0]\n    for w in words[1:]:\n        camel_case += w.capitalize()\n    return camel_case\n",
        "def snake_to_camel(word):\n    words = word.split('_')\n    capitalized_words = [w.capitalize() for w in words]\n    camel_case = ''.join(capitalized_words)\n    return camel_case\n",
        "def snake_to_camel(word):\n    \"\"\"\n    Write a function to convert a snake case string to camel case string.\n\n    Examples:\n    snake_to_camel('python_program') == 'pythonProgram'\n    snake_to_camel('python_language') == 'pythonLanguage'\n    snake_to_camel('programming_language') == 'programmingLanguage'\n    \"\"\"\n    camel_case_parts = []\n    current_word = ''\n\n    for char in word:\n        if char == '_':\n            if current_word:\n                camel_case_parts.append(current_word.capitalize())\n                current_word = ''\n        else:\n            current_word += char\n\n    if current_word:\n        camel_case_parts.append(current_word.capitalize())\n\n    return ''.join(camel_case_parts)\n"
    ],
    "MbppEval/103": [
        "def eulerian_num(n, m):\n    if n == 0 or m == 0:\n        return 1\n    return (n-m) * eulerian_num(n-1, m) + (m+1) * eulerian_num(n-1, m-1)\n",
        "def eulerian_num(n, m):\n    if n == 0:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n-1, m-1) + (m + 1) * eulerian_num(n-1, m)\n",
        "def eulerian_num(n, m):\n    if m == 0:\n        return 1\n    if n == 0 or m > n:\n        return 0\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)\n",
        "def eulerian_num(n, m):\n    memo = {}\n    \n    def helper(n, m):\n        if m == 0 or m == n:\n            return 1\n        if (n, m) in memo:\n            return memo[(n, m)]\n        memo[(n, m)] = (n - m) * helper(n - 1, m - 1) + (m + 1) * helper(n - 1, m)\n        return memo[(n, m)]\n    \n    return helper(n, m)\n",
        "def eulerian_num(n, m):\n    \"\"\"\n    Find the Eulerian number a(n, m).\n\n    Args:\n        n (int): The value of n.\n        m (int): The value of m.\n\n    Returns:\n        int: The Eulerian number a(n, m).\n    \"\"\"\n    if m == 0:\n        return 1\n    \n    dp = [[0] * (m+1) for _ in range(n+1)]\n    \n    # Initialize the base cases\n    for i in range(1, n+1):\n        dp[i][0] = 1\n    \n    # Compute the Eulerian numbers using the recurrence relation\n    for i in range(2, n+1):\n        for j in range(1, min(i, m)+1):\n            dp[i][j] = (i-j) * dp[i-1][j-1] + (j+1) * dp[i-1][j]\n    \n    return dp[n][m]\n"
    ],
    "MbppEval/104": [
        "def sort_sublists(input_list):\n    return [sorted(sublist) for sublist in input_list]\n",
        "def sort_sublists(input_list):\n    return [sorted(sublist) for sublist in input_list]\n",
        "def sort_sublists(input_list):\n    sorted_sublists = []\n    for sublist in input_list:\n        sorted_sublist = sorted(sublist)\n        sorted_sublists.append(sorted_sublist)\n    return sorted_sublists\n",
        "def sort_sublists(input_list):\n    return [sorted(sublist) for sublist in input_list]\n",
        "def sort_sublists(input_list):\n    sorted_sublists = []\n    for sublist in input_list:\n        sorted_sublist = sorted(sublist)\n        sorted_sublists.append(sorted_sublist)\n    return sorted_sublists\n"
    ],
    "MbppEval/105": [
        "def count(lst):\n    true_count = 0\n    for element in lst:\n        if element:\n            true_count += 1\n    return true_count\n",
        "def count(lst):\n    true_count = 0\n    for element in lst:\n        if element:\n            true_count += 1\n    return true_count\n",
        "def count(lst):\n    count = 0\n    for element in lst:\n        if element:\n            count += 1\n    return count\n",
        "def count(lst):\n    true_count = 0\n    for item in lst:\n        if item:\n            true_count += 1\n    return true_count\n",
        "def count(lst):\n    count = 0\n    for element in lst:\n        if element:\n            count += 1\n    return count\n"
    ],
    "MbppEval/106": [
        "def add_lists(test_list, test_tup):\n    return test_tup + tuple(test_list)\n",
        "def add_lists(test_list, test_tup):\n    return test_tup + tuple(test_list)\n",
        "def add_lists(test_list, test_tup):\n    return test_tup + tuple(test_list)\n",
        "def add_lists(test_list, test_tup):\n    return test_tup + tuple(test_list)\n",
        "def add_lists(test_list, test_tup):\n    return test_tup + tuple(test_list)\n"
    ],
    "MbppEval/108": [
        "import heapq\nfrom itertools import chain\n\ndef merge_sorted_list(num1, num2, num3):\n    return list(heapq.merge(num1, num2, num3))\n",
        "import heapq\n\ndef merge_sorted_list(num1, num2, num3):\n    return list(heapq.merge(num1, num2, num3))\n",
        "import heapq\n\ndef merge_sorted_list(num1, num2, num3):\n    result = []\n    heap = []\n    for num in num1:\n        heapq.heappush(heap, num)\n    for num in num2:\n        heapq.heappush(heap, num)\n    for num in num3:\n        heapq.heappush(heap, num)\n    while heap:\n        result.append(heapq.heappop(heap))\n    return result\n",
        "import heapq\n\ndef merge_sorted_list(num1, num2, num3):\n    min_heap = []\n    if num1:\n        heapq.heappush(min_heap, (num1[0], 0, num1))\n    if num2:\n        heapq.heappush(min_heap, (num2[0], 1, num2))\n    if num3:\n        heapq.heappush(min_heap, (num3[0], 2, num3))\n\n    result = []\n    while min_heap:\n        value, list_index, list_ref = heapq.heappop(min_heap)\n        result.append(value)\n\n        next_index = list_index + 1\n        if next_index < len(list_ref):\n            heapq.heappush(min_heap, (list_ref[next_index], list_index, list_ref))\n\n    return result\n",
        "import heapq\n\ndef merge_sorted_list(num1, num2, num3):\n    merged = []\n    heap = []\n\n    if num1:\n        heapq.heappush(heap, (num1[0], 0, num1))\n    if num2:\n        heapq.heappush(heap, (num2[0], 1, num2))\n    if num3:\n        heapq.heappush(heap, (num3[0], 2, num3))\n\n    while heap:\n        val, idx, lst = heapq.heappop(heap)\n        merged.append(val)\n\n        if idx + 1 < len(lst):\n            heapq.heappush(heap, (lst[idx + 1], idx + 1, lst))\n\n    return merged\n"
    ],
    "MbppEval/109": [
        "def odd_Equivalent(s, n):\n    count = 0\n    for _ in range(n):\n        if int(s, 2) % 2 == 1:\n            count += 1\n        s = s[-1] + s[:-1]\n    return count\n",
        "def odd_Equivalent(s, n):\n    count = 0\n    for _ in range(n):\n        s = s[1:] + s[0]\n        num = int(s, 2)\n        if num % 2 == 1:\n            count += 1\n    return count\n",
        "def odd_Equivalent(s, n):\n    num = int(s, 2)\n    count = 0\n    for _ in range(n):\n        if num & 1 == 1:\n            count += 1\n        num = (num >> 1) | (num << (len(s) - 1))\n    return count\n",
        "def odd_Equivalent(s, n):\n    count = 0\n    for _ in range(n):\n        s = s[1:] + s[0]\n        if int(s, 2) % 2 == 1:\n            count += 1\n    return count\n",
        "def odd_Equivalent(s, n):\n    num = int(s, 2)\n    count = 0\n    for _ in range(n):\n        if num & 1:  # Check if the least significant bit is 1\n            count += 1\n        num <<= 1  # Rotate the bits to the left by 1 position\n    return count\n"
    ],
    "MbppEval/111": [
        "def common_in_nested_lists(nestedlist):\n    if not nestedlist:\n        return []\n\n    common_set = set(nestedlist[0])\n\n    for lst in nestedlist[1:]:\n        common_set = common_set.intersection(lst)\n\n    return list(common_set)\n",
        "def common_in_nested_lists(nestedlist):\n    if not nestedlist:\n        return []\n\n    common_elements = set(nestedlist[0])  # Initialize with the first list\n\n    for lst in nestedlist[1:]:\n        common_elements = common_elements.intersection(set(lst))\n\n    return list(common_elements)\n",
        "def common_in_nested_lists(nestedlist):\n    if not nestedlist:\n        return []\n\n    common_elements = set(nestedlist[0])\n\n    for lst in nestedlist[1:]:\n        common_elements &= set(lst)\n\n    return list(common_elements)\n",
        "def common_in_nested_lists(nestedlist):\n    element_count = {}\n    for inner_list in nestedlist:\n        for element in inner_list:\n            if element in element_count:\n                element_count[element] += 1\n            else:\n                element_count[element] = 1\n    \n    common_elements = [element for element, count in element_count.items() if count == len(nestedlist)]\n    return common_elements\n",
        "def common_in_nested_lists(nestedlist):\n    common_elements = set(nestedlist[0])\n    for lst in nestedlist[1:]:\n        common_elements &= set(lst)\n    return list(common_elements)\n"
    ],
    "MbppEval/113": [
        "def check_integer(text):\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n",
        "def check_integer(text):\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n",
        "def check_integer(text):\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n",
        "def check_integer(text):\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n",
        "def check_integer(text):\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n"
    ],
    "MbppEval/115": [
        "def empty_dit(list1):\n    '''\n    Write a function to check whether all dictionaries in a list are empty or not.\n\n    Examples:\n    empty_dit([{},{},{}]) == True\n    empty_dit([{1,2},{},{}]) == False\n    empty_dit({}) == True\n    '''\n    if not isinstance(list1, list):\n        return True\n    \n    return all(not dict_item for dict_item in list1)\n",
        "def empty_dit(list1):\n    all_empty = True\n    for element in list1:\n        if isinstance(element, dict):\n            if element:\n                all_empty = False\n                break\n    return all_empty\n",
        "def empty_dit(list1):\n    \"\"\"\n    Write a function to check whether all dictionaries in a list are empty or not.\n\n    Examples:\n    empty_dit([{},{},{}]) == True\n    empty_dit([{1,2},{},{}]) == False\n    empty_dit({}) == True\n    \"\"\"\n    all_empty = True\n    for item in list1:\n        if isinstance(item, dict):\n            if len(item) > 0:\n                all_empty = False\n                break\n    return all_empty\n",
        "def empty_dit(obj):\n    \"\"\"\n    Write a function to check whether all dictionaries in a list are empty or not.\n\n    Examples:\n    empty_dit([{},{},{}]) == True\n    empty_dit([{1,2},{},{}]) == False\n    empty_dit({}) == True\n    empty_dit([]) == True\n    empty_dit([1, 2, 3]) == False\n    \"\"\"\n    if isinstance(obj, dict):\n        return len(obj) == 0\n    elif isinstance(obj, list):\n        if len(obj) == 0:\n            return True\n        for item in obj:\n            if not isinstance(item, dict):\n                return False\n            if len(item) > 0:\n                return False\n        return True\n    else:\n        return False\n",
        "def empty_dit(list1):\n    all_empty = True\n    for element in list1:\n        if isinstance(element, dict):\n            if element:\n                all_empty = False\n                break\n    return all_empty\n"
    ],
    "MbppEval/116": [
        "def tuple_to_int(nums):\n    \"\"\"\n    Write a function to convert a given tuple of positive integers into a single integer.\n\n    Examples:\n    tuple_to_int((1,2,3)) == 123\n    tuple_to_int((4,5,6)) == 456\n    tuple_to_int((5,6,7)) == 567\n    \"\"\"\n    result = 0\n    for i, num in enumerate(nums):\n        result = result * 10 + num\n    return result\n",
        "def tuple_to_int(nums):\n    result = 0\n    for i, num in enumerate(nums):\n        result = result * 10 + num\n    return result\n",
        "def tuple_to_int(nums):\n    return int(''.join(map(str, nums)))\n",
        "def tuple_to_int(nums):\n    result = 0\n    for num in nums:\n        result = result * 10 + num\n    return result\n",
        "def tuple_to_int(nums):\n    result = \"\"\n    for num in nums:\n        result += str(num)\n    return int(result)\n"
    ],
    "MbppEval/117": [
        "def list_to_float(test_list):\n    result = []\n    for inner_list in test_list:\n        converted_list = []\n        for element in inner_list:\n            try:\n                converted_list.append(float(element))\n            except ValueError:\n                converted_list.append(element)\n        result.append(tuple(converted_list))\n    return str(result)\n",
        "def list_to_float(test_list):\n    result = []\n    for inner_list in test_list:\n        try:\n            first_float = float(inner_list[0])\n        except ValueError:\n            first_float = inner_list[0]\n        try:\n            second_float = float(inner_list[1])\n        except ValueError:\n            second_float = inner_list[1]\n        result.append((first_float, second_float))\n    return str(result)\n",
        "def list_to_float(test_list):\n    result = []\n    for inner_list in test_list:\n        converted_list = []\n        for item in inner_list:\n            try:\n                converted_list.append(float(item))\n            except ValueError:\n                converted_list.append(item)\n        result.append(tuple(converted_list))\n    return str(result)\n",
        "def list_to_float(test_list):\n    output_list = []\n    for pair in test_list:\n        first_element = float(pair[0]) if pair[0].replace('.', '', 1).isdigit() else pair[0]\n        second_element = float(pair[1]) if pair[1].replace('.', '', 1).isdigit() else pair[1]\n        output_list.append((first_element, second_element))\n    return str(output_list)\n",
        "def list_to_float(test_list):\n    output = []\n    for inner_list in test_list:\n        converted_pair = []\n        for element in inner_list:\n            try:\n                converted_pair.append(float(element))\n            except ValueError:\n                converted_pair.append(element)\n        output.append(tuple(converted_pair))\n    return str(output)\n"
    ],
    "MbppEval/118": [
        "def string_to_list(string):\n    return string.split()\n",
        "def string_to_list(string):\n    return string.split()\n",
        "def string_to_list(string):\n    return string.split()\n",
        "def string_to_list(string):\n    return string.split()\n",
        "def string_to_list(string):\n    return string.split()\n"
    ],
    "MbppEval/119": [
        "def search(arr):\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if mid == 0 or mid == len(arr) - 1:\n            return arr[mid]\n\n        if arr[mid] != arr[mid - 1] and arr[mid] != arr[mid + 1]:\n            return arr[mid]\n\n        if arr[mid] == arr[mid - 1]:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return None\n",
        "def search(arr):\n    low = 0\n    high = len(arr) - 1\n    \n    while low < high:\n        mid = (low + high) // 2\n        if (mid % 2 == 0 and arr[mid] == arr[mid+1]) or \\\n           (mid % 2 == 1 and arr[mid] == arr[mid-1]):\n            low = mid + 1\n        else:\n            high = mid\n    \n    return arr[low]\n",
        "def search(arr):\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if (mid == 0 or arr[mid] != arr[mid-1]) and (mid == len(arr)-1 or arr[mid] != arr[mid+1]):\n            return arr[mid]\n        \n        if mid > 0 and arr[mid] == arr[mid-1]:\n            right = mid - 2\n        else:\n            left = mid + 1\n    \n    return -1\n",
        "def search(arr):\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if mid > 0 and arr[mid] == arr[mid - 1]:\n            left = mid + 1\n        elif mid < len(arr) - 1 and arr[mid] == arr[mid + 1]:\n            right = mid - 1\n        else:\n            return arr[mid]\n\n    return -1\n",
        "def search(arr):\n    for i in range(0, len(arr) - 1, 2):\n        if arr[i] != arr[i+1]:\n            return arr[i]\n    return arr[-1]\n"
    ],
    "MbppEval/120": [
        "def max_product_tuple(list1):\n    max_product = 0\n    \n    for a, b in list1:\n        current_product = abs(a * b)\n        if current_product > max_product:\n            max_product = current_product\n    \n    return max_product\n",
        "def max_product_tuple(list1):\n    max_product = 0\n    \n    for tup in list1:\n        product = abs(tup[0] * tup[1])\n        if product > max_product:\n            max_product = product\n    \n    return max_product\n",
        "def max_product_tuple(list1):\n    max_product = 0\n\n    for a, b in list1:\n        current_product = abs(a * b)\n        if current_product > max_product:\n            max_product = current_product\n\n    return max_product\n",
        "def max_product_tuple(list1):\n    max_product = 0\n    \n    for tup in list1:\n        a, b = tup\n        current_product = abs(a * b)\n        \n        if current_product > max_product:\n            max_product = current_product\n    \n    return max_product\n",
        "def max_product_tuple(list1):\n    max_product = 0\n    for a, b in list1:\n        product = abs(a * b)\n        if product > max_product:\n            max_product = product\n    return max_product\n"
    ],
    "MbppEval/123": [
        "def amicable_numbers_sum(limit):\n    total_sum = 0\n    \n    for n in range(1, limit):\n        sum_of_divisors = sum(divisor for divisor in range(1, n) if n % divisor == 0)\n        sum_of_divisors_of_divisors = sum(divisor for divisor in range(1, sum_of_divisors) if sum_of_divisors % divisor == 0)\n        \n        if n == sum_of_divisors_of_divisors and n != sum_of_divisors:\n            total_sum += n\n    \n    return total_sum\n",
        "def amicable_numbers_sum(limit):\n    amicable_numbers = []\n\n    for n in range(1, limit + 1):\n        divisor_sum = sum(i for i in range(1, n) if n % i == 0)\n        if sum(i for i in range(1, divisor_sum) if divisor_sum % i == 0) == n and n != divisor_sum:\n            amicable_numbers.append(n)\n\n    return sum(amicable_numbers)\n",
        "def amicable_numbers_sum(limit):\n    \"\"\"\n    Write a function to sum all amicable numbers from 1 to a specified number.\n\n    Examples:\n    amicable_numbers_sum(999) == 504\n    amicable_numbers_sum(9999) == 31626\n    amicable_numbers_sum(99) == 0\n    \"\"\"\n    amicable_numbers = set()\n\n    for num in range(1, limit):\n        divisors_sum = sum(div for div in range(1, num) if num % div == 0)\n        other_num_divisors_sum = sum(div for div in range(1, divisors_sum) if divisors_sum % div == 0)\n\n        if other_num_divisors_sum == num and num != divisors_sum:\n            amicable_numbers.add(num)\n            amicable_numbers.add(divisors_sum)\n\n    return sum(amicable_numbers)\n",
        "def amicable_numbers_sum(limit):\n    amicable_numbers = []\n\n    for n in range(1, limit + 1):\n        divisor_sum = sum(divisor for divisor in range(1, n) if n % divisor == 0)\n        if divisor_sum != n and sum(divisor for divisor in range(1, divisor_sum) if divisor_sum % divisor == 0) == n:\n            amicable_numbers.append(n)\n\n    return sum(amicable_numbers)\n",
        "def amicable_numbers_sum(limit):\n    amicable_numbers = set()\n\n    for num in range(1, limit):\n        proper_divisors_sum = sum(divisor for divisor in range(1, num) if num % divisor == 0)\n        if sum(divisor for divisor in range(1, proper_divisors_sum) if proper_divisors_sum % divisor == 0) == num and num != proper_divisors_sum:\n            amicable_numbers.add(num)\n            amicable_numbers.add(proper_divisors_sum)\n\n    return sum(amicable_numbers)\n"
    ],
    "MbppEval/124": [
        "import cmath\n\ndef angle_complex(a, b):\n    \"\"\"\n    Write a function to get the angle of a complex number.\n\n    Examples:\n    angle_complex(0, 1j) == 1.5707963267948966\n    angle_complex(2, 1j) == 0.4636476090008061\n    angle_complex(0, 2j) == 1.5707963267948966\n    \"\"\"\n    z = complex(a, b)\n    return cmath.phase(z)\n",
        "import cmath\n\ndef angle_complex(a, b):\n    return cmath.phase(complex(a, b))\n",
        "import cmath\n\ndef angle_complex(a, b):\n    \"\"\"\n    Write a function to get the angle of a complex number.\n\n    Examples:\n    angle_complex(0, 1j) == 1.5707963267948966\n    angle_complex(2, 1j) == 0.4636476090008061\n    angle_complex(0, 2j) == 1.5707963267948966\n    \"\"\"\n    return cmath.phase(complex(a, b))\n",
        "import cmath\n\ndef angle_complex(a, b):\n    complex_num = complex(a, b)\n    angle = cmath.phase(complex_num)\n    return angle\n",
        "import cmath\n\ndef angle_complex(a, b):\n    \"\"\"\n    Write a function to get the angle of a complex number.\n\n    Examples:\n    angle_complex(0, 1j) == 1.5707963267948966\n    angle_complex(2, 1j) == 0.4636476090008061\n    angle_complex(0, 2j) == 1.5707963267948966\n    \"\"\"\n    z = complex(a, b)\n    return cmath.phase(z)\n"
    ],
    "MbppEval/125": [
        "def find_length(string):\n    \"\"\"\n    Find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n    \n    Args:\n        string (str): The binary string to search.\n    \n    Returns:\n        int: The maximum difference between 0s and 1s.\n    \"\"\"\n    max_diff = 0\n    count_0 = 0\n    count_1 = 0\n    \n    for char in string:\n        if char == '0':\n            count_0 += 1\n        else:\n            count_1 += 1\n        \n        diff = abs(count_0 - count_1)\n        max_diff = max(max_diff, diff)\n    \n    return max_diff\n",
        "def find_length(string, n):\n    max_diff = 0\n\n    for i in range(n):\n        num_0 = 0\n        num_1 = 0\n        for j in range(i, n):\n            if string[j] == '0':\n                num_0 += 1\n            else:\n                num_1 += 1\n            curr_diff = abs(num_0 - num_1)\n            max_diff = max(max_diff, curr_diff)\n\n    return max_diff\n",
        "def find_length(string):\n    max_diff = 0\n    current_diff = 0\n    \n    for char in string:\n        if char == '1':\n            current_diff += 1\n        else:\n            current_diff -= 1\n        max_diff = max(max_diff, abs(current_diff))\n    \n    return max_diff\n",
        "def find_length(string, n):\n    max_diff = 0\n    current_diff = 0\n    zeros = 0\n    ones = 0\n    \n    for char in string:\n        if char == '0':\n            zeros += 1\n        else:\n            ones += 1\n        current_diff = abs(zeros - ones)\n        max_diff = max(max_diff, current_diff)\n    \n    return max_diff\n",
        "def find_length(string):\n    max_diff = 0\n    count_0 = 0\n    count_1 = 0\n    \n    for char in string:\n        if char == '0':\n            count_0 += 1\n        else:\n            count_1 += 1\n        \n        current_diff = abs(count_0 - count_1)\n        max_diff = max(max_diff, current_diff)\n    \n    return max_diff\n"
    ],
    "MbppEval/126": [
        "def sum(a, b):\n    \"\"\"\n    Write a python function to find the sum of common divisors of two given numbers.\n\n    Examples:\n    sum(10, 15) == 6\n    sum(100, 150) == 93\n    sum(4, 6) == 3\n    \"\"\"\n    common_divisors = [1]\n    for i in range(2, min(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors.append(i)\n    return sum(common_divisors)\n",
        "def sum_common_divisors(a, b):\n    \"\"\"\n    Write a python function to find the sum of common divisors of two given numbers.\n\n    Examples:\n    sum_common_divisors(10, 15) == 6\n    sum_common_divisors(100, 150) == 93\n    sum_common_divisors(4, 6) == 3\n    \"\"\"\n    common_divisors = set()\n    for i in range(1, min(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors.add(i)\n    return sum(common_divisors)\n",
        "def sum(a, b):\n    \"\"\"\n    Write a python function to find the sum of common divisors of two given numbers.\n\n    Examples:\n    sum(10, 15) == 6\n    sum(100, 150) == 93\n    sum(4, 6) == 3\n    \"\"\"\n    divisors_a = [i for i in range(1, a+1) if a % i == 0]\n    divisors_b = [i for i in range(1, b+1) if b % i == 0]\n    common_divisors = [x for x in divisors_a if x in divisors_b]\n    return sum(common_divisors)\n",
        "def gcd(a, b):\n    \"\"\"Find the Greatest Common Divisor of a and b.\"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef divisors(n):\n    \"\"\"Find all the divisors of n.\"\"\"\n    return [i for i in range(1, n + 1) if n % i == 0]\n\ndef sum(a, b):\n    \"\"\"Find the sum of common divisors of a and b.\"\"\"\n    g = gcd(a, b)\n    return sum(divisors(g))\n",
        "def sum(a, b):\n    \"\"\"\n    Find the sum of common divisors of two given numbers.\n\n    Examples:\n    sum(10, 15) == 6\n    sum(100, 150) == 93\n    sum(4, 6) == 3\n    \"\"\"\n    def find_divisors(n):\n        \"\"\"\n        Helper function to find all the divisors of a given number.\n        \"\"\"\n        divisors = []\n        for i in range(1, n+1):\n            if n % i == 0:\n                divisors.append(i)\n        return divisors\n\n    a_divisors = find_divisors(a)\n    b_divisors = find_divisors(b)\n    common_divisors = set(a_divisors) & set(b_divisors)\n    return sum(common_divisors)\n"
    ],
    "MbppEval/127": [
        "def multiply_int(x, y):\n    \"\"\"\n    Write a function to multiply two integers.\n\n    Examples:\n    multiply_int(10, 20) == 200\n    multiply_int(5, 10) == 50\n    multiply_int(4, 8) == 32\n    \"\"\"\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise TypeError(\"Both arguments must be integers.\")\n\n    return x * y\n",
        "def multiply_int(x, y):\n    '''\n    Write a function to multiply two integers.\n\n    Examples:\n    multiply_int(10,20) == 200\n    multiply_int(5,10) == 50\n    multiply_int(4,8) == 32\n    '''\n    return x * y\n",
        "def multiply_int(x, y):\n    if not isinstance(x, int) or not isinstance(y, int):\n        return \"Error: Both arguments must be integers.\"\n    return x * y\n",
        "def multiply_int(x, y):\n    return x * y\n",
        "def multiply_int(x, y):\n    \"\"\"\n    Write a function to multiply two integers.\n\n    Examples:\n    multiply_int(10, 20) == 200\n    multiply_int(5, 10) == 50\n    multiply_int(4, 8) == 32\n    \"\"\"\n    return x * y\n"
    ],
    "MbppEval/128": [
        "def long_words(n, string):\n    words = string.split()\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list\n",
        "def long_words(n, string):\n    words = string.split()\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list\n",
        "def long_words(n, string):\n    words = string.split()\n    long_words_list = []\n    for word in words:\n        if len(word) > n:\n            long_words_list.append(word)\n    return long_words_list\n",
        "def long_words(n, str):\n    return [word for word in str.split() if len(word) > n]\n",
        "def long_words(n, str):\n    words = str.split()\n    result = [word for word in words if len(word) > n]\n    return result\n"
    ],
    "MbppEval/129": [
        "def magic_square_test(my_matrix):\n    \"\"\"\n    Determine if the input matrix is a magic square.\n    \n    Args:\n        my_matrix (list of lists): A square matrix.\n    \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(my_matrix)\n    for row in my_matrix:\n        if len(row) != n:\n            return False\n    \n    expected_sum = sum(my_matrix[0])\n    \n    for row in my_matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    for i in range(n):\n        column_sum = 0\n        for j in range(n):\n            column_sum += my_matrix[j][i]\n        if column_sum != expected_sum:\n            return False\n    \n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += my_matrix[i][i]\n    if diagonal_sum != expected_sum:\n        return False\n    \n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += my_matrix[i][n-1-i]\n    if diagonal_sum != expected_sum:\n        return False\n    \n    return True\n",
        "def magic_square_test(my_matrix):\n    \"\"\"\n    Write a function to calculate whether the matrix is a magic square.\n\n    Examples:\n    magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True\n    magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) == True\n    magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 7]]) == False\n    \"\"\"\n    # Step 3: Calculate the expected sum for each row, column, and diagonal\n    magic_sum = sum(my_matrix[0])\n\n    # Step 4: Check if the sum of each row is equal to the magic_sum\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Step 5: Check if the sum of each column is equal to the magic_sum\n    for i in range(len(my_matrix[0])):\n        column_sum = 0\n        for row in my_matrix:\n            column_sum += row[i]\n        if column_sum != magic_sum:\n            return False\n\n    # Step 6: Check if the sum of the main diagonal is equal to the magic_sum\n    main_diagonal_sum = 0\n    for i in range(len(my_matrix)):\n        main_diagonal_sum += my_matrix[i][i]\n    if main_diagonal_sum != magic_sum:\n        return False\n\n    # Step 7: Check if the sum of the secondary diagonal is equal to the magic_sum\n    secondary_diagonal_sum = 0\n    for i in range(len(my_matrix)):\n        secondary_diagonal_sum += my_matrix[i][len(my_matrix[0]) - 1 - i]\n    if secondary_diagonal_sum != magic_sum:\n        return False\n\n    # Step 8: If all the checks pass, return True\n    return True\n",
        "def magic_square_test(my_matrix):\n    sum_constant = sum(my_matrix[0])\n    for row in my_matrix:\n        if sum(row) != sum_constant:\n            return False\n    for i in range(len(my_matrix)):\n        column_sum = 0\n        for row in my_matrix:\n            column_sum += row[i]\n        if column_sum != sum_constant:\n            return False\n    main_diagonal_sum = 0\n    for i in range(len(my_matrix)):\n        main_diagonal_sum += my_matrix[i][i]\n    if main_diagonal_sum != sum_constant:\n        return False\n    secondary_diagonal_sum = 0\n    for i in range(len(my_matrix)):\n        secondary_diagonal_sum += my_matrix[i][len(my_matrix) - i - 1]\n    if secondary_diagonal_sum != sum_constant:\n        return False\n    return True\n",
        "def magic_square_test(my_matrix):\n    # Check if the input is a valid 2D matrix\n    if not isinstance(my_matrix, list) or not all(isinstance(row, list) for row in my_matrix):\n        return False\n    \n    # Check if all rows have the same length\n    row_length = len(my_matrix[0])\n    if not all(len(row) == row_length for row in my_matrix):\n        return False\n    \n    # Initialize magic_sum\n    magic_sum = sum(my_matrix[0])\n    \n    # Check rows\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check columns\n    for j in range(row_length):\n        column_sum = 0\n        for i in range(len(my_matrix)):\n            column_sum += my_matrix[i][j]\n        if column_sum != magic_sum:\n            return False\n    \n    # Calculate primary diagonal sum\n    primary_diagonal_sum = 0\n    for i in range(len(my_matrix)):\n        primary_diagonal_sum += my_matrix[i][i]\n    \n    # Calculate secondary diagonal sum\n    secondary_diagonal_sum = 0\n    for i in range(len(my_matrix)):\n        secondary_diagonal_sum += my_matrix[i][row_length - i - 1]\n    \n    # Check diagonals\n    if primary_diagonal_sum != magic_sum or secondary_diagonal_sum != magic_sum:\n        return False\n    \n    # If all checks pass, return True\n    return True\n",
        "def magic_square_test(my_matrix):\n    n = len(my_matrix)\n    if len(my_matrix[0]) != n:\n        return False\n\n    target_sum = sum(my_matrix[0])\n\n    for i in range(n):\n        row_sum = sum(my_matrix[i])\n        col_sum = sum(my_matrix[j][i] for j in range(n))\n\n        if row_sum != target_sum or col_sum != target_sum:\n            return False\n\n        if i == 0:\n            diag_sum1 = my_matrix[i][i]\n            diag_sum2 = my_matrix[i][n-i-1]\n\n    if diag_sum1 != target_sum or diag_sum2 != target_sum:\n        return False\n\n    return True\n"
    ],
    "MbppEval/130": [
        "from collections import defaultdict\n\ndef max_occurrences(nums):\n    count = defaultdict(int)\n    for num in nums:\n        count[num] += 1\n    max_count = max(count.values())\n    for num, c in count.items():\n        if c == max_count:\n            return (num, c)\n",
        "from collections import defaultdict\n\ndef max_occurrences(nums):\n    count_dict = defaultdict(int)\n    for num in nums:\n        count_dict[num] += 1\n    max_count = 0\n    max_element = None\n    for element, freq in count_dict.items():\n        if freq > max_count:\n            max_count = freq\n            max_element = element\n    return (max_element, max_count)\n",
        "from collections import defaultdict\n\ndef max_occurrences(nums):\n    count = defaultdict(int)\n    for num in nums:\n        count[num] += 1\n    max_count = max(count.values())\n    for item, freq in count.items():\n        if freq == max_count:\n            return (item, freq)\n",
        "from collections import defaultdict\n\ndef max_occurrences(nums):\n    count = defaultdict(int)\n    for num in nums:\n        count[num] += 1\n    \n    max_count = 0\n    max_item = None\n    for item, c in count.items():\n        if c > max_count:\n            max_count = c\n            max_item = item\n    \n    return (max_item, max_count)\n",
        "from collections import defaultdict\n\ndef max_occurrences(nums):\n    freq = defaultdict(int)\n    for num in nums:\n        freq[num] += 1\n    max_item, max_freq = max(freq.items(), key=lambda x: x[1])\n    return max_item, max_freq\n"
    ],
    "MbppEval/131": [
        "def reverse_vowels(str1):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    char_list = list(str1)\n    \n    # Find the indices of the vowels\n    vowel_indices = [i for i, char in enumerate(char_list) if char.lower() in vowels]\n    \n    # Reverse the vowels\n    for i in range(len(vowel_indices) // 2):\n        char_list[vowel_indices[i]], char_list[vowel_indices[len(vowel_indices) - 1 - i]] = char_list[vowel_indices[len(vowel_indices) - 1 - i]], char_list[vowel_indices[i]]\n    \n    return ''.join(char_list)\n",
        "def reverse_vowels(str1):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    char_list = list(str1)\n    vowel_list = [char for char in char_list if char.lower() in vowels]\n    vowel_list.reverse()\n    \n    result = []\n    vowel_index = 0\n    for char in char_list:\n        if char.lower() in vowels:\n            result.append(vowel_list[vowel_index])\n            vowel_index += 1\n        else:\n            result.append(char)\n    \n    return ''.join(result)\n",
        "def reverse_vowels(str1):\n    \"\"\"\n    Write a python function to reverse only the vowels of a given string (where y is not a vowel).\n\n    Examples:\n    reverse_vowels(\"Python\") == \"Python\"\n    reverse_vowels(\"USA\") == \"ASU\"\n    reverse_vowels(\"ab\") == \"ab\"\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    char_list = list(str1)\n    left, right = 0, len(char_list) - 1\n    while left < right:\n        if char_list[left] in vowels:\n            while right > left and char_list[right] not in vowels:\n                right -= 1\n            if right > left:\n                char_list[left], char_list[right] = char_list[right], char_list[left]\n                right -= 1\n        left += 1\n    return ''.join(char_list)\n",
        "def reverse_vowels(str1):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    char_list = list(str1)\n    vowel_indices = [i for i, char in enumerate(char_list) if char.lower() in vowels]\n    \n    for i in range(len(vowel_indices) // 2):\n        char_list[vowel_indices[i]], char_list[vowel_indices[-(i+1)]] = char_list[vowel_indices[-(i+1)]], char_list[vowel_indices[i]]\n    \n    return ''.join(char_list)\n",
        "def reverse_vowels(str1):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    char_list = list(str1)\n    left, right = 0, len(char_list) - 1\n\n    while left < right:\n        if char_list[left].lower() in vowels and char_list[right].lower() in vowels:\n            char_list[left], char_list[right] = char_list[right], char_list[left]\n            left += 1\n            right -= 1\n        elif char_list[left].lower() in vowels:\n            right -= 1\n        elif char_list[right].lower() in vowels:\n            left += 1\n        else:\n            left += 1\n            right -= 1\n\n    return ''.join(char_list)\n"
    ],
    "MbppEval/132": [
        "def tup_string(tup1):\n    result = \"\"\n    for char in tup1:\n        result += char\n    return result\n",
        "def tup_string(tup1):\n    result = ''.join(tup1)\n    return result\n",
        "def tup_string(tup1):\n    result_string = \"\"\n    for char in tup1:\n        result_string += char\n    return result_string\n",
        "def tup_string(tup1):\n    return ''.join(tup1)\n",
        "def tup_string(tup1):\n    \"\"\"\n    Write a function to convert a tuple to a string.\n\n    Examples:\n    tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's')) == (\"exercises\")\n    tup_string(('p','y','t','h','o','n')) == (\"python\")\n    tup_string(('p','r','o','g','r','a','m')) == (\"program\")\n    \"\"\"\n    return ''.join(tup1)\n"
    ],
    "MbppEval/133": [
        "def sum_negativenum(nums):\n    return sum(num for num in nums if num < 0)\n",
        "def sum_negativenum(nums):\n    negative_sum = 0\n    for num in nums:\n        if num < 0:\n            negative_sum += num\n    return negative_sum\n",
        "def sum_negativenum(nums):\n    total = 0\n    for num in nums:\n        if num < 0:\n            total += num\n    return total\n",
        "def sum_negativenum(nums):\n    negative_sum = 0\n    for num in nums:\n        if num < 0:\n            negative_sum += num\n    return negative_sum\n",
        "def sum_negativenum(nums):\n    total = 0\n    for num in nums:\n        if num < 0:\n            total += num\n    return total\n"
    ],
    "MbppEval/135": [
        "def hexagonal_num(n):\n    return n * (2 * n - 1)\n",
        "def hexagonal_num(n):\n    return n * (2 * n - 1)\n",
        "def hexagonal_num(n):\n    \"\"\"\n    Write a function to find the nth hexagonal number.\n\n    Examples:\n    hexagonal_num(10) == 190\n    hexagonal_num(5) == 45\n    hexagonal_num(7) == 91\n    \"\"\"\n    return n * (2 * n - 1)\n",
        "def hexagonal_num(n):\n    return n * (2 * n - 1)\n",
        "def hexagonal_num(n):\n    return n * (2 * n - 1)\n"
    ],
    "MbppEval/137": [
        "from array import array\n\ndef zero_count(nums):\n    zero_count = 0\n    non_zero_count = 0\n\n    for num in nums:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n\n    total_count = zero_count + non_zero_count\n    if total_count == 0:\n        return 0.0\n    else:\n        return zero_count / total_count\n",
        "def zero_count(nums):\n    zero_count = nums.count(0)\n    total_count = len(nums)\n    return zero_count / total_count\n",
        "from array import array\n\ndef zero_count(nums):\n    zero_count = 0\n    non_zero_count = 0\n    \n    for num in nums:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    total_count = zero_count + non_zero_count\n    ratio = zero_count / total_count\n    \n    return ratio\n",
        "def zero_count(nums):\n    zero_count = 0\n    for num in nums:\n        if num == 0:\n            zero_count += 1\n    return zero_count / len(nums)\n",
        "from array import array\n\ndef zero_count(nums):\n    zero_count = 0\n    for num in nums:\n        if num == 0:\n            zero_count += 1\n    return zero_count / len(nums)\n"
    ],
    "MbppEval/138": [
        "def is_Sum_Of_Powers_Of_Two(n):\n    power = 0\n    sum_of_powers = 0\n    \n    while 2 ** power <= n:\n        sum_of_powers += 2 ** power\n        power += 1\n    \n    return sum_of_powers == n\n",
        "def is_Sum_Of_Powers_Of_Two(n):\n    \"\"\"\n    Checks whether the given number can be represented as a sum of non-zero powers of 2.\n\n    Args:\n        n (int): The number to be checked.\n\n    Returns:\n        bool: True if the number can be represented as a sum of non-zero powers of 2, False otherwise.\n    \"\"\"\n    binary_repr = bin(n)[2:]  # Convert to binary and remove the '0b' prefix\n    \n    # Check if the binary representation has only non-zero digits\n    return all(int(digit) > 0 for digit in binary_repr)\n",
        "def is_Sum_Of_Powers_Of_Two(n):\n    if n == 0 or (n & (n - 1)) == 0:\n        return True\n\n    result = True\n    binary_str = bin(n)[2:]\n\n    for i, char in enumerate(binary_str):\n        if char == '1' and 2 ** i != n:\n            result = False\n            break\n\n    return result\n",
        "def is_Sum_Of_Powers_Of_Two(n):\n    if n == 0:\n        return False\n    temp = n\n    if (temp & (temp - 1)) == 0:\n        return True\n    while temp:\n        if temp & 1 == 1 and not is_Sum_Of_Powers_Of_Two(temp & (temp - 1)):\n            return False\n        temp >>= 1\n    return True\n",
        "def is_Sum_Of_Powers_Of_Two(n):\n    temp = n\n    result = True\n    \n    i = 1\n    while i <= n:\n        if temp >= i:\n            if temp % i == 0:\n                temp -= i\n            else:\n                result = False\n        i *= 2\n    \n    return result\n"
    ],
    "MbppEval/139": [
        "import math\n\ndef circle_circumference(r):\n    circumference = 2 * math.pi * r\n    return circumference\n",
        "import math\n\ndef circle_circumference(r):\n    \"\"\"\n    Write a function to find the circumference of a circle.\n\n    Examples:\n    circle_circumference(10) == 62.83185307179586\n    circle_circumference(5) == 31.41592653589793\n    circle_circumference(4) == 25.132741228718345\n    \"\"\"\n    circumference = 2 * math.pi * r\n    return circumference\n",
        "import math\n\ndef circle_circumference(r):\n    circumference = 2 * math.pi * r\n    return round(circumference, 3)\n",
        "import math\n\ndef circle_circumference(r):\n    return 2 * math.pi * r\n",
        "import math\n\ndef circle_circumference(r):\n    '''\n    Write a function to find the circumference of a circle.\n\n    Examples:\n    circle_circumference(10) == 62.832\n    circle_circumference(5) == 31.416\n    circle_circumference(4) == 25.133\n    '''\n    circumference = 2 * math.pi * r\n    return round(circumference, 3)\n"
    ],
    "MbppEval/140": [
        "def extract_singly(test_list):\n    result = set()\n    for inner_list in test_list:\n        result.update(inner_list)\n    return list(result)\n",
        "def extract_singly(test_list):\n    result = []\n    for inner_list in test_list:\n        result.extend(inner_list)\n    return set(result)\n",
        "def extract_singly(test_list):\n    result_set = set()\n    for inner_list in test_list:\n        for num in inner_list:\n            result_set.add(num)\n    return list(result_set)\n",
        "def extract_singly(test_list):\n    result = set()\n    for inner_list in test_list:\n        result.update(inner_list)\n    return list(result)\n",
        "def extract_singly(test_list):\n    \"\"\"\n    Write a function to flatten the list of lists into a single set of numbers.\n\n    Examples:\n    extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)]) == [3, 4, 5, 7, 1]\n    extract_singly([(1, 2, 3), (4, 2, 3), (7, 8)]) == [1, 2, 3, 4, 7, 8]\n    extract_singly([(7, 8, 9), (10, 11, 12), (10, 11)]) == [7, 8, 9, 10, 11, 12]\n    \"\"\"\n    result = set()\n    for inner_list in test_list:\n        result.update(inner_list)\n    return list(result)\n"
    ],
    "MbppEval/141": [
        "def pancake_sort(nums):\n    sorted_nums = []\n    for i in range(len(nums), 0, -1):\n        max_index = max(range(i), key=lambda x: nums[x])\n        nums[:max_index+1] = reversed(nums[:max_index+1])\n        sorted_nums.append(nums.pop(max_index))\n        nums[:i-1] = reversed(nums[:i-1])\n    return sorted_nums\n",
        "def pancake_sort(nums):\n    n = len(nums)\n    for i in range(n, 0, -1):\n        max_index = 0\n        for j in range(1, i):\n            if nums[j] > nums[max_index]:\n                max_index = j\n        \n        # Reverse the subarray from the beginning to the maximum element\n        nums[:max_index+1] = reversed(nums[:max_index+1])\n        \n        # Reverse the subarray from the beginning to the current index\n        nums[:i] = reversed(nums[:i])\n    \n    return nums\n",
        "def pancake_sort(nums):\n    n = len(nums)\n    \n    for i in range(n, 0, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_idx = 0\n        for j in range(1, i):\n            if nums[j] > nums[max_idx]:\n                max_idx = j\n        \n        # Flip the sublist to bring the maximum element to the beginning\n        nums[:max_idx + 1] = reversed(nums[:max_idx + 1])\n        \n        # Flip the entire unsorted part to bring the maximum element to its correct position\n        nums[:i] = reversed(nums[:i])\n    \n    return nums\n",
        "def pancake_sort(nums):\n    n = len(nums)\n    for i in range(n, 0, -1):\n        max_idx = 0\n        for j in range(1, i):\n            if nums[j] > nums[max_idx]:\n                max_idx = j\n        nums[:max_idx+1] = reversed(nums[:max_idx+1])\n        nums[:i] = reversed(nums[:i])\n    return nums\n",
        "def pancake_sort(nums):\n    n = len(nums)\n    \n    for i in range(n, 0, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_index = max(range(i), key=nums.__getitem__)\n        \n        # Reverse the sublist from the beginning to the maximum element\n        nums[:max_index + 1] = reversed(nums[:max_index + 1])\n        \n        # Reverse the entire sublist to bring the maximum element to its correct position\n        nums[:i] = reversed(nums[:i])\n    \n    return nums\n"
    ],
    "MbppEval/142": [
        "def count_samepair(list1, list2, list3):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    return count\n",
        "def count_samepair(list1, list2, list3):\n    count = 0\n    for a, b, c in zip(list1, list2, list3):\n        if a == b == c:\n            count += 1\n    return count\n",
        "def count_samepair(list1, list2, list3):\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        return 0\n\n    count = 0\n\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n\n    return count\n",
        "def count_samepair(list1, list2, list3):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    return count\n",
        "def count_samepair(list1, list2, list3):\n    count = 0\n    for x, y, z in zip(list1, list2, list3):\n        if x == y == z:\n            count += 1\n    return count\n"
    ],
    "MbppEval/143": [
        "def find_lists(Input):\n    count = 0\n    for element in Input:\n        if isinstance(element, list):\n            count += 1\n    return count\n",
        "def find_lists(Input):\n    count = 0\n    for element in Input:\n        if isinstance(element, list):\n            count += 1\n    return count\n",
        "def find_lists(Input):\n    count = 0\n    \n    if not isinstance(Input, tuple):\n        return \"Input must be a tuple\"\n    \n    for element in Input:\n        if isinstance(element, list):\n            count += 1\n    \n    return count\n",
        "def find_lists(Input):\n    count = 0\n    for element in Input:\n        if isinstance(element, list):\n            count += 1\n    return count\n",
        "def find_lists(input_tuple):\n    \"\"\"\n    Write a function to find the number of lists present in the given tuple.\n\n    Examples:\n    find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2\n    find_lists(([1, 2], [3, 4], [5, 6])) == 3\n    find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1\n    \"\"\"\n    count = 0\n    for item in input_tuple:\n        if isinstance(item, list):\n            count += 1\n    return count\n"
    ],
    "MbppEval/145": [
        "def max_Abs_Diff(arr):\n    max_diff = 0\n    \n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_diff:\n                max_diff = diff\n    \n    return max_diff\n",
        "def max_Abs_Diff(arr):\n    \"\"\"\n    Find the maximum difference between any two elements in a given array.\n\n    Args:\n        arr (list): The input array.\n\n    Returns:\n        int: The maximum absolute difference between any two elements in the array.\n    \"\"\"\n    max_val = max(arr)\n    min_val = min(arr)\n    return abs(max_val - min_val)\n",
        "def max_Abs_Diff(arr, n):\n    max_diff = 0\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            curr_diff = abs(arr[i] - arr[j])\n            max_diff = max(max_diff, curr_diff)\n    \n    return max_diff\n",
        "def max_Abs_Diff(arr, n):\n    \"\"\"\n    Find the maximum difference between any two elements in a given array.\n\n    Args:\n        arr (list): The input array.\n        n (int): The length of the input array.\n\n    Returns:\n        int: The maximum absolute difference between any two elements in the array.\n    \"\"\"\n    max_val = max(arr)\n    min_val = min(arr)\n\n    return abs(max_val - min_val)\n",
        "def max_Abs_Diff(arr, n):\n    max_diff = 0\n\n    for i in range(n):\n        for j in range(i+1, n):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_diff:\n                max_diff = diff\n\n    return max_diff\n"
    ],
    "MbppEval/160": [
        "def find_solution(a, b, n):\n    \"\"\"\n    Returns integers x and y that satisfy ax + by = n as a tuple, or None if no solution exists.\n    \"\"\"\n    def gcd(x, y):\n        \"\"\"Compute the greatest common divisor of x and y.\"\"\"\n        while y != 0:\n            x, y = y, x % y\n        return x\n\n    def extended_euclidean(a, b):\n        \"\"\"\n        Compute the extended Euclidean algorithm for a and b.\n        Returns x, y, and gcd(a, b), where ax + by = gcd(a, b).\n        \"\"\"\n        if b == 0:\n            return 1, 0, a\n        else:\n            x, y, d = extended_euclidean(b, a % b)\n            return y, x - (a // b) * y, d\n\n    d = gcd(a, b)\n    if n % d != 0:\n        return None\n\n    x0, y0, _ = extended_euclidean(a // d, b // d)\n    x = x0 * (n // d)\n    y = y0 * (n // d)\n    return (f\"x = {x}\", f\"y = {y}\")\n",
        "def find_solution(a, b, n):\n    for x in range(n // a + 1):\n        y = (n - a * x) / b\n        if y.is_integer() and y >= 0:\n            return ('x = ', x, ', y = ', int(y))\n    return \"No solution\"\n",
        "def extended_gcd(a, b):\n    \"\"\"\n    Compute the extended Euclidean algorithm for a and b.\n    Returns (gcd, x, y) such that ax + by = gcd(a, b)\n    \"\"\"\n    x, y, u, v = 0, 1, 1, 0\n    while a != 0:\n        q, r = b // a, b % a\n        m, n = x - u * q, y - v * q\n        b, a, x, y, u, v = a, r, u, v, m, n\n    return b, x, y\n\ndef find_solution(a, b, n):\n    \"\"\"\n    Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return 'No solution' if no solution exists.\n\n    Examples:\n    find_solution(2, 3, 7) == ('x = ', 2, ', y = ', 1)\n    find_solution(4, 2, 7) == 'No solution'\n    find_solution(1, 13, 17) == ('x = ', 4, ', y = ', 1)\n    \"\"\"\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd != 0:\n        return 'No solution'\n    x0 = x * (n // gcd)\n    y0 = y * (n // gcd)\n    return ('x = ', x0, ', y = ', y0)\n",
        "def gcd(a, b):\n    \"\"\"\n    Find the greatest common divisor of a and b using the Euclidean algorithm.\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef extended_gcd(a, b, n):\n    \"\"\"\n    Find the extended Euclidean algorithm to solve ax + by = n.\n    \"\"\"\n    if b == 0:\n        return 1, 0, a\n    else:\n        x, y, d = extended_gcd(b, a % b, n)\n        return y, x - (a // b) * y, d\n\ndef find_solution(a, b, n):\n    \"\"\"\n    Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\n    \"\"\"\n    d = gcd(a, b)\n    if n % d != 0:\n        return None\n    \n    x, y, _ = extended_gcd(a // d, b // d, n // d)\n    return (x, y)\n",
        "def find_solution(a, b, n):\n    for x in range(n+1):\n        for y in range(n+1):\n            if a*x + b*y == n:\n                return ('x = ', x, ', y = ', y)\n    return 'No solution'\n"
    ],
    "MbppEval/161": [
        "def remove_elements(list1, list2):\n    list2_set = set(list2)\n    new_list = [item for item in list1 if item not in list2_set]\n    return new_list\n",
        "def remove_elements(list1, list2):\n    result = []\n    list2_set = set(list2)\n    for item in list1:\n        if item not in list2_set:\n            result.append(item)\n    return result\n",
        "def remove_elements(list1, list2):\n    result = [item for item in list1 if item not in list2]\n    return result\n",
        "def remove_elements(list1, list2):\n    result = []\n    for item in list1:\n        if item not in list2:\n            result.append(item)\n    return result\n",
        "def remove_elements(list1, list2):\n    result = [item for item in list1 if item not in list2]\n    return result\n"
    ],
    "MbppEval/162": [
        "def sum_series(n):\n    \"\"\"\n    Write a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).\n\n    Examples:\n    sum_series(6) == 12\n    sum_series(10) == 30\n    sum_series(9) == 25\n    \"\"\"\n    num_terms = n // 2 + 1\n    sum_formula = n * num_terms - 2 * (num_terms * (num_terms - 1)) // 2\n    return sum_formula\n",
        "def sum_series(n):\n    total = 0\n    for i in range(n // 2 + 1):\n        total += n - 2 * i\n    return total\n",
        "def sum_series(n):\n    total = 0\n    for i in range(n//2 + 1):\n        total += n - 2*i\n    return total\n",
        "def sum_series(n):\n    total_sum = 0\n    for i in range(n // 2 + 1):\n        total_sum += n - 2 * i\n    return total_sum\n",
        "def sum_series(n):\n    total = 0\n    for i in range(n//2 + 1):\n        total += n - 2*i\n    return total\n"
    ],
    "MbppEval/163": [
        "from math import tan, pi\n\ndef area_polygon(s, l):\n    return (s * l**2) / (4 * tan(pi/s))\n",
        "from math import tan, pi\n\ndef area_polygon(s, n):\n    area = (n * s**2) / (4 * tan(pi/n))\n    return round(area, 10)\n",
        "from math import tan, pi\n\ndef area_polygon(s, l):\n    area = (s * l**2) / (4 * tan(pi/s))\n    return round(area, 10)\n",
        "from math import tan, pi\n\ndef area_polygon(s, l):\n    area = (s * l**2) / (4 * tan(pi/s))\n    return area\n",
        "from math import tan, pi\n\ndef area_polygon(s, n):\n    return (n * s**2) / (4 * tan(pi / n))\n"
    ],
    "MbppEval/164": [
        "import math\n\ndef div_sum(n):\n    \"\"\"\n    Write a function to determine the sum of the divisors of an integer.\n    \n    Args:\n        n (int): The integer to find the divisor sum for.\n    \n    Returns:\n        int: The sum of the divisors of `n`.\n    \"\"\"\n    divisor_sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            divisor_sum += i\n    return divisor_sum\n\ndef areEquivalent(a, b):\n    \"\"\"\n    Determine if the sum of the divisors of two integers are the same.\n    \n    Args:\n        a (int): The first integer.\n        b (int): The second integer.\n    \n    Returns:\n        bool: True if the sum of the divisors of `a` and `b` are the same, False otherwise.\n    \"\"\"\n    return div_sum(a) == div_sum(b)\n",
        "import math\n\ndef div_sum(n):\n    divisor_sum = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            divisor_sum += i\n    return divisor_sum\n\ndef areEquivalent(a, b):\n    a_divisor_sum = div_sum(a)\n    b_divisor_sum = div_sum(b)\n    return a_divisor_sum == b_divisor_sum\n",
        "import math\n\ndef div_sum(n):\n    \"\"\"\n    Write a function to determine the sum of the divisors of an integer.\n\n    Args:\n    n (int): The integer to find the divisor sum for.\n\n    Returns:\n    int: The sum of the divisors of n.\n    \"\"\"\n    divisors = []\n    for i in range(1, n+1):\n        if n % i == 0:\n            divisors.append(i)\n    return sum(divisors)\n\ndef areEquivalent(a, b):\n    \"\"\"\n    Determine if the sum of the divisors of two integers are the same.\n\n    Args:\n    a (int): The first integer.\n    b (int): The second integer.\n\n    Returns:\n    bool: True if the sum of the divisors of a and b are the same, False otherwise.\n    \"\"\"\n    return div_sum(a) == div_sum(b)\n",
        "def divisor_sum(n):\n    \"\"\"\n    Calculates the sum of all the divisors of an integer n.\n    \"\"\"\n    divisor_sum = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            divisor_sum += i\n    return divisor_sum\n\ndef are_divisor_sums_equal(a, b):\n    \"\"\"\n    Determines if the sum of the divisors of two integers are the same.\n    \"\"\"\n    return divisor_sum(a) == divisor_sum(b)\n",
        "import math\n\ndef div_sum(n):\n    '''\n    Write a function to determine the sum of the divisors of an integer.\n\n    Example:\n    div_sum(36) == 91\n    div_sum(57) == 150\n    '''\n    divisors = []\n    for i in range(1, n+1):\n        if n % i == 0:\n            divisors.append(i)\n    return sum(divisors)\n\ndef areEquivalent(a, b):\n    '''\n    Write a function to determine if the sum of the divisors of two integers are the same.\n\n    Examples:\n    areEquivalent(36,57) == False\n    areEquivalent(2,4) == False\n    areEquivalent(23,47) == True\n    '''\n    return div_sum(a) == div_sum(b)\n"
    ],
    "MbppEval/165": [
        "def count_char_position(str1):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    alphabet_dict = {char: i for i, char in enumerate(alphabet)}\n    count = 0\n    str1 = str1.lower()\n    for i, char in enumerate(str1):\n        if char in alphabet_dict and i == alphabet_dict[char]:\n            count += 1\n    return count\n",
        "def count_char_position(str1):\n    count = 0\n    for i, char in enumerate(str1.lower()):\n        if i == ord(char) - ord('a'):\n            count += 1\n    return count\n",
        "def count_char_position(str1):\n    count = 0\n    for i, char in enumerate(str1.lower()):\n        if i == ord(char) - ord('a'):\n            count += 1\n    return count\n",
        "def count_char_position(str1):\n    count = 0\n    for i, char in enumerate(str1.lower()):\n        if ord(char) - ord('a') + 1 == i + 1:\n            count += 1\n    return count\n",
        "def count_char_position(str1):\n    count = 0\n    for i, char in enumerate(str1.lower()):\n        if i + 1 == ord(char) - ord('a') + 1:\n            count += 1\n    return count\n"
    ],
    "MbppEval/166": [
        "def find_even_pair(A):\n    count = 0\n    for i in range(len(A)):\n        for j in range(i+1, len(A)):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n",
        "def find_even_pair(A):\n    even_xor_dict = {}\n    count = 0\n    for a in A:\n        if (a ^ 2) in even_xor_dict:\n            count += even_xor_dict[a ^ 2]\n        even_xor_dict[a] = even_xor_dict.get(a, 0) + 1\n    return count\n",
        "def find_even_pair(A):\n    xor_set = set()\n    count = 0\n    \n    for num in A:\n        current_xor = num\n        if current_xor ^ current_xor in xor_set:\n            count += 1\n        xor_set.add(current_xor)\n    \n    return count\n",
        "def find_even_pair(A):\n    even_count = 0\n    odd_count = 0\n    even_pairs = 0\n\n    # Count even and odd numbers\n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    # Calculate the number of pairs that XOR to an even number\n    for num in A:\n        even_pairs += even_count * odd_count\n        if num % 2 == 0:\n            even_count -= 1\n        else:\n            odd_count -= 1\n\n    return even_pairs\n",
        "def find_even_pair(A):\n    count = 0\n    for i in range(len(A)):\n        for j in range(i+1, len(A)):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n"
    ],
    "MbppEval/167": [
        "def next_power_of_2(n):\n    if n == 0:\n        return 1\n    \n    return 2 ** ((n - 1).bit_length())\n",
        "def next_power_of_2(n):\n    if n == 0:\n        return 1\n    else:\n        return 2 ** (n - 1).bit_length()\n",
        "def next_power_of_2(n):\n    \"\"\"\n    Write a python function to find the smallest power of 2 greater than or equal to n.\n\n    Examples:\n    next_Power_Of_2(0) == 1\n    next_Power_Of_2(5) == 8\n    next_Power_Of_2(17) == 32\n    \"\"\"\n    if n == 0:\n        return 1\n    return (n - 1) | (n - 1) + 1\n",
        "def next_power_of_2(n):\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n\n    Examples:\n    next_power_of_2(0) == 1\n    next_power_of_2(5) == 8\n    next_power_of_2(17) == 32\n    \"\"\"\n    power = 1\n    while power < n:\n        power *= 2\n    return power\n",
        "def next_power_of_2(n):\n    \"\"\"\n    Write a python function to find the smallest power of 2 greater than or equal to n.\n\n    Examples:\n    next_power_of_2(0) == 1\n    next_power_of_2(5) == 8\n    next_power_of_2(17) == 32\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    power = 1\n    while power < n:\n        power *= 2\n    \n    return power\n"
    ],
    "MbppEval/168": [
        "def frequency(a, x):\n    count = 0\n    for element in a:\n        if element == x:\n            count += 1\n    return count\n",
        "def frequency(a, x):\n    count = 0\n    for element in a:\n        if element == x:\n            count += 1\n    return count\n",
        "def frequency(a, x):\n    count = 0\n    for num in a:\n        if num == x:\n            count += 1\n    return count\n",
        "def frequency(a, x):\n    count = 0\n    for element in a:\n        if element == x:\n            count += 1\n    return count\n",
        "def frequency(a, x):\n    count = 0\n    for num in a:\n        if num == x:\n            count += 1\n    return count\n"
    ],
    "MbppEval/170": [
        "def sum_range_list(list1, m, n):\n    total = 0\n    for i in range(m, n+1):\n        total += list1[i]\n    return total\n",
        "def sum_range_list(list1, m, n):\n    total = 0\n    for i in range(m, n+1):\n        total += list1[i]\n    return total\n",
        "def sum_range_list(list1, m, n):\n    if not isinstance(list1, list):\n        raise TypeError(\"Input must be a list\")\n    if m < 0 or n >= len(list1):\n        raise IndexError(\"Indices out of range\")\n    if m > n:\n        raise ValueError(\"m must be less than or equal to n\")\n\n    sum_range = 0\n    for i in range(m, n+1):\n        sum_range += list1[i]\n    return sum_range\n",
        "def sum_range_list(list1, m, n):\n    sum_range = 0\n    for i in range(m, n+1):\n        sum_range += list1[i]\n    return sum_range\n",
        "def sum_range_list(list1, m, n):\n    total = 0\n    for i in range(m, n+1):\n        total += list1[i]\n    return total\n"
    ],
    "MbppEval/171": [
        "import math\n\ndef perimeter_pentagon(a):\n    return 5 * a\n",
        "def perimeter_pentagon(a):\n    return 5 * a\n",
        "import math\n\ndef perimeter_pentagon(a):\n    perimeter = a * 5\n    return perimeter\n",
        "import math\n\ndef perimeter_pentagon(a):\n    return 5 * a\n",
        "def perimeter_pentagon(a):\n    return 5 * a\n"
    ],
    "MbppEval/172": [
        "def count_occurance(s):\n    return s.count('std')\n",
        "def count_occurance(s):\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count\n",
        "def count_occurance(s):\n    return s.lower().count('std')\n",
        "def count_occurance(s):\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count\n",
        "def count_occurance(s):\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count\n"
    ],
    "MbppEval/222": [
        "def check_type(test_tuple):\n    \"\"\"\n    Write a function to check if all the elements in tuple have same data type or not.\n\n    Examples:\n    check_type((5, 6, 7, 3, 5, 6)) == True\n    check_type((1, 2, \"4\")) == False\n    check_type((3, 2, 1, 4, 5)) == True\n    \"\"\"\n    data_type = type(test_tuple[0])\n    for element in test_tuple:\n        if type(element) != data_type:\n            return False\n    return True\n",
        "def check_type(test_tuple):\n    \"\"\"\n    Write a function to check if all the elements in tuple have same data type or not.\n\n    Examples:\n    check_type((5, 6, 7, 3, 5, 6)) == True\n    check_type((1, 2, \"4\")) == False\n    check_type((3, 2, 1, 4, 5)) == True\n    \"\"\"\n    if len(test_tuple) == 0:\n        return True\n\n    data_type = type(test_tuple[0])\n\n    for element in test_tuple:\n        if type(element) != data_type:\n            return False\n\n    return True\n",
        "def check_type(test_tuple):\n    data_types = set()\n    for element in test_tuple:\n        data_types.add(type(element))\n    return len(data_types) == 1\n",
        "def check_type(test_tuple):\n    \"\"\"\n    Write a function to check if all the elements in tuple have same data type or not.\n\n    Examples:\n    check_type((5, 6, 7, 3, 5, 6)) == True\n    check_type((1, 2, \"4\")) == False\n    check_type((3, 2, 1, 4, 5)) == True\n    \"\"\"\n    if not test_tuple:\n        return True\n\n    data_type = type(test_tuple[0])\n\n    for element in test_tuple:\n        if type(element) != data_type:\n            return False\n\n    return True\n",
        "def check_type(test_tuple):\n    data_type = type(test_tuple[0])\n    for element in test_tuple:\n        if type(element) != data_type:\n            return False\n    return True\n"
    ],
    "MbppEval/223": [
        "def is_majority(arr, n, x):\n    # Find the first and last index of x in the sorted array\n    first_index = 0\n    last_index = n - 1\n    while first_index <= last_index:\n        mid = (first_index + last_index) // 2\n        if arr[mid] == x:\n            break\n        elif arr[mid] < x:\n            first_index = mid + 1\n        else:\n            last_index = mid - 1\n    \n    # If x is not present in the array, return False\n    if arr[first_index] != x:\n        return False\n    \n    # Calculate the count of x\n    count = last_index - first_index + 1\n    \n    # Check if x is the majority element\n    return count > n // 2\n",
        "def is_majority(arr, n, x):\n    # Find the first occurrence of x\n    left = 0\n    right = n - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == x:\n            if mid == 0 or arr[mid-1] != x:\n                break\n            right = mid - 1\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    # If x is not present in the array, return False\n    if left > right:\n        return False\n    \n    # Find the last occurrence of x\n    start = mid\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == x:\n            if mid == n-1 or arr[mid+1] != x:\n                break\n            left = mid + 1\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    # Calculate the number of occurrences of x\n    count = mid - start + 1\n    \n    # Check if count is greater than n//2\n    return count > n // 2\n",
        "def is_majority(arr, n, x):\n    \"\"\"\n    Write a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\n\n    Examples:\n    is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True\n    is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False\n    is_majority([1, 1, 1, 2, 2], 5, 1) == True\n    \"\"\"\n    # Find the first occurrence of x\n    left = 0\n    right = n - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == x:\n            if mid == 0 or arr[mid - 1] != x:\n                break\n            right = mid - 1\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    if left > n - 1 or arr[left] != x:\n        return False\n\n    first_idx = left\n\n    # Find the last occurrence of x\n    left = 0\n    right = n - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == x:\n            if mid == n - 1 or arr[mid + 1] != x:\n                break\n            left = mid + 1\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    last_idx = mid\n\n    return last_idx - first_idx + 1 > n // 2\n",
        "def is_majority(arr, n, x):\n    # Find the first and last index of x in the sorted array\n    first = 0\n    last = n - 1\n    while first <= last:\n        mid = (first + last) // 2\n        if arr[mid] == x:\n            break\n        elif arr[mid] < x:\n            first = mid + 1\n        else:\n            last = mid - 1\n\n    # If x is not found in the array, return False\n    if arr[mid] != x:\n        return False\n\n    # Find the first index of x\n    start = mid\n    while start > 0 and arr[start - 1] == x:\n        start -= 1\n\n    # Find the last index of x\n    end = mid\n    while end < n - 1 and arr[end + 1] == x:\n        end += 1\n\n    # Check if the count of x is greater than n/2\n    if end - start + 1 > n // 2:\n        return True\n    else:\n        return False\n",
        "def is_majority(arr, n, x):\n    # Find the first occurrence of x\n    left = 0\n    right = n - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == x:\n            if mid == 0 or arr[mid - 1] != x:\n                break\n            right = mid - 1\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    # If x is not present in the array, return False\n    if arr[mid] != x:\n        return False\n\n    first_occurrence = mid\n\n    # Find the last occurrence of x\n    left = mid\n    right = n - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == x:\n            if mid == n - 1 or arr[mid + 1] != x:\n                break\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    last_occurrence = mid\n\n    # Check if the majority condition is met\n    return last_occurrence - first_occurrence + 1 > n // 2\n"
    ],
    "MbppEval/224": [
        "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n",
        "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n",
        "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n",
        "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n",
        "def count_Set_Bits(n):\n    count = 0\n    while n:\n        if n & 1:\n            count += 1\n        n >>= 1\n    return count\n"
    ],
    "MbppEval/226": [
        "def odd_values_string(str):\n    result = \"\"\n    for i, char in enumerate(str):\n        if i % 2 == 0:\n            result += char\n    return result\n",
        "def odd_values_string(str):\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result += str[i]\n    return result\n",
        "def odd_values_string(str):\n    result = \"\"\n    for i, char in enumerate(str):\n        if i % 2 == 0:\n            result += char\n    return result\n",
        "def odd_values_string(str):\n    result = \"\"\n    for i, char in enumerate(str):\n        if i % 2 == 0:\n            result += char\n    return result\n",
        "def odd_values_string(str):\n    result = \"\"\n    for i in range(1, len(str), 2):\n        result += str[i]\n    return result\n"
    ],
    "MbppEval/227": [
        "def min_of_three(a, b, c):\n    if a <= b and a <= c:\n        return a\n    elif b <= a and b <= c:\n        return b\n    else:\n        return c\n",
        "def min_of_three(a, b, c):\n    return min(a, b, c)\n",
        "def min_of_three(a, b, c):\n    if a <= b and a <= c:\n        return a\n    elif b <= a and b <= c:\n        return b\n    else:\n        return c\n",
        "def min_of_three(a, b, c):\n    minimum = a\n    \n    if b < minimum:\n        minimum = b\n    if c < minimum:\n        minimum = c\n    \n    return minimum\n",
        "def min_of_three(a, b, c):\n    return min(a, b, c)\n"
    ],
    "MbppEval/228": [
        "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    mask = (1 << (r - l + 1)) - 1\n    return (n & mask) == mask\n",
        "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    mask = (1 << (r - l + 1)) - 1\n    mask <<= l\n    return (n & mask) == mask\n",
        "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    mask = (1 << (r-l+1)) - 1\n    return (n & mask) == mask\n",
        "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    mask = (1 << (r - l + 1)) - 1\n    mask <<= l\n    return (n & mask) == mask\n",
        "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    mask = (1 << (r - l + 1)) - 1\n    mask <<= l\n    return (n & mask) == 0\n"
    ],
    "MbppEval/229": [
        "def re_arrange_array(arr, n):\n    negative = []\n    positive = []\n\n    for num in arr[:n]:\n        if num < 0:\n            negative.append(num)\n        else:\n            positive.append(num)\n\n    return negative + positive\n",
        "def re_arrange_array(arr, n):\n    i = 0\n    j = 0\n    \n    for i in range(n):\n        if arr[i] < 0:\n            arr[i], arr[j] = arr[j], arr[i]\n            j += 1\n    \n    return arr\n",
        "def re_arrange_array(arr, n):\n    \"\"\"\n    Rearranges the first n elements of the given array so that all negative elements appear before positive ones,\n    while preserving the relative order among negative and positive elements.\n    \"\"\"\n    negative = []\n    positive = []\n    \n    for i in range(n):\n        if arr[i] < 0:\n            negative.append(arr[i])\n        else:\n            positive.append(arr[i])\n    \n    return negative + positive\n",
        "def re_arrange_array(arr, n):\n    left = 0\n    right = n - 1\n\n    while left <= right:\n        if arr[left] < 0:\n            left += 1\n        elif arr[right] >= 0:\n            right -= 1\n        else:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    return arr\n",
        "def re_arrange_array(arr, n):\n    left = 0\n    right = n - 1\n    \n    while left < right:\n        if arr[left] < 0:\n            left += 1\n        else:\n            arr[left], arr[right] = arr[right], arr[left]\n            right -= 1\n    \n    return arr\n"
    ],
    "MbppEval/230": [
        "def replace_blank(str1, char):\n    result = \"\"\n    for c in str1:\n        if c == \" \":\n            result += char\n        else:\n            result += c\n    return result\n",
        "def replace_blank(str1, char):\n    result = \"\"\n    for c in str1:\n        if c == \" \":\n            result += char\n        else:\n            result += c\n    return result\n",
        "def replace_blank(str1, char):\n    new_str = \"\"\n    for char_in_str in str1:\n        if char_in_str == \" \":\n            new_str += char\n        else:\n            new_str += char_in_str\n    return new_str\n",
        "def replace_blank(str1, char):\n    new_str = \"\"\n    for c in str1:\n        if c.isspace():\n            new_str += char\n        else:\n            new_str += c\n    return new_str\n",
        "def replace_blank(str1, char):\n    result = ''\n    for c in str1:\n        if c == ' ':\n            result += char\n        else:\n            result += c\n    return result\n"
    ],
    "MbppEval/232": [
        "import heapq\n\ndef larg_nnum(list1, n):\n    return heapq.nlargest(n, list1)\n",
        "import heapq\n\ndef larg_nnum(list1, n):\n    heapq.heapify(list1)\n    return heapq.nlargest(n, list1)\n",
        "import heapq\n\ndef larg_nnum(list1, n):\n    return heapq.nlargest(n, list1)\n",
        "import heapq\n\ndef larg_nnum(list1, n):\n    return heapq.nlargest(n, list1)\n",
        "import heapq\n\ndef larg_nnum(list1, n):\n    return heapq.nlargest(n, list1)\n"
    ],
    "MbppEval/233": [
        "import math\n\ndef lateralsuface_cylinder(r, h):\n    \"\"\"\n    Write a function to find the lateral surface area of a cylinder.\n\n    Examples:\n    lateralsuface_cylinder(10, 5) == 314.1592653589793\n    lateralsuface_cylinder(4, 5) == 125.66370614359172\n    lateralsuface_cylinder(4, 10) == 251.32741228718345\n    \"\"\"\n    lateral_surface_area = 2 * math.pi * r * h\n    return lateral_surface_area\n",
        "import math\n\ndef lateralsuface_cylinder(r, h):\n    \"\"\"\n    Write a function to find the lateral surface area of a cylinder.\n\n    Examples:\n    lateralsuface_cylinder(10, 5) == 314.1592653589793\n    lateralsuface_cylinder(4, 5) == 125.66370614359172\n    lateralsuface_cylinder(4, 10) == 251.32741228718345\n    \"\"\"\n    lateral_surface_area = 2 * math.pi * r * h\n    return lateral_surface_area\n",
        "import math\n\ndef lateralsuface_cylinder(r, h):\n    lateral_surface_area = 2 * math.pi * r * h\n    return lateral_surface_area\n",
        "import math\n\ndef lateralsuface_cylinder(r, h):\n    lateral_surface_area = 2 * math.pi * r * h\n    return round(lateral_surface_area, 2)\n",
        "import math\n\ndef lateralsuface_cylinder(r, h):\n    lateral_surface_area = 2 * math.pi * r * h\n    return lateral_surface_area\n"
    ],
    "MbppEval/234": [
        "def volume_cube(l):\n    \"\"\"\n    Write a function to find the volume of a cube given its side length.\n\n    Examples:\n    volume_cube(3) == 27\n    volume_cube(2) == 8\n    volume_cube(5) == 125\n    \"\"\"\n    return l * l * l\n",
        "def volume_cube(l):\n    return l * l * l\n",
        "def volume_cube(l):\n    \"\"\"\n    Write a function to find the volume of a cube given its side length.\n\n    Examples:\n    volume_cube(3) == 27\n    volume_cube(2) == 8\n    volume_cube(5) == 125\n    \"\"\"\n    return l ** 3\n",
        "def volume_cube(l):\n    return l ** 3\n",
        "def volume_cube(l):\n    '''\n    Write a function to find the volume of a cube given its side length.\n\n    Parameters:\n    l (int or float): The side length of the cube.\n\n    Returns:\n    int or float: The volume of the cube.\n\n    Examples:\n    volume_cube(3) == 27\n    volume_cube(2) == 8\n    volume_cube(5) == 125\n    '''\n    volume = l * l * l\n    return volume\n"
    ],
    "MbppEval/235": [
        "def even_bit_set_number(n):\n    even_bit_mask = 0b1010101010101010\n    return n | even_bit_mask\n",
        "def even_bit_set_number(n):\n    mask = 0b10101010101010101010101010101010\n    result = n | mask\n    return result\n",
        "def even_bit_set_number(n):\n    mask = 0b10101010101010101010101010101010\n    return n | mask\n",
        "def even_bit_set_number(n):\n    odd_mask = 0b1010101010101010\n    result = n | odd_mask\n    return result\n",
        "def even_bit_set_number(n):\n    mask = 0b10101010101010101010101010101010\n    result = n | mask\n    return result\n"
    ],
    "MbppEval/237": [
        "from collections import Counter\n\ndef check_occurrences(test_list):\n    tuple_count = {}\n\n    for tup in test_list:\n        if tup not in tuple_count:\n            tuple_count[tup] = 1\n        else:\n            tuple_count[tup] += 1\n\n    return tuple_count\n",
        "from collections import Counter\n\ndef check_occurences(test_list):\n    tuple_count = {}\n\n    for tup in test_list:\n        if tup in tuple_count:\n            tuple_count[tup] += 1\n        else:\n            tuple_count[tup] = 1\n\n    return tuple_count\n",
        "from collections import Counter \n\ndef check_occurrences(test_list):\n    return dict(Counter(test_list))\n",
        "from collections import Counter \n\ndef check_occurences(test_list):\n    count_dict = {}\n    for tup in test_list:\n        if tup in count_dict:\n            count_dict[tup] += 1\n        else:\n            count_dict[tup] = 1\n    return count_dict\n",
        "from collections import Counter\n\ndef check_occurences(test_list):\n    tuple_count = Counter(test_list)\n    return dict(tuple_count)\n"
    ],
    "MbppEval/238": [
        "def number_of_substrings(s):\n    n = len(s)\n    return n * (n + 1) // 2\n",
        "def number_of_substrings(s):\n    count = 0\n    for i in range(len(s)):\n        count += len(s) - i\n    return count\n",
        "def number_of_substrings(str):\n    return len(str) * (len(str) + 1) // 2\n",
        "def number_of_substrings(str):\n    n = len(str)\n    return int(n * (n + 1) / 2)\n",
        "def number_of_substrings(s):\n    n = len(s)\n    return int(n * (n + 1) / 2)\n"
    ],
    "MbppEval/239": [
        "def get_total_number_of_sequences(m, n):\n    def helper(n, start):\n        if n == 1:\n            return m - start + 1\n        \n        count = 0\n        for i in range(start, m+1):\n            count += helper(n-1, i)\n        return count\n    \n    return helper(n, 2)\n",
        "def get_total_number_of_sequences(m, n):\n    if n == 1:\n        return m\n    if m < 2:\n        return 0\n    \n    total = 0\n    for first_element in range(2, m+1):\n        total += get_total_number_of_sequences(min(m, first_element * 2), n-1)\n    \n    return total\n",
        "def get_total_number_of_sequences(m, n):\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    \n    # Base case: sequences of length 1\n    for i in range(1, m+1):\n        dp[i][1] = 1\n    \n    # Compute the number of sequences\n    for j in range(2, n+1):\n        for i in range(1, m+1):\n            for k in range(max(1, i//2), i):\n                dp[i][j] += dp[k][j-1]\n    \n    # Sum up the values in the last column\n    return sum(dp[i][n] for i in range(1, m+1))\n",
        "def get_total_number_of_sequences(m, n):\n    dp = [[0] * (n+1) for _ in range(m+1)]\n\n    # Base case: there is 1 sequence of length 1 for each valid integer\n    for i in range(1, m+1):\n        dp[i][1] = 1\n\n    for j in range(2, n+1):\n        for i in range(1, m+1):\n            min_val = max(1, i//2)\n            for k in range(min_val, i):\n                dp[i][j] += dp[k][j-1]\n\n    return sum(dp[i][n] for i in range(1, m+1))\n",
        "def get_total_number_of_sequences(m, n):\n    count = 0\n    for first_element in range(1, m+1):\n        current_element = first_element\n        for _ in range(n-1):\n            current_element = max(current_element * 2, current_element + 1)\n            if current_element > m:\n                break\n        else:\n            count += 1\n    return count\n"
    ],
    "MbppEval/240": [
        "def replace_list(list1, list2):\n    return list1[:-1] + list2\n",
        "def replace_list(list1, list2):\n    len_list1 = len(list1)\n    list1[-1] = list2\n    return list1\n",
        "def replace_list(list1, list2):\n    return list1[:-1] + list2\n",
        "def replace_list(list1, list2):\n    new_list = list1[:]\n    new_list[-1] = list2\n    return new_list\n",
        "def replace_list(list1, list2):\n    if not list1:\n        return list2\n    if not list2:\n        return list1\n    return list1[:-1] + list2\n"
    ],
    "MbppEval/242": [
        "def count_charac(str1):\n    char_count = 0\n    for char in str1:\n        char_count += 1\n    return char_count\n",
        "def count_charac(str1):\n    return len(str1)\n",
        "def count_charac(str1):\n    total_chars = 0\n    for char in str1:\n        total_chars += 1\n    return total_chars\n",
        "def count_charac(str1):\n    total_chars = 0\n    for char in str1:\n        total_chars += 1\n    return total_chars\n",
        "def count_charac(str1):\n    char_count = 0\n    for char in str1:\n        char_count += 1\n    return char_count\n"
    ],
    "MbppEval/244": [
        "import math\n\ndef next_Perfect_Square(N):\n    \"\"\"\n    Write a python function to find the next perfect square greater than a given number.\n\n    Examples:\n    next_Perfect_Square(35) == 36\n    next_Perfect_Square(6) == 9\n    next_Perfect_Square(9) == 16\n    \"\"\"\n    sqrt = math.sqrt(N)\n    next_sqrt = math.ceil(sqrt)\n    next_perfect_square = next_sqrt ** 2\n    return int(next_perfect_square)\n",
        "import math\n\ndef next_Perfect_Square(N):\n    next_sqrt = math.ceil(math.sqrt(N))\n    return next_sqrt ** 2\n",
        "import math\n\ndef next_Perfect_Square(N):\n    square_root = math.sqrt(N)\n    next_square = math.ceil(square_root)\n    return next_square ** 2\n",
        "import math\n\ndef next_Perfect_Square(N):\n    sqrt = math.sqrt(N)\n    next_sqrt = math.ceil(sqrt)\n    next_perfect_square = next_sqrt ** 2\n    return int(next_perfect_square)\n",
        "import math\n\ndef next_Perfect_Square(N):\n    sqrt = math.sqrt(N)\n    if sqrt.is_integer():\n        return int(sqrt + 1) ** 2\n    else:\n        return int(math.ceil(sqrt)) ** 2\n"
    ],
    "MbppEval/245": [
        "def max_sum(arr):\n    n = len(arr)\n    increasing = [0] * n\n    decreasing = [0] * n\n\n    # Initialize the first elements\n    increasing[0] = arr[0]\n    decreasing[n-1] = arr[-1]\n\n    # Calculate the increasing and decreasing subsequences\n    for i in range(1, n):\n        increasing[i] = max(arr[i], increasing[i-1] + arr[i])\n\n    for i in range(n-2, -1, -1):\n        decreasing[i] = max(arr[i], decreasing[i+1] + arr[i])\n\n    # Find the maximum sum where the increasing and decreasing subsequences meet\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, increasing[i] + decreasing[i] - arr[i])\n\n    return max_sum\n",
        "def max_sum(arr):\n    n = len(arr)\n    \n    lis = [1] * n\n    lds = [1] * n\n    \n    for i in range(1, n):\n        if arr[i] > arr[i-1]:\n            lis[i] = lis[i-1] + 1\n    \n    for i in range(n-2, -1, -1):\n        if arr[i] > arr[i+1]:\n            lds[i] = lds[i+1] + 1\n    \n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, lis[i] + lds[i] - 1)\n    \n    return max_sum\n",
        "def max_sum(arr):\n    n = len(arr)\n    increasing = [0] * n\n    decreasing = [0] * n\n\n    increasing[0] = arr[0]\n    for i in range(1, n):\n        increasing[i] = max(increasing[i-1] + arr[i], arr[i])\n\n    decreasing[n-1] = arr[n-1]\n    for i in range(n-2, -1, -1):\n        decreasing[i] = max(decreasing[i+1] + arr[i], arr[i])\n\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, increasing[i] + decreasing[i] - arr[i])\n\n    return max_sum\n",
        "def max_sum(arr):\n    n = len(arr)\n    increasing = [0] * n\n    decreasing = [0] * n\n\n    # Compute the increasing subsequence\n    increasing[0] = arr[0]\n    for i in range(1, n):\n        increasing[i] = max(increasing[i-1] + arr[i], arr[i])\n\n    # Compute the decreasing subsequence\n    decreasing[n-1] = arr[n-1]\n    for i in range(n-2, -1, -1):\n        decreasing[i] = max(decreasing[i+1] + arr[i], arr[i])\n\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, increasing[i] + decreasing[i] - arr[i])\n\n    return max_sum\n",
        "def max_sum(arr):\n    n = len(arr)\n    increasing = [0] * n\n    decreasing = [0] * n\n\n    # Calculate the increasing part\n    increasing[0] = arr[0]\n    for i in range(1, n):\n        increasing[i] = max(arr[i], increasing[i-1] + arr[i])\n\n    # Calculate the decreasing part\n    decreasing[n-1] = arr[n-1]\n    for i in range(n-2, -1, -1):\n        decreasing[i] = max(arr[i], decreasing[i+1] + arr[i])\n\n    max_val = 0\n    for i in range(n):\n        max_val = max(max_val, increasing[i] + decreasing[i] - arr[i])\n\n    return max_val\n"
    ],
    "MbppEval/246": [
        "def babylonian_squareroot(number):\n    \"\"\"\n    Write a function for computing square roots using the Babylonian method.\n\n    Examples:\n    babylonian_squareroot(10) == 3.162277660168379\n    babylonian_squareroot(2) == 1.414213562373095\n    babylonian_squareroot(9) == 3.0\n    \"\"\"\n    x = number / 2\n    while abs(x - number / x) > 1e-10:\n        x = (x + number / x) / 2\n    return x\n",
        "def babylonian_squareroot(number):\n    \"\"\"\n    Write a function for computing square roots using the babylonian method.\n\n    Examples:\n    babylonian_squareroot(10) == 3.162277660168379\n    babylonian_squareroot(2) == 1.414213562373095\n    babylonian_squareroot(9) == 3.0\n    \"\"\"\n    guess = number\n    tolerance = 1e-10\n\n    while abs(guess - number/guess) > tolerance:\n        guess = (guess + number/guess) / 2\n\n    return guess\n",
        "def babylonian_squareroot(number):\n    \"\"\"\n    Write a function for computing square roots using the Babylonian method.\n\n    Examples:\n    babylonian_squareroot(10) == 3.162277660168379\n    babylonian_squareroot(2) == 1.414213562373095\n    babylonian_squareroot(9) == 3.0\n    \"\"\"\n    guess = number / 2\n    previous_guess = 0\n\n    while abs(guess - previous_guess) > 1e-10:\n        previous_guess = guess\n        guess = (guess + number / guess) / 2\n\n    return guess\n",
        "def babylonian_squareroot(number):\n    \"\"\"\n    Write a function for computing square roots using the Babylonian method.\n\n    Examples:\n    babylonian_squareroot(10) == 3.162277660168379\n    babylonian_squareroot(2) == 1.414213562373095\n    babylonian_squareroot(9) == 3.0\n    \"\"\"\n    guess = (1 + number) / 2\n    \n    while abs(guess**2 - number) >= 0.000001:\n        guess = (guess + number/guess) / 2\n    \n    return guess\n",
        "def babylonian_squareroot(number):\n    '''\n    Write a function for computing square roots using the babylonian method.\n\n    Examples:\n    babylonian_squareroot(10) == 3.162277660168379\n    babylonian_squareroot(2) == 1.414213562373095\n    babylonian_squareroot(9) == 3.0\n    '''\n    guess = number\n    while True:\n        new_guess = (guess + number / guess) / 2\n        if abs(new_guess - guess) < 1e-10:\n            break\n        guess = new_guess\n    return new_guess\n"
    ],
    "MbppEval/247": [
        "def lps(str):\n    n = len(str)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Base cases\n    for i in range(n):\n        dp[i][i] = 1\n    \n    for length in range(2, n+1):\n        for i in range(n-length+1):\n            j = i + length - 1\n            if str[i] == str[j]:\n                dp[i][j] = 2 + dp[i+1][j-1]\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    \n    return dp[0][n-1]\n",
        "def lps(str):\n    n = len(str)\n    dp = [[0] * n for _ in range(n)]\n\n    # Base case: for substrings of length 1, the length of the longest palindromic subsequence is 1\n    for i in range(n):\n        dp[i][i] = 1\n\n    # For substrings of length 2, if the characters are the same, the length is 2, else it is 1\n    for i in range(n-1):\n        if str[i] == str[i+1]:\n            dp[i][i+1] = 2\n        else:\n            dp[i][i+1] = 1\n\n    # For substrings of length greater than 2\n    for length in range(3, n+1):\n        for i in range(n-length+1):\n            j = i + length - 1\n            if str[i] == str[j]:\n                dp[i][j] = 2 + dp[i+1][j-1]\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n\n    return dp[0][n-1]\n",
        "def lps(str):\n    n = len(str)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n+1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if str[i] == str[j]:\n                dp[i][j] = 2 + dp[i+1][j-1]\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n\n    return dp[0][n-1]\n",
        "def lps(str):\n    n = len(str)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Initialize the diagonal elements\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the dp table\n    for length in range(2, n+1):\n        for start in range(n - length + 1):\n            end = start + length - 1\n            if str[start] == str[end]:\n                dp[start][end] = dp[start+1][end-1] + 2\n            else:\n                dp[start][end] = max(dp[start+1][end], dp[start][end-1])\n    \n    return dp[0][n-1]\n",
        "def lps(str):\n    n = len(str)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Base case: length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Base case: length 2\n    for i in range(n-1):\n        if str[i] == str[i+1]:\n            dp[i][i+1] = 2\n        else:\n            dp[i][i+1] = 1\n    \n    # Compute the length for substrings of length 3 to n\n    for length in range(3, n+1):\n        for i in range(n-length+1):\n            j = i + length - 1\n            if str[i] == str[j]:\n                dp[i][j] = 2 + dp[i+1][j-1]\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    \n    return dp[0][n-1]\n"
    ],
    "MbppEval/248": [
        "def harmonic_sum(n):\n    sum_harmonic = 0\n    for i in range(1, n):\n        sum_harmonic += 1/i\n    return sum_harmonic\n",
        "def harmonic_sum(n):\n    if n == 1:\n        return 0\n    \n    harmonic_sum_n_1 = 0\n    for i in range(1, n):\n        harmonic_sum_n_1 += 1 / i\n    \n    return harmonic_sum_n_1\n",
        "def harmonic_sum(n):\n    result = 0\n    for i in range(1, n):\n        result += 1/i\n    return result\n",
        "import math\n\ndef harmonic_sum(n):\n    return math.log(n) + 0.5772\n",
        "def harmonic_sum(n):\n    \"\"\"\n    Write a function that takes in an integer n and calculates the harmonic sum of n-1.\n\n    Examples:\n    harmonic_sum(7) == 2.5928571428571425\n    harmonic_sum(4) == 2.083333333333333\n    harmonic_sum(19) == 3.547739657143682\n    \"\"\"\n    harmonic_sum = 0.0\n    for i in range(1, n+1):\n        harmonic_sum += 1 / i\n    return harmonic_sum\n"
    ],
    "MbppEval/249": [
        "def intersection_array(array_nums1, array_nums2):\n    num_dict = {}\n    for num in array_nums1:\n        num_dict[num] = True\n    intersection = []\n    for num in array_nums2:\n        if num in num_dict:\n            intersection.append(num)\n    return intersection\n",
        "def intersection_array(array_nums1, array_nums2):\n    common_elements = []\n    for num in array_nums1:\n        if num in array_nums2:\n            common_elements.append(num)\n    return common_elements\n",
        "def intersection_array(array_nums1, array_nums2):\n    return list(set(array_nums1) & set(array_nums2))\n",
        "def intersection_array(array_nums1, array_nums2):\n    intersection = []\n    for num in array_nums1:\n        if num in array_nums2:\n            intersection.append(num)\n    return intersection\n",
        "def intersection_array(array_nums1, array_nums2):\n    intersection = []\n    for num in array_nums1:\n        if num in array_nums2:\n            intersection.append(num)\n    return intersection\n"
    ],
    "MbppEval/250": [
        "def count_X(tup, x):\n    count = 0\n    for element in tup:\n        if element == x:\n            count += 1\n    return count\n",
        "def count_X(tup, x):\n    count = 0\n    for element in tup:\n        if element == x:\n            count += 1\n    return count\n",
        "def count_X(tup, x):\n    count = 0\n    for element in tup:\n        if element == x:\n            count += 1\n    return count\n",
        "def count_X(tup, x):\n    count = 0\n    for element in tup:\n        if element == x:\n            count += 1\n    return count\n",
        "def count_X(tup, x):\n    count = 0\n    for element in tup:\n        if element == x:\n            count += 1\n    return count\n"
    ],
    "MbppEval/251": [
        "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result\n",
        "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result\n",
        "def insert_element(list, element):\n    result = []\n    for item in list:\n        result.append(element)\n        result.append(item)\n    return result\n",
        "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result\n",
        "def insert_element(list, element):\n    return [item if i == 0 else element + item for i, item in enumerate(list)]\n"
    ],
    "MbppEval/252": [
        "import cmath\n\ndef convert(num):\n    \"\"\"\n    Write a python function to convert complex numbers to polar coordinates.\n\n    Examples:\n    convert(1) == (1.0, 0.0)\n    convert(4) == (4.0, 0.0)\n    convert(5) == (5.0, 0.0)\n    \"\"\"\n    complex_num = complex(num)\n    magnitude = abs(complex_num)\n    angle = cmath.phase(complex_num)\n    return (magnitude, angle)\n",
        "import cmath\n\ndef convert(num):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n\n    Args:\n        num (complex): The complex number to be converted.\n\n    Returns:\n        tuple: A tuple containing the magnitude and angle of the complex number.\n    \"\"\"\n    magnitude = abs(num)\n    angle = cmath.phase(num)\n    return (magnitude, angle)\n",
        "import cmath\n\ndef convert(number):\n    magnitude, phase = cmath.polar(number)\n    return (magnitude, phase)\n",
        "import cmath\n\ndef convert(num):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n    \n    Args:\n        num (complex): The complex number to be converted.\n    \n    Returns:\n        (float, float): The magnitude (modulus) and angle (phase) of the complex number.\n    \"\"\"\n    magnitude = abs(num)\n    angle = cmath.phase(num)\n    return (magnitude, angle)\n",
        "import cmath\n\ndef convert(numbers):\n    r, theta = cmath.polar(complex(numbers))\n    return r, theta\n"
    ],
    "MbppEval/253": [
        "def count_integer(list1):\n    count = 0\n    for item in list1:\n        if isinstance(item, int):\n            count += 1\n    return count\n",
        "def count_integer(list1):\n    count = 0\n    for element in list1:\n        if isinstance(element, int):\n            count += 1\n    return count\n",
        "def count_integer(list1):\n    count = 0\n    for element in list1:\n        if isinstance(element, int):\n            count += 1\n    return count\n",
        "def count_integer(list1):\n    count = 0\n    for element in list1:\n        if isinstance(element, int):\n            count += 1\n    return count\n",
        "def count_integer(list1):\n    count = 0\n    for element in list1:\n        if isinstance(element, int):\n            count += 1\n    return count\n"
    ],
    "MbppEval/255": [
        "from itertools import combinations_with_replacement\n\ndef combinations_colors(l, n):\n    \"\"\"\n    Write a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list of lists.\n\n    Examples:\n    combinations_colors( [\"Red\",\"Green\",\"Blue\"],1) == [['Red'], ['Green'], ['Blue']]\n    combinations_colors( [\"Red\",\"Green\",\"Blue\"],2) == [['Red', 'Red'], ['Red', 'Green'], ['Red', 'Blue'], ['Green', 'Green'], ['Green', 'Blue'], ['Blue', 'Blue']]\n    combinations_colors( [\"Red\",\"Green\",\"Blue\"],3) == [['Red', 'Red', 'Red'], ['Red', 'Red', 'Green'], ['Red', 'Red', 'Blue'], ['Red', 'Green', 'Green'], ['Red', 'Green', 'Blue'], ['Red', 'Blue', 'Blue'], ['Green', 'Green', 'Green'], ['Green', 'Green', 'Blue'], ['Green', 'Blue', 'Blue'], ['Blue', 'Blue', 'Blue']]\n    \"\"\"\n    return [list(combo) for combo in combinations_with_replacement(l, n)]\n",
        "from itertools import combinations_with_replacement\n\ndef combinations_colors(l, n):\n    return list(map(tuple, combinations_with_replacement(l, n)))\n",
        "from itertools import combinations_with_replacement\n\ndef combinations_colors(l, n):\n    return list(combinations_with_replacement(l, n))\n",
        "from itertools import combinations_with_replacement\n\ndef combinations_colors(l, n):\n    return list(combinations_with_replacement(l, n))\n",
        "from itertools import combinations_with_replacement\n\ndef combinations_colors(l, n):\n    return list(combinations_with_replacement(l, n))\n"
    ],
    "MbppEval/256": [
        "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    \n    is_prime = [True] * (n+1)\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n+1, i):\n                is_prime[j] = False\n    \n    return sum(is_prime)\n",
        "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n\n    Examples:\n    count_Primes_nums(5) == 2\n    count_Primes_nums(10) == 4\n    count_Primes_nums(100) == 25\n    \"\"\"\n    if n < 2:\n        return 0\n\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n\n    return sum(is_prime)\n",
        "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n\n    Examples:\n    count_Primes_nums(5) == 2\n    count_Primes_nums(10) == 4\n    count_Primes_nums(100) == 25\n    \"\"\"\n    if n < 2:\n        return 0\n    \n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count\n\ndef is_prime(x):\n    \"\"\"\n    Helper function to check if a number is prime.\n    \"\"\"\n    if x < 2:\n        return False\n    for i in range(2, int(x ** 0.5) + 1):\n        if x % i == 0:\n            return False\n    return True\n",
        "import math\n\ndef count_Primes_nums(n):\n    if n < 2:\n        return 0\n\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n\n    return sum(is_prime)\n",
        "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n + 1, i):\n                is_prime[j] = False\n\n    return sum(is_prime)\n"
    ],
    "MbppEval/257": [
        "def swap_numbers(a, b):\n    return (b, a)\n",
        "def swap_numbers(a, b):\n    return (b, a)\n",
        "def swap_numbers(a, b):\n    return (b, a)\n",
        "def swap_numbers(a, b):\n    return b, a\n",
        "def swap_numbers(a, b):\n    return (b, a)\n"
    ],
    "MbppEval/259": [
        "def maximize_elements(test_tup1, test_tup2):\n    result = []\n    for t1, t2 in zip(test_tup1, test_tup2):\n        result.append((max(t1[0], t2[0]), max(t1[1], t2[1])))\n    return result\n",
        "def maximize_elements(test_tup1, test_tup2):\n    maximized_tuples = []\n    for t1, t2 in zip(test_tup1, test_tup2):\n        maximized_tuples.append((max(t1[0], t2[0]), max(t1[1], t2[1])))\n    return tuple(maximized_tuples)\n",
        "def maximize_elements(test_tup1, test_tup2):\n    maximized_tuples = []\n    for t1, t2 in zip(test_tup1, test_tup2):\n        maximized_tuples.append((max(t1[0], t2[0]), max(t1[1], t2[1])))\n    return tuple(maximized_tuples)\n",
        "def maximize_elements(test_tup1, test_tup2):\n    result = []\n    for a, b in zip(test_tup1, test_tup2):\n        result.append((max(a[0], b[0]), max(a[1], b[1])))\n    return tuple(result)\n",
        "def maximize_elements(test_tup1, test_tup2):\n    result = []\n    for tup1, tup2 in zip(test_tup1, test_tup2):\n        if tup1[1] >= tup2[1]:\n            result.append(tup1)\n        else:\n            result.append(tup2)\n    return tuple(result)\n"
    ],
    "MbppEval/260": [
        "def newman_prime(n):\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if is_prime(num) and is_increasing_digits(num):\n            primes.append(num)\n        num += 1\n    return primes[-1]\n\ndef is_increasing_digits(n):\n    digits = [int(d) for d in str(n)]\n    for i in range(1, len(digits)):\n        if digits[i] <= digits[i-1]:\n            return False\n    return True\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n",
        "def newman_prime(n):\n    \"\"\"\n    Finds the nth Newman-Shanks-Williams prime number.\n    \"\"\"\n    if n == 1:\n        return 2\n    \n    newman_primes = [2]\n    p = 3\n    while len(newman_primes) < n:\n        if is_prime(p) and is_prime(2 ** p - 1):\n            newman_primes.append(2 ** p - 1)\n        p += 2\n    \n    return newman_primes[n - 1]\n\ndef is_prime(n):\n    \"\"\"\n    Checks if a number is prime.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n",
        "def newman_prime(n):\n    \"\"\"\n    Find the nth Newman-Shanks-Williams prime number.\n    \n    Args:\n        n (int): The index of the Newman-Shanks-Williams prime number to find.\n    \n    Returns:\n        int: The nth Newman-Shanks-Williams prime number.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    primes = []\n    i = 1\n    while len(primes) < n:\n        candidate = 2 ** i - 1\n        if all(candidate % p != 0 for p in primes):\n            primes.append(candidate)\n        i += 1\n    \n    return primes[n - 1]\n",
        "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_newman_shanks_williams_prime(n):\n    if not is_prime(n):\n        return False\n    i = 0\n    while True:\n        if n == 2 ** i + 1:\n            return True\n        if 2 ** i + 1 > n:\n            return False\n        i += 1\n\ndef newman_prime(n):\n    count = 0\n    i = 2\n    while True:\n        if is_newman_shanks_williams_prime(i):\n            count += 1\n            if count == n:\n                return i\n        i += 1\n",
        "def newman_prime(n):\n    \"\"\"\n    Find the nth Newman-Shanks-Williams prime number.\n    \"\"\"\n    if n == 1:\n        return 3\n    if n == 2:\n        return 5\n    \n    a = 3\n    b = 5\n    for _ in range(n-2):\n        a, b = b, a + b\n    \n    return b\n"
    ],
    "MbppEval/261": [
        "def division_elements(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    result = ()\n    for i in range(len(test_tup1)):\n        result += (test_tup1[i] / test_tup2[i],)\n\n    return result\n",
        "def division_elements(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length.\")\n    \n    result = []\n    for i in range(len(test_tup1)):\n        try:\n            result.append(test_tup1[i] / test_tup2[i])\n        except ZeroDivisionError:\n            result.append(0)\n    \n    return tuple(result)\n",
        "def division_elements(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    result = []\n    for i in range(len(test_tup1)):\n        division = test_tup1[i] / test_tup2[i]\n        result.append(division)\n\n    return tuple(result)\n",
        "def division_elements(test_tup1, test_tup2):\n    results = []\n    for i in range(len(test_tup1)):\n        result = test_tup1[i] / test_tup2[i]\n        results.append(result)\n    return tuple(results)\n",
        "def division_elements(test_tup1, test_tup2):\n    \"\"\"\n    Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n\n    Examples:\n    division_elements((10, 4, 6, 9),(5, 2, 3, 3)) == (2, 2, 2, 3)\n    division_elements((12, 6, 8, 16),(6, 3, 4, 4)) == (2, 2, 2, 4)\n    division_elements((20, 14, 36, 18),(5, 7, 6, 9)) == (4, 2, 6, 2)\n    \"\"\"\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    result = []\n    for i in range(len(test_tup1)):\n        try:\n            result.append(test_tup1[i] / test_tup2[i])\n        except ZeroDivisionError:\n            raise ZeroDivisionError(f\"Division by zero at index {i}\")\n\n    return tuple(result)\n"
    ],
    "MbppEval/262": [
        "def split_two_parts(list1, L):\n    first_part = []\n    second_part = []\n    for i, item in enumerate(list1):\n        if i < L:\n            first_part.append(item)\n        else:\n            second_part.append(item)\n    return (first_part, second_part)\n",
        "def split_two_parts(list1, L):\n    first_part = list1[:L]\n    second_part = list1[L:]\n    return (first_part, second_part)\n",
        "def split_two_parts(list1, L):\n    first_part = list1[:L]\n    second_part = list1[L:]\n    return (first_part, second_part)\n",
        "def split_two_parts(list1, L):\n    first_part = list1[:L]\n    second_part = list1[L:]\n    return (first_part, second_part)\n",
        "def split_two_parts(list1, L):\n    first_part = list1[:L]\n    second_part = list1[L:]\n    return (first_part, second_part)\n"
    ],
    "MbppEval/264": [
        "def dog_age(h_age):\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years.\n\n    Examples:\n    dog_age(12) == 61\n    dog_age(15) == 73\n    dog_age(24) == 109\n    \"\"\"\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4\n",
        "def dog_age(h_age):\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years.\n\n    Examples:\n    dog_age(12) == 61\n    dog_age(15) == 73\n    dog_age(24) == 109\n    \"\"\"\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4\n",
        "def dog_age(h_age):\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years.\n\n    Examples:\n    dog_age(12) == 61\n    dog_age(15) == 73\n    dog_age(24) == 109\n    \"\"\"\n    if h_age <= 2:\n        return h_age * 10\n    else:\n        return 16 + (h_age - 2) * 4\n",
        "def dog_age(h_age):\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return (2 * 10.5) + ((h_age - 2) * 4)\n",
        "def dog_age(h_age):\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years.\n\n    Examples:\n    dog_age(12) == 61\n    dog_age(15) == 73\n    dog_age(24) == 109\n    \"\"\"\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4\n"
    ],
    "MbppEval/265": [
        "def list_split(S, step):\n    result = []\n    temp = []\n    for i in range(len(S)):\n        if i > 0 and i % step == 0:\n            result.append(temp)\n            temp = []\n        temp.append(S[i])\n    result.append(temp)\n    return result\n",
        "def list_split(S, step):\n    result = [[] for _ in range(step)]\n    for i, item in enumerate(S):\n        result[i % step].append(item)\n    return result\n",
        "def list_split(S, step):\n    result = []\n    for i in range(0, len(S), step):\n        result.append(S[i::step])\n    return result\n",
        "def list_split(S, step):\n    result = []\n    for i in range(0, len(S), step):\n        sub_list = [S[j] for j in range(i, len(S), step)]\n        result.append(sub_list)\n    return result\n",
        "def list_split(S, step):\n    result = []\n    for i in range(0, len(S), step):\n        sub_list = [S[j] for j in range(i, len(S), step)]\n        result.append(sub_list)\n    return result\n"
    ],
    "MbppEval/266": [
        "def lateralsurface_cube(l):\n    return 4 * l * l\n",
        "def lateralsurface_cube(side_length):\n    \"\"\"\n    Calculates the lateral surface area of a cube given its side length.\n\n    Args:\n        side_length (float): The length of one side of the cube.\n\n    Returns:\n        float: The lateral surface area of the cube.\n    \"\"\"\n    return 4 * side_length * side_length\n",
        "def lateralsurface_cube(l):\n    return 4 * l ** 2\n",
        "def lateralsurface_cube(l):\n    return 4 * l ** 2\n",
        "def lateralsurface_cube(l):\n    return 4 * l**2\n"
    ],
    "MbppEval/267": [
        "def square_Sum(n):\n    return n * (n + 1) * (2 * n + 1) // 6\n",
        "def square_Sum(n):\n    total = 0\n    for i in range(1, n+1):\n        total += (2 * i - 1) ** 2\n    return total\n",
        "def square_Sum(n):\n    total = 0\n    i = 1\n    for _ in range(n):\n        total += i**2\n        i += 2\n    return total\n",
        "def square_Sum(n):\n    total_sum = 0\n    for i in range(1, 2*n, 2):\n        total_sum += i**2\n    return total_sum\n",
        "def square_Sum(n):\n    sum = 0\n    for i in range(1, 2*n, 2):\n        sum += i**2\n    return sum\n"
    ],
    "MbppEval/268": [
        "def find_star_num(n):\n    \"\"\"\n    Write a function to find the n'th star number.\n    \n    Examples:\n    find_star_num(3) == 37\n    find_star_num(4) == 73\n    find_star_num(5) == 121\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return find_star_num(n-1) + 2*n - 1\n",
        "def find_star_num(n):\n    \"\"\"\n    Write a function to find the n'th star number.\n\n    Examples:\n    find_star_num(3) == 37\n    find_star_num(4) == 73\n    find_star_num(5) == 121\n    \"\"\"\n    result = 0\n    for i in range(1, n+1):\n        result += (i * (i + 1)) // 2\n    return result\n",
        "def find_star_num(n):\n    \"\"\"\n    Write a function to find the n'th star number.\n\n    Examples:\n    find_star_num(3) == 37\n    find_star_num(4) == 73\n    find_star_num(5) == 121\n    \"\"\"\n    if n == 1:\n        return 1\n    \n    star_num = 1\n    for i in range(2, n+1):\n        star_num += i\n    \n    return star_num\n",
        "def find_star_num(n):\n    return n**2 + (n-1)**2\n",
        "def find_star_num(n):\n    total = 0\n    for i in range(1, 2*n, 2):\n        total += i\n    return total\n"
    ],
    "MbppEval/269": [
        "def ascii_value(k):\n    return ord(k)\n",
        "def ascii_value(k):\n    return ord(k)\n",
        "def ascii_value(k):\n    \"\"\"\n    Write a function to find the ASCII value of a character.\n\n    Examples:\n    ascii_value('A') == 65\n    ascii_value('R') == 82\n    ascii_value('S') == 83\n    \"\"\"\n    return ord(k)\n",
        "def ascii_value(k):\n    return ord(k)\n",
        "def ascii_value(k):\n    return ord(k)\n"
    ],
    "MbppEval/270": [
        "def sum_even_and_even_index(arr):\n    even_at_even_index = [num for i, num in enumerate(arr) if i % 2 == 0 and num % 2 == 0]\n    return sum(even_at_even_index)\n",
        "def sum_even_and_even_index(arr):\n    sum = 0\n    for i, num in enumerate(arr):\n        if num % 2 == 0 and i % 2 == 0:\n            sum += num\n    return sum\n",
        "def sum_even_and_even_index(arr):\n    even_sum = 0\n    for i in range(0, len(arr), 2):\n        if arr[i] % 2 == 0:\n            even_sum += arr[i]\n    return even_sum\n",
        "def sum_even_and_even_index(arr):\n    total = 0\n    for i, num in enumerate(arr):\n        if i % 2 == 0 and num % 2 == 0:\n            total += num\n    return total\n",
        "def sum_even_and_even_index(arr):\n    sum_even = 0\n    for i in range(0, len(arr), 2):\n        if arr[i] % 2 == 0:\n            sum_even += arr[i]\n    return sum_even\n"
    ],
    "MbppEval/271": [
        "def even_Power_Sum(n):\n    return 2 ** 5 * (n * (n + 1) * (2 * n + 1) * (3 * n ** 2 + 3 * n - 1) / 30)\n",
        "def even_Power_Sum(n):\n    total_sum = 0\n    for i in range(1, n+1):\n        total_sum += (2 * i) ** 5\n    return total_sum\n",
        "def even_Power_Sum(n):\n    return (2 * n * (2 * n + 1) * (2 * n + 2) * (2 * n + 3) * (2 * n + 4)) // 5",
        "def even_Power_Sum(n):\n    total_sum = 0\n    for i in range(1, n+1):\n        even_num = 2 * i\n        even_num_power_5 = even_num ** 5\n        total_sum += even_num_power_5\n    return total_sum\n",
        "def even_Power_Sum(n):\n    total_sum = 0\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            total_sum += i ** 5\n    return total_sum\n"
    ],
    "MbppEval/272": [
        "def rear_extract(test_list):\n    rear_elements = [tup[-1] for tup in test_list]\n    return rear_elements\n",
        "def rear_extract(test_list):\n    result = [tup[-1] for tup in test_list]\n    return result\n",
        "def rear_extract(test_list):\n    return [tup[-1] for tup in test_list]\n",
        "def rear_extract(test_list):\n    output = []\n    for tup in test_list:\n        output.append(tup[-1])\n    return output\n",
        "def rear_extract(test_list):\n    result = [tup[-1] for tup in test_list]\n    return result\n"
    ],
    "MbppEval/273": [
        "def substract_elements(test_tup1, test_tup2):\n    result = []\n    for a, b in zip(test_tup1, test_tup2):\n        result.append(a - b)\n    return tuple(result)\n",
        "def subtract_elements(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        return \"Error: Input tuples must have the same length.\"\n    \n    result = []\n    for i in range(len(test_tup1)):\n        result.append(test_tup1[i] - test_tup2[i])\n    \n    return tuple(result)\n",
        "def subtract_elements(test_tup1, test_tup2):\n    return tuple(a - b for a, b in zip(test_tup1, test_tup2))\n",
        "def subtract_elements(test_tup1, test_tup2):\n    \"\"\"\n    Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n\n    Examples:\n    subtract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)\n    subtract_elements((11, 2, 3), (24, 45, 16)) == (-13, -43, -13)\n    subtract_elements((7, 18, 9), (10, 11, 12)) == (-3, 7, -3)\n    \"\"\"\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    result = tuple(a - b for a, b in zip(test_tup1, test_tup2))\n    return result\n",
        "def substract_elements(test_tup1, test_tup2):\n    result = []\n    for i in range(len(test_tup1)):\n        result.append(test_tup1[i] - test_tup2[i])\n    return tuple(result)\n"
    ],
    "MbppEval/274": [
        "import math\n\ndef even_binomial_Coeff_Sum(n):\n    result = 0\n    for i in range(0, n+1, 2):\n        result += math.comb(n, i)\n    return result\n",
        "import math\n\ndef even_binomial_Coeff_Sum(n):\n    sum_even = 0\n    for i in range(0, n+1, 2):\n        sum_even += math.comb(n, i)\n    return sum_even\n",
        "import math\n\ndef even_binomial_Coeff_Sum(n):\n    sum_even = 0\n    for i in range(0, n+1, 2):\n        sum_even += math.comb(n, i)\n    return sum_even\n",
        "import math\n\ndef even_binomial_Coeff_Sum(n):\n    total_sum = 0\n    for k in range(0, n+1, 2):\n        binomial_coeff = math.comb(n, k)\n        total_sum += binomial_coeff\n    return total_sum\n",
        "import math\n\ndef even_binomial_Coeff_Sum(n):\n    sum = 0\n    for i in range(n+1):\n        if i % 2 == 0:\n            sum += math.comb(n, i)\n    return sum\n"
    ],
    "MbppEval/276": [
        "import math\n\ndef volume_cylinder(r, h):\n    volume = math.pi * r**2 * h\n    return volume\n",
        "import math\n\ndef volume_cylinder(r, h):\n    volume = math.pi * r**2 * h\n    return volume\n",
        "import math\n\ndef volume_cylinder(r, h):\n    volume = math.pi * (r ** 2) * h\n    return volume\n",
        "import math\n\ndef volume_cylinder(r, h):\n    return math.pi * r**2 * h\n",
        "import math\n\ndef volume_cylinder(r, h):\n    return math.pi * r**2 * h\n"
    ],
    "MbppEval/277": [
        "def dict_filter(d, n):\n    return {k: v for k, v in d.items() if v >= n}\n",
        "def dict_filter(dict_in, n):\n    new_dict = {}\n    for key, value in dict_in.items():\n        if value >= n:\n            new_dict[key] = value\n    return new_dict\n",
        "def dict_filter(d, n):\n    return {k: v for k, v in d.items() if v >= n}\n",
        "def dict_filter(d, n):\n    filtered_dict = {}\n    for key, value in d.items():\n        if value >= n:\n            filtered_dict[key] = value\n    return filtered_dict\n",
        "def dict_filter(dict_to_filter, n):\n    filtered_dict = {}\n    for key, value in dict_to_filter.items():\n        if value >= n:\n            filtered_dict[key] = value\n    return filtered_dict\n"
    ],
    "MbppEval/278": [
        "def count_first_elements(test_tup):\n    count = 0\n    for element in test_tup:\n        if isinstance(element, tuple):\n            return count\n        count += 1\n    return count\n",
        "def count_first_elements(test_tup):\n    for i, element in enumerate(test_tup):\n        if isinstance(element, tuple):\n            return i\n    return 0\n",
        "def count_first_elements(test_tup):\n    for i, element in enumerate(test_tup):\n        if isinstance(element, tuple):\n            return i\n    return 0\n",
        "def count_first_elements(test_tup):\n    count = 0\n    for element in test_tup:\n        if isinstance(element, tuple):\n            return count\n        count += 1\n    return count\n",
        "def count_first_elements(test_tup):\n    \"\"\"\n    Write a function to find the number of elements that occurs before the tuple element in the given tuple.\n\n    Examples:\n    count_first_elements((1, 5, 7, (4, 6), 10)) == 3\n    count_first_elements((2, 9, (5, 7), 11)) == 2\n    count_first_elements((11, 15, 5, 8, (2, 3), 8)) == 4\n    \"\"\"\n    for i, elem in enumerate(test_tup):\n        if isinstance(elem, tuple):\n            return i\n    return len(test_tup)\n"
    ],
    "MbppEval/279": [
        "def is_num_decagonal(n):\n    return n * (3 * n - 2)\n",
        "def is_num_decagonal(n):\n    return n * (3 * n - 2)\n",
        "def get_nth_decagonal(n):\n    return n * (3 * n - 2)\n",
        "def is_num_decagonal(n):\n    return n * (3 * n - 2)\n",
        "def is_num_decagonal(n):\n    \"\"\"\n    Finds the nth decagonal number.\n    \n    Args:\n        n (int): The position of the decagonal number to find.\n    \n    Returns:\n        int: The nth decagonal number.\n    \"\"\"\n    return n * (3 * n - 2)\n"
    ],
    "MbppEval/280": [
        "def sequential_search(dlist, item):\n    found = False\n    index = -1\n    \n    for i, elem in enumerate(dlist):\n        if elem == item:\n            found = True\n            index = i\n            break\n    \n    return (found, index)\n",
        "def sequential_search(dlist, item):\n    found = False\n    index = -1\n    \n    for i, element in enumerate(dlist):\n        if element == item:\n            found = True\n            index = i\n            break\n    \n    return (found, index)\n",
        "def sequential_search(dlist, item):\n    found = False\n    index = -1\n    \n    for i, elem in enumerate(dlist):\n        if elem == item:\n            found = True\n            index = i\n            break\n    \n    return (found, index)\n",
        "def sequential_search(dlist, item):\n    found = False\n    index = -1\n    \n    for i, element in enumerate(dlist):\n        if element == item:\n            found = True\n            index = i\n            break\n    \n    return (found, index)\n",
        "def sequential_search(dlist, item):\n    found = False\n    index = -1\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            found = True\n            index = i\n            break\n    return (found, index)\n"
    ],
    "MbppEval/281": [
        "def all_unique(test_list):\n    return len(test_list) == len(set(test_list))\n",
        "def all_unique(test_list):\n    unique_set = set(test_list)\n    return len(test_list) == len(unique_set)\n",
        "def all_unique(test_list):\n    \"\"\"\n    Write a python function to check if the elements of a given list are unique or not.\n\n    Examples:\n    all_unique([1,2,3]) == True\n    all_unique([1,2,1,2]) == False\n    all_unique([1,2,3,4,5]) == True\n    \"\"\"\n    unique_elements = set()\n    for item in test_list:\n        unique_elements.add(item)\n    return len(unique_elements) == len(test_list)\n",
        "def all_unique(test_list):\n    unique_set = set(test_list)\n    return len(unique_set) == len(test_list)\n",
        "def all_unique(test_list):\n    unique_set = set(test_list)\n    return len(unique_set) == len(test_list)\n"
    ],
    "MbppEval/282": [
        "def sub_list(nums1, nums2):\n    if not isinstance(nums1, list) or not isinstance(nums2, list):\n        raise TypeError(\"Both inputs must be lists\")\n    \n    if len(nums1) != len(nums2):\n        raise ValueError(\"Lists must have the same length\")\n    \n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] - nums2[i])\n    \n    return result\n",
        "def sub_list(nums1, nums2):\n    if len(nums1) != len(nums2):\n        return []\n\n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] - nums2[i])\n\n    return result\n",
        "def sub_list(nums1, nums2):\n    if len(nums1) != len(nums2):\n        return \"Error: The input lists must have the same length.\"\n\n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] - nums2[i])\n\n    return result\n",
        "def sub_list(nums1, nums2):\n    if len(nums1) != len(nums2):\n        return []\n    \n    result = [x - y for x, y in zip(nums1, nums2)]\n    return result\n",
        "def sub_list(nums1, nums2):\n    result = []\n    for i in range(min(len(nums1), len(nums2))):\n        result.append(nums1[i] - nums2[i])\n    return result\n"
    ],
    "MbppEval/283": [
        "def validate(n):\n    \"\"\"\n    Write a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\n\n    Examples:\n    validate(1234) == True\n    validate(51241) == False\n    validate(321) == True\n    \"\"\"\n    # Initialize a list to store the counts of each digit (0-9)\n    digit_counts = [0] * 10\n    \n    # Extract the digits and update the counts\n    while n > 0:\n        digit = n % 10\n        digit_counts[digit] += 1\n        n //= 10\n    \n    # Check if the count of each digit is less than or equal to the digit itself\n    for i in range(10):\n        if digit_counts[i] > i:\n            return False\n    \n    return True\n",
        "def validate(n):\n    str_n = str(n)\n    digit_count = {}\n\n    for digit in str_n:\n        digit_count[digit] = digit_count.get(digit, 0) + 1\n\n    for digit, count in digit_count.items():\n        if count > int(digit):\n            return False\n\n    return True\n",
        "def validate(n):\n    num_str = str(n)\n    freq_dict = {}\n\n    for digit in num_str:\n        if digit in freq_dict:\n            freq_dict[digit] += 1\n        else:\n            freq_dict[digit] = 1\n\n    for digit, count in freq_dict.items():\n        if count > int(digit):\n            return False\n\n    return True\n",
        "def validate(n):\n    freq_dict = {}\n    str_n = str(n)\n    \n    for char in str_n:\n        digit = int(char)\n        if digit not in freq_dict:\n            freq_dict[digit] = 1\n        else:\n            freq_dict[digit] += 1\n    \n    for digit, count in freq_dict.items():\n        if count > digit:\n            return False\n    \n    return True\n",
        "def validate(n):\n    \"\"\"\n    Write a python function that takes in an integer and checks whether the frequency of each digit in the integer is less than or equal to the digit itself.\n    \n    Examples:\n    validate(1234) == True\n    validate(51241) == False\n    validate(321) == True\n    \"\"\"\n    digit_count = {}\n    \n    while n > 0:\n        digit = n % 10\n        if digit in digit_count:\n            digit_count[digit] += 1\n        else:\n            digit_count[digit] = 1\n        n //= 10\n    \n    for digit, count in digit_count.items():\n        if count > digit:\n            return False\n    \n    return True\n"
    ],
    "MbppEval/284": [
        "def check_element(lst, element):\n    return all(item == element for item in lst)\n",
        "def check_element(lst, element):\n    all_equal = True\n    for item in lst:\n        if item != element:\n            all_equal = False\n            break\n    return all_equal\n",
        "def check_element(lst, element):\n    all_equal = True\n    for item in lst:\n        if item != element:\n            all_equal = False\n            break\n    return all_equal\n",
        "def check_element(lst, element):\n    all_equal = True\n    for item in lst:\n        if item != element:\n            all_equal = False\n            break\n    return all_equal\n",
        "def check_element(list, element):\n    all_equal = True\n    for item in list:\n        if item != element:\n            all_equal = False\n            break\n    return all_equal\n"
    ],
    "MbppEval/285": [
        "import re\n\ndef text_match_two_three(text):\n    if re.search(r'ab{2,3}', text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_two_three(text):\n    pattern = r'ab{2,3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_two_three(text):\n    pattern = r'ab{2,3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_two_three(text):\n    pattern = r'ab{2,3}$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_two_three(text):\n    pattern = r'a(bb|bbb)'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n"
    ],
    "MbppEval/286": [
        "def max_sub_array_sum_repeated(a, n, k):\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for _ in range(k):\n        current_sum = 0\n        for x in a:\n            current_sum += x\n            max_sum = max(max_sum, current_sum)\n            if current_sum < 0:\n                current_sum = 0\n\n    return max_sum\n",
        "def max_sub_array_sum_repeated(a, n, k):\n    max_sum = float('-inf')\n    total_sum = sum(a)\n    \n    # Compute the maximum sum of a contiguous subarray in the original array\n    curr_sum = 0\n    for num in a:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    repeated_sum = 0\n    for i in range(k-1):\n        repeated_sum += total_sum\n        max_sum = max(max_sum, repeated_sum)\n    \n    return max_sum\n",
        "def max_sub_array_sum_repeated(a, n, k):\n    max_subarray_sum = float('-inf')\n    total_sum = 0\n    \n    # Calculate the total sum of the original array\n    for num in a:\n        total_sum += num\n    \n    # Find the maximum subarray sum in the original array\n    curr_sum = 0\n    for num in a:\n        curr_sum = max(num, curr_sum + num)\n        max_subarray_sum = max(max_subarray_sum, curr_sum)\n    \n    # Calculate the maximum subarray sum in the repeated array\n    if total_sum >= 0:\n        return max_subarray_sum * k\n    else:\n        return max(max_subarray_sum, max_subarray_sum + (k - 1) * total_sum)\n",
        "def max_sub_array_sum_repeated(a, n, k):\n    max_sum = float('-inf')\n    current_sum = 0\n    min_sum = 0\n    total_sum = 0\n\n    for _ in range(k):\n        current_sum = max(current_sum + a[i], a[i])\n        max_sum = max(max_sum, current_sum)\n        min_sum = min(min_sum, current_sum)\n        total_sum += a[i]\n        i = (i + 1) % n\n\n    # If all elements are negative, return the maximum element\n    if max_sum < 0:\n        return max_sum\n\n    return max(max_sum, total_sum - min_sum)\n",
        "def max_sub_array_sum_repeated(a, n, k):\n    # Step 1: Use Kadane's algorithm to find the maximum subarray sum in the original array\n    max_subarray_sum = float('-inf')\n    current_sum = 0\n    for num in a:\n        current_sum = max(num, current_sum + num)\n        max_subarray_sum = max(max_subarray_sum, current_sum)\n\n    # Step 2: Calculate the total sum of the array\n    total_sum = sum(a)\n\n    # Step 3: If the maximum subarray sum is negative, return the maximum subarray sum\n    if max_subarray_sum < 0:\n        return max_subarray_sum\n\n    # Step 4: Calculate the maximum subarray sum in the repeated array\n    return max_subarray_sum + (total_sum * (k - 1))\n"
    ],
    "MbppEval/287": [
        "def square_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2 * i) ** 2\n    return sum\n",
        "def square_Sum(n):\n    return n * (2 * n + 1) * (2 * n - 1) // 3\n",
        "def square_Sum(n):\n    total_sum = 0\n    for i in range(1, n+1):\n        even_num = 2 * i\n        squared_num = even_num ** 2\n        total_sum += squared_num\n    return total_sum\n",
        "def square_Sum(n):\n    \"\"\"\n    Write a python function that takes in an integer n and returns the sum of squares of first n even natural numbers.\n\n    Examples:\n    square_Sum(2) == 20\n    square_Sum(3) == 56\n    square_Sum(4) == 120\n    \"\"\"\n    total_sum = 0\n    for i in range(1, n+1):\n        even_num = 2 * i\n        total_sum += even_num ** 2\n    return total_sum\n",
        "def square_Sum(n):\n    sum_of_squares = 0\n    for i in range(1, n+1):\n        even_number = i * 2\n        sum_of_squares += even_number ** 2\n    return sum_of_squares\n"
    ],
    "MbppEval/290": [
        "def max_length(list1):\n    max_len = 0\n    max_list = None\n\n    for l in list1:\n        if len(l) > max_len:\n            max_len = len(l)\n            max_list = l\n\n    return (max_len, max_list)\n",
        "def max_length(list1):\n    max_len = 0\n    max_list = []\n\n    for sub_list in list1:\n        if len(sub_list) > max_len:\n            max_len = len(sub_list)\n            max_list = sub_list\n\n    return (max_len, max_list)\n",
        "def max_length(list1):\n    max_len = 0\n    max_list = None\n\n    for inner_list in list1:\n        if len(inner_list) > max_len:\n            max_len = len(inner_list)\n            max_list = inner_list\n\n    return (max_len, max_list)\n",
        "def max_length(list1):\n    max_length = 0\n    max_list = []\n\n    for inner_list in list1:\n        if len(inner_list) > max_length:\n            max_length = len(inner_list)\n            max_list = inner_list\n\n    return (max_length, max_list)\n",
        "def max_length(list1):\n    \"\"\"\n    Write a function to find the list of maximum length in a list of lists.\n\n    Examples:\n    max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    max_length([[1], [5, 7], [10, 12, 14,15]]) == (4, [10, 12, 14,15])\n    max_length([[5], [15,20,25]]) == (3, [15,20,25])\n    \"\"\"\n    max_list = max(list1, key=len)\n    return (len(max_list), max_list)\n"
    ],
    "MbppEval/291": [
        "def count_no_of_ways(n, k):\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    \n    same = k\n    diff = k * (k - 1)\n    \n    for i in range(3, n + 1):\n        same, diff = diff, (k - 1) * (same + diff)\n    \n    return same + diff\n",
        "def count_no_of_ways(n, k):\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    \n    same = k\n    diff = k * (k-1)\n    total = same + diff\n    \n    for i in range(3, n+1):\n        same, diff = diff, (same + diff) * (k-1)\n        total = same + diff\n    \n    return total\n",
        "def count_no_of_ways(n, k):\n    if n == 1:\n        return k\n    \n    same = k\n    different = k * (k - 1)\n    \n    for i in range(3, n+1):\n        new_same = different\n        new_different = (same + different) * (k - 1)\n        same = new_same\n        different = new_different\n    \n    return same + different\n",
        "def count_no_of_ways(n, k):\n    if n == 1:\n        return k\n    \n    same = k\n    diff = k * (k-1)\n    \n    for i in range(3, n+1):\n        same, diff = diff, (same + diff) * (k-1)\n    \n    return same + diff\n",
        "def count_no_of_ways(n, k):\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    same = k\n    diff = k * (k - 1)\n\n    for i in range(3, n + 1):\n        temp = same\n        same = diff\n        diff = (temp + diff) * (k - 1)\n\n    return same + diff\n"
    ],
    "MbppEval/292": [
        "def find(n, m):\n    return n // m\n",
        "def find(n, m):\n    return n // m\n",
        "def find(n, m):\n    return n // m\n",
        "def find(n, m):\n    return n // m\n",
        "def find(n, m):\n    return n // m\n"
    ],
    "MbppEval/293": [
        "import math\n\ndef otherside_rightangle(w, h):\n    c = math.sqrt(w**2 + h**2)\n    return c\n",
        "import math\n\ndef otherside_rightangle(w, h):\n    return math.sqrt(w**2 + h**2)\n",
        "import math\n\ndef otherside_rightangle(w, h):\n    return math.sqrt(w**2 + h**2)\n",
        "import math\n\ndef otherside_rightangle(w, h):\n    return math.sqrt(w ** 2 + h ** 2)\n",
        "import math\n\ndef otherside_rightangle(w, h):\n    c = math.sqrt(w**2 + h**2)\n    return c\n"
    ],
    "MbppEval/294": [
        "def max_val(listval):\n    max_val = float('-inf')\n    for element in listval:\n        if isinstance(element, (int, float)):\n            max_val = max(max_val, element)\n    return max_val\n",
        "def max_val(listval):\n    max_value = float('-inf')\n    \n    for element in listval:\n        if isinstance(element, (int, float)):\n            max_value = max(max_value, element)\n    \n    return max_value\n",
        "def max_val(listval):\n    \"\"\"\n    Write a function to find the maximum value in a given heterogeneous list.\n\n    Examples:\n    max_val(['Python', 3, 2, 4, 5, 'version']) == 5\n    max_val(['Python', 15, 20, 25]) == 25\n    max_val(['Python', 30, 20, 40, 50, 'version']) == 50\n    \"\"\"\n    if not listval:\n        return None\n\n    max_value = float('-inf')\n    for item in listval:\n        if isinstance(item, (int, float)):\n            max_value = max(max_value, item)\n\n    return max_value\n",
        "def max_val(listval):\n    \"\"\"\n    Write a function to find the maximum value in a given heterogeneous list.\n\n    Examples:\n    max_val(['Python', 3, 2, 4, 5, 'version']) == 5\n    max_val(['Python', 15, 20, 25]) == 25\n    max_val(['Python', 30, 20, 40, 50, 'version']) == 50\n    \"\"\"\n    max_value = float('-inf')\n    \n    for item in listval:\n        if isinstance(item, (int, float)):\n            max_value = max(max_value, item)\n    \n    return max_value\n",
        "def max_val(listval):\n    \"\"\"\n    Write a function to find the maximum value in a given heterogeneous list.\n\n    Examples:\n    max_val(['Python', 3, 2, 4, 5, 'version']) == 5\n    max_val(['Python', 15, 20, 25]) == 25\n    max_val(['Python', 30, 20, 40, 50, 'version']) == 50\n    \"\"\"\n    if not isinstance(listval, list):\n        raise TypeError(\"Input must be a list\")\n\n    max_value = float('-inf')\n    for item in listval:\n        if isinstance(item, (int, float)):\n            max_value = max(max_value, item)\n\n    return max_value\n"
    ],
    "MbppEval/295": [
        "import math\n\ndef sum_div(number):\n    sum_of_divisors = 0\n    for i in range(1, int(math.sqrt(number)) + 1):\n        if number % i == 0:\n            sum_of_divisors += i\n            if i != number // i:\n                sum_of_divisors += number // i\n    if math.sqrt(number).is_integer():\n        sum_of_divisors -= int(math.sqrt(number))\n    return sum_of_divisors\n",
        "def sum_div(number):\n    divisors = []\n    for i in range(1, number + 1):\n        if number % i == 0:\n            divisors.append(i)\n    return sum(divisors)\n",
        "def sum_div(number):\n    divisors_sum = 0\n    for i in range(1, number+1):\n        if number % i == 0:\n            divisors_sum += i\n    return divisors_sum\n",
        "def sum_div(number):\n    result = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            result += i\n    return result\n",
        "def sum_div(number):\n    total = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            total += i\n    return total\n"
    ],
    "MbppEval/296": [
        "def merge_sort(arr, n):\n    if n == 1:\n        return arr, 0\n    \n    mid = n // 2\n    left, left_inv = merge_sort(arr[:mid], mid)\n    right, right_inv = merge_sort(arr[mid:], n - mid)\n    \n    merged = []\n    i, j = 0, 0\n    inversions = left_inv + right_inv\n    \n    while i < mid and j < n - mid:\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inversions += mid - i\n    \n    merged += left[i:]\n    merged += right[j:]\n    \n    return merged, inversions\n\ndef get_Inv_Count(arr, n):\n    _, inversions = merge_sort(arr, n)\n    return inversions\n",
        "def get_Inv_Count(arr):\n    return merge_sort(arr, 0, len(arr) - 1)\n\ndef merge_sort(arr, left, right):\n    if left < right:\n        mid = (left + right) // 2\n        left_count = merge_sort(arr, left, mid)\n        right_count = merge_sort(arr, mid + 1, right)\n        return left_count + right_count + merge(arr, left, mid, right)\n    return 0\n\ndef merge(arr, left, mid, right):\n    i = left\n    j = mid + 1\n    count = 0\n    temp = [0] * (right - left + 1)\n    k = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp[k] = arr[i]\n            i += 1\n        else:\n            temp[k] = arr[j]\n            count += mid - i + 1\n            j += 1\n        k += 1\n\n    while i <= mid:\n        temp[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp[i - left]\n\n    return count\n",
        "def get_Inv_Count(arr):\n    return merge_sort(arr, len(arr))\n\ndef merge_sort(arr, n):\n    if n == 1:\n        return 0\n\n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left_inversions = merge_sort(left, mid)\n    right_inversions = merge_sort(right, n - mid)\n\n    i = j = 0\n    inversions = 0\n    for k in range(n):\n        if i < mid and (j >= n - mid or left[i] <= right[j]):\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inversions += mid - i\n\n    return left_inversions + right_inversions + inversions\n",
        "def merge_and_count(left, right):\n    i = j = inv_count = 0\n    merged = []\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n    merged += left[i:]\n    merged += right[j:]\n    return merged, inv_count\n\ndef get_Inv_Count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr) // 2\n    left, left_inv_count = get_Inv_Count(arr[:mid])\n    right, right_inv_count = get_Inv_Count(arr[mid:])\n    merged, merge_inv_count = merge_and_count(left, right)\n    return merged, left_inv_count + right_inv_count + merge_inv_count\n",
        "def merge_and_count(arr, n):\n    if n <= 1:\n        return 0\n\n    mid = n // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    left_count = merge_and_count(left, mid)\n    right_count = merge_and_count(right, n - mid)\n\n    i = j = 0\n    inv_count = 0\n    for k in range(n):\n        if i < mid and (j >= n - mid or left[i] <= right[j]):\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inv_count += (mid - i)\n\n    return left_count + right_count + inv_count\n\ndef get_Inv_Count(arr, n):\n    return merge_and_count(arr, n)\n"
    ],
    "MbppEval/297": [
        "def flatten_list(list1):\n    flattened = []\n\n    for item in list1:\n        if isinstance(item, list):\n            flattened.extend(flatten_list(item))\n        else:\n            flattened.append(item)\n\n    return flattened\n",
        "def flatten_list(list1):\n    flattened = []\n    \n    for item in list1:\n        if isinstance(item, list):\n            flattened.extend(flatten_list(item))\n        else:\n            flattened.append(item)\n    \n    return flattened\n",
        "def flatten_list(list1):\n    flattened_list = []\n    \n    for item in list1:\n        if isinstance(item, list):\n            flattened_list.extend(flatten_list(item))\n        else:\n            flattened_list.append(item)\n    \n    return flattened_list\n",
        "def flatten_list(list1):\n    flattened_list = []\n\n    for element in list1:\n        if isinstance(element, list):\n            flattened_list.extend(flatten_list(element))\n        else:\n            flattened_list.append(element)\n\n    return flattened_list\n",
        "def flatten_list(list1):\n    flattened = []\n    \n    for element in list1:\n        if isinstance(element, list):\n            flattened.extend(flatten_list(element))\n        else:\n            flattened.append(element)\n    \n    return flattened\n"
    ],
    "MbppEval/299": [
        "from collections import defaultdict\n\ndef max_aggregate(stdata):\n    aggregates = defaultdict(int)\n    for name, score in stdata:\n        aggregates[name] += score\n    return max(aggregates.items(), key=lambda x: x[1])\n",
        "from collections import defaultdict\n\ndef max_aggregate(stdata):\n    agg_scores = defaultdict(int)\n    for name, score in stdata:\n        agg_scores[name] += score\n    max_person, max_score = max(agg_scores.items(), key=lambda x: x[1])\n    return (max_person, max_score)\n",
        "from collections import defaultdict\n\ndef max_aggregate(stdata):\n    aggregates = defaultdict(int)\n    for name, score in stdata:\n        aggregates[name] += score\n    return max(aggregates.items(), key=lambda x: x[1])\n",
        "from collections import defaultdict\n\ndef max_aggregate(stdata):\n    aggregates = defaultdict(int)\n\n    for name, score in stdata:\n        aggregates[name] += score\n\n    max_name, max_score = max(aggregates.items(), key=lambda x: x[1])\n    return (max_name, max_score)\n",
        "from collections import defaultdict\n\ndef max_aggregate(stdata):\n    aggregates = defaultdict(int)\n\n    for name, value in stdata:\n        aggregates[name] += value\n\n    return max(aggregates.items(), key=lambda x: x[1])\n"
    ],
    "MbppEval/300": [
        "from math import factorial\n\ndef count_binary_seq(n):\n    return factorial(2 * n) // (factorial(n) * factorial(n))\n",
        "def count_binary_seq(n):\n    \"\"\"\n    Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.\n\n    Examples:\n    count_binary_seq(1) == 2.0\n    count_binary_seq(2) == 6.0\n    count_binary_seq(3) == 20.0\n    \"\"\"\n    if n == 1:\n        return 2.0\n\n    count = 0\n    for i in range(2 ** (2 * n)):\n        binary_seq = format(i, f\"0{2 * n}b\")\n        first_half = int(binary_seq[:n], 2)\n        second_half = int(binary_seq[n:], 2)\n        if first_half == second_half:\n            count += 1\n\n    return count\n",
        "def count_binary_seq(n):\n    if n == 1:\n        return 2.0\n    else:\n        return 2 * (count_binary_seq(n-1)) / 2\n",
        "def count_binary_seq(n):\n    if n == 0:\n        return 1.0\n    \n    total = 0\n    for i in range(2 ** n):\n        first_half = bin(i)[2:].zfill(n)\n        second_half = bin((2 ** n) - 1 - i)[2:].zfill(n)\n        if sum(int(bit) for bit in first_half) == sum(int(bit) for bit in second_half):\n            total += 1\n    return total\n",
        "from math import comb\n\ndef count_binary_seq(n):\n    return 2 ** n * comb(2 * n, n)\n"
    ],
    "MbppEval/301": [
        "def dict_depth(d):\n    \"\"\"\n    Write a function to find the depth of a dictionary.\n\n    Examples:\n    dict_depth({'a':1, 'b': {'c': {'d': {}}}}) == 4\n    dict_depth({'a':1, 'b': {'c':'python'}}) == 2\n    dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}}) == 3\n    \"\"\"\n    return _dict_depth(d, 1)\n\ndef _dict_depth(d, depth):\n    if not d:\n        return depth\n    \n    max_depth = depth\n    for value in d.values():\n        if isinstance(value, dict):\n            max_depth = max(max_depth, _dict_depth(value, depth + 1))\n    \n    return max_depth\n",
        "def dict_depth(d):\n    \"\"\"\n    Write a function to find the depth of a dictionary.\n\n    Examples:\n    dict_depth({'a':1, 'b': {'c': {'d': {}}}}) == 4\n    dict_depth({'a':1, 'b': {'c':'python'}}) == 2\n    dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}}) == 3\n    \"\"\"\n    if not d:\n        return 0\n    return 1 + (max(map(dict_depth, d.values())) if any(isinstance(v, dict) for v in d.values()) else 0)\n",
        "def dict_depth(d):\n    \"\"\"\n    Write a function to find the depth of a dictionary.\n\n    Examples:\n    dict_depth({'a':1, 'b': {'c': {'d': {}}}}) == 4\n    dict_depth({'a':1, 'b': {'c':'python'}}) == 2\n    dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}}) == 3\n    \"\"\"\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0\n",
        "def dict_depth(d):\n    \"\"\"\n    Write a function to find the depth of a dictionary.\n\n    Examples:\n    dict_depth({'a':1, 'b': {'c': {'d': {}}}}) == 4\n    dict_depth({'a':1, 'b': {'c':'python'}}) == 2\n    dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}}) == 3\n    \"\"\"\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0\n",
        "def dict_depth(d):\n    \"\"\"\n    Write a function to find the depth of a dictionary.\n\n    Examples:\n    dict_depth({'a':1, 'b': {'c': {'d': {}}}}) == 4\n    dict_depth({'a':1, 'b': {'c':'python'}}) == 2\n    dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}}) == 3\n    \"\"\"\n\n    def get_depth(d):\n        if not d:\n            return 1\n        return 1 + (max(map(get_depth, d.values())) if d else 0)\n\n    return get_depth(d)\n"
    ],
    "MbppEval/304": [
        "def find_Element(arr, ranges, rotations, index):\n    for i in range(rotations):\n        for start, end in ranges:\n            arr = arr[start:] + arr[:start]\n    return arr[index]\n",
        "def find_Element(arr, ranges, rotations, index):\n    for start, end in ranges:\n        arr = rotate_array(arr[start:end+1], rotations) + arr[:start] + arr[end+1:]\n    return arr[index]\n\ndef rotate_array(arr, k):\n    return arr[-k:] + arr[:-k]\n",
        "def find_Element(arr, ranges, rotations, index):\n    for start, end in ranges:\n        arr[start:end] = arr[start+rotations:end] + arr[start:start+rotations]\n    return arr[index]\n",
        "def find_Element(arr, ranges, rotations, index):\n    for i in range(rotations):\n        for start, end in ranges:\n            arr[start:end+1] = arr[start:end+1][-1:] + arr[start:end+1][:-1]\n    return arr[index]\n",
        "def find_Element(arr, ranges, rotations, index):\n    current_arr = arr.copy()\n\n    for start, end in ranges:\n        current_arr[start:end+1] = current_arr[start:end+1][rotations:] + current_arr[start:end+1][:rotations]\n\n    return current_arr[index]\n"
    ],
    "MbppEval/305": [
        "import re\n\ndef start_withp(words):\n    p_words = []\n    for word in words:\n        if re.match(r'^p', word, re.IGNORECASE):\n            p_words.append(word)\n    return tuple(p_words[:2])\n",
        "import re\n\ndef start_withp(words):\n    p_words = [word for word in words if re.match(r'^p', word, re.IGNORECASE)]\n    return tuple(p_words[:2])\n",
        "import re\n\ndef start_withp(words):\n    result = []\n    for word in words:\n        if re.match(r'^p', word, re.IGNORECASE):\n            result.append(word)\n            if len(result) == 2:\n                break\n    return tuple(result)\n",
        "import re\n\ndef start_withp(words):\n    p_words = []\n    P_words = []\n    \n    for word in words:\n        if re.match(r'^p', word, re.IGNORECASE):\n            if word.startswith('p'):\n                p_words.append(word)\n            else:\n                P_words.append(word)\n    \n    return (p_words[0], P_words[0]) if p_words and P_words else ()\n",
        "import re\n\ndef start_withp(words):\n    word_list = words.split()\n    p_words = [word for word in word_list if re.match(r'^p', word, re.IGNORECASE)]\n    return tuple(p_words[:2])\n"
    ],
    "MbppEval/306": [
        "def max_sum_increasing_subseq(a, n, index, k):\n    dp = [0] * (n + 1)\n    \n    for i in range(n):\n        if i < k - 1:\n            dp[i + 1] = max(dp[i] + a[i], dp[i + 1])\n        else:\n            dp[i + 1] = max(dp[k - 1] + a[i], dp[i + 1])\n    \n    return dp[n]\n",
        "def max_sum_increasing_subseq(a, n, index, k):\n    dp = [0] * n\n    max_sum = 0\n\n    # Base case\n    if index == 0:\n        return a[0]\n\n    # Iterate through the array\n    for i in range(n):\n        # Find the maximum sum of increasing subsequence up to index i\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n\n        # Update the max_sum if i is less than k\n        if i < k:\n            max_sum = max(max_sum, dp[i])\n\n    return max_sum\n",
        "def max_sum_increasing_subseq(a, n, index, k):\n    dp = [0] * n\n    dp[0] = a[0]\n\n    for i in range(1, index + 1):\n        if a[i] > a[i-1]:\n            dp[i] = dp[i-1] + a[i]\n        else:\n            dp[i] = dp[i-1]\n\n    for i in range(index + 1, k + 1):\n        dp[i] = max(dp[i], dp[index] + a[i])\n\n    return dp[k]\n",
        "def max_sum_increasing_subseq(a, n, index, k):\n    dp = [0] * n\n    \n    # Initialize the first element\n    dp[0] = a[0]\n    \n    # Iterate through the array\n    for i in range(1, n):\n        # Find the maximum sum of the increasing subsequence up to i, including any element after i up to the kth element\n        if i <= index:\n            dp[i] = max(dp[i-1], a[i])\n        elif a[i] < a[k]:\n            dp[k] = max(dp[k], dp[i-1] + a[i])\n        else:\n            dp[i] = dp[i-1]\n    \n    # Return the maximum value in the dp array\n    return dp[k]\n",
        "def max_sum_increasing_subseq(a, n, i, k):\n    dp = [0] * n\n    \n    # Initialize dp[i] to a[i]\n    for i in range(n):\n        dp[i] = a[i]\n    \n    # Find the maximum sum of increasing subsequence up to index i\n    for j in range(i):\n        if a[j] < a[i]:\n            dp[i] = max(dp[i], dp[j] + a[i])\n    \n    # Find the maximum sum of increasing subsequence that includes the k-th element\n    for j in range(i+1, k):\n        if a[j] < a[k]:\n            dp[k] = max(dp[k], dp[j] + a[k])\n    \n    return dp[k]\n"
    ],
    "MbppEval/307": [
        "from copy import deepcopy\n\ndef colon_tuplex(tuplex, m, n):\n    modified_tuple = deepcopy(tuplex)\n    if isinstance(modified_tuple[m], list):\n        modified_tuple[m] = [n]\n    else:\n        modified_tuple = tuple(modified_tuple[:m] + (modified_tuple[m],) + modified_tuple[m+1:])\n    return modified_tuple\n",
        "def colon_tuplex(tuplex, n):\n    return tuplex[:2] + ([n],) + tuplex[3:]\n",
        "from copy import deepcopy\n\ndef colon_tuplex(tuplex, m, n):\n    new_tuple = deepcopy(tuplex)\n    if isinstance(new_tuple[m], list):\n        new_tuple[m] = [n]\n    return new_tuple\n",
        "from copy import deepcopy\n\ndef colon_tuplex(tuplex, m, n):\n    if m < 0 or m >= len(tuplex):\n        raise IndexError(\"Index out of range\")\n    \n    new_tuple = deepcopy(tuplex)\n    element_at_m = new_tuple[m]\n    \n    if isinstance(element_at_m, list):\n        new_tuple = new_tuple[:m] + (element_at_m[:n] + [n] + element_at_m[n+1:],) + new_tuple[m+1:]\n    else:\n        new_tuple = new_tuple[:m] + ([n],) + new_tuple[m+1:]\n    \n    return new_tuple\n",
        "from copy import deepcopy\n\ndef colon_tuplex(tuplex, m, n):\n    new_tuplex = deepcopy(tuplex)\n    new_tuplex[m][0] = n\n    return new_tuplex\n"
    ],
    "MbppEval/308": [
        "import heapq\n\ndef large_product(nums1, nums2, N):\n    largest_products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            product = num1 * num2\n            if len(largest_products) < N or product > largest_products[0]:\n                heapq.heappush(largest_products, product)\n                if len(largest_products) > N:\n                    heapq.heappop(largest_products)\n    return sorted(largest_products, reverse=True)\n",
        "def large_product(nums1, nums2, N):\n    products = [num1 * num2 for num1 in nums1 for num2 in nums2]\n    products.sort(reverse=True)\n    return products[:N]\n",
        "def large_product(nums1, nums2, N):\n    largest_products = []\n\n    for num1 in nums1:\n        for num2 in nums2:\n            product = num1 * num2\n            if len(largest_products) < N:\n                largest_products.append(product)\n            else:\n                min_product = min(largest_products)\n                if product > min_product:\n                    largest_products.remove(min_product)\n                    largest_products.append(product)\n\n    largest_products.sort(reverse=True)\n    return largest_products[:N]\n",
        "def large_product(nums1, nums2, N):\n    largest_products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            product = num1 * num2\n            if len(largest_products) < N or product > largest_products[0]:\n                largest_products.append(product)\n                largest_products.sort(reverse=True)\n                if len(largest_products) > N:\n                    largest_products.pop(0)\n    return largest_products[:N]\n",
        "def large_product(nums1, nums2, N):\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    largest_products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            product = num1 * num2\n            largest_products.append(product)\n            if len(largest_products) == N:\n                break\n        if len(largest_products) == N:\n            break\n    largest_products = sorted(largest_products, reverse=True)[:N]\n    return largest_products\n"
    ],
    "MbppEval/309": [
        "def maximum(a, b):\n    \"\"\"\n    Write a python function to find the maximum of two numbers.\n\n    Examples:\n    maximum(5, 10) == 10\n    maximum(-1, -2) == -1\n    maximum(9, 7) == 9\n    \"\"\"\n    if a >= b:\n        return a\n    else:\n        return b\n",
        "def maximum(a, b):\n    \"\"\"\n    Write a python function to find the maximum of two numbers.\n\n    Examples:\n    maximum(5, 10) == 10\n    maximum(-1, -2) == -1\n    maximum(9, 7) == 9\n    \"\"\"\n    if a >= b:\n        return a\n    else:\n        return b\n",
        "def maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b\n",
        "def maximum(a, b):\n    \"\"\"\n    Write a python function to find the maximum of two numbers.\n\n    Examples:\n    maximum(5, 10) == 10\n    maximum(-1, -2) == -1\n    maximum(9, 7) == 9\n    \"\"\"\n    if a > b:\n        return a\n    else:\n        return b\n",
        "def maximum(a, b):\n    if a >= b:\n        return a\n    else:\n        return b\n"
    ],
    "MbppEval/310": [
        "def string_to_tuple(str1):\n    \"\"\"\n    Write a function to convert a given string to a tuple of characters.\n\n    Examples:\n    string_to_tuple(\"python 3.0\") == ('p', 'y', 't', 'h', 'o', 'n', ' ', '3', '.', '0')\n    string_to_tuple(\"item1\") == ('i', 't', 'e', 'm', '1')\n    string_to_tuple(\"15.10\") == ('1', '5', '.', '1', '0')\n    \"\"\"\n    return tuple(char for char in str1)\n",
        "def string_to_tuple(str1):\n    return tuple(str1)\n",
        "def string_to_tuple(str1):\n    result = tuple(str1)\n    return result\n",
        "def string_to_tuple(str1):\n    return tuple(str1)\n",
        "def string_to_tuple(str1):\n    return tuple(str1)\n"
    ],
    "MbppEval/311": [
        "def set_left_most_unset_bit(n):\n    two_complement = -n - 1\n    return n | two_complement\n",
        "def set_left_most_unset_bit(n):\n    binary_str = bin(n)[2:]\n    leftmost_unset_bit_pos = 0\n    for i, bit in enumerate(binary_str):\n        if bit == '0':\n            leftmost_unset_bit_pos = len(binary_str) - i\n            break\n    result = n | (1 << (leftmost_unset_bit_pos - 1))\n    return result\n",
        "def set_left_most_unset_bit(n):\n    \"\"\"\n    Set the leftmost unset bit in the given integer n.\n    \"\"\"\n    # Find the rightmost set bit\n    rightmost_set_bit = n & -n\n    \n    # Shift the rightmost set bit all the way to the left\n    leftmost_unset_bit = rightmost_set_bit << 1\n    \n    # Set the leftmost unset bit\n    return n | leftmost_unset_bit\n",
        "def set_left_most_unset_bit(n):\n    leftmost_one = n & (-n)\n    return n | leftmost_one\n",
        "def set_left_most_unset_bit(n):\n    position = n.bit_length()\n    mask = (1 << position) - 1\n    return n | mask\n"
    ],
    "MbppEval/312": [
        "import math\n\ndef volume_cone(r, h):\n    \"\"\"\n    Write a function to find the volume of a cone.\n\n    Examples:\n    volume_cone(5, 12) == 314.15926535897927\n    volume_cone(10, 15) == 1570.7963267948965\n    volume_cone(19, 17) == 6426.651371693521\n    \"\"\"\n    volume = (1/3) * math.pi * r**2 * h\n    return volume\n",
        "import math\n\ndef volume_cone(r, h):\n    \"\"\"\n    Write a function to find the volume of a cone.\n\n    Examples:\n    volume_cone(5, 12) == 314.1592653589793\n    volume_cone(10, 15) == 1570.7963267948966\n    volume_cone(19, 17) == 6426.651371693521\n    \"\"\"\n    return (1/3) * math.pi * r**2 * h\n",
        "import math\n\ndef volume_cone(r, h):\n    \"\"\"\n    Write a function to find the volume of a cone.\n\n    Examples:\n    volume_cone(5, 12) == 314.15926535897927\n    volume_cone(10, 15) == 1570.7963267948965\n    volume_cone(19, 17) == 6426.651371693521\n    \"\"\"\n    return (1/3) * math.pi * r**2 * h\n",
        "import math\n\ndef volume_cone(r, h):\n    return (1/3) * math.pi * r**2 * h\n",
        "import math\n\ndef volume_cone(r, h):\n    \"\"\"\n    Write a function to find the volume of a cone.\n\n    Examples:\n    volume_cone(5, 12) == 314.15926535897927\n    volume_cone(10, 15) == 1570.7963267948965\n    volume_cone(19, 17) == 6426.651371693521\n    \"\"\"\n    volume = (1/3) * math.pi * r**2 * h\n    return volume\n"
    ],
    "MbppEval/388": [
        "def highest_Power_of_2(n):\n    power = 0\n    while n >= 2:\n        n //= 2\n        power += 1\n    return 2 ** power\n",
        "def highest_Power_of_2(n):\n    power_of_2 = 1\n    while power_of_2 <= n:\n        power_of_2 <<= 1\n    return power_of_2 >> 1\n",
        "def highest_Power_of_2(n):\n    power_of_2 = 1\n    while power_of_2 * 2 <= n:\n        power_of_2 *= 2\n    return power_of_2\n",
        "def highest_Power_of_2(n):\n    power_of_2 = 1\n    while power_of_2 <= n:\n        power_of_2 *= 2\n    return power_of_2 // 2\n",
        "def highest_Power_of_2(n):\n    power_of_2 = 1\n    while power_of_2 <= n:\n        power_of_2 *= 2\n    return power_of_2 // 2\n"
    ],
    "MbppEval/389": [
        "def find_lucas(n):\n    \"\"\"\n    Write a function to find the n'th lucas number.\n\n    Examples:\n    find_lucas(9) == 76\n    find_lucas(4) == 7\n    find_lucas(3) == 4\n    \"\"\"\n    lucas_numbers = [2, 1]  # Initialize the list with the first two Lucas numbers\n\n    if n < 2:\n        return lucas_numbers[n]\n\n    # Calculate and store the remaining Lucas numbers\n    for i in range(2, n + 1):\n        next_lucas = lucas_numbers[i - 1] + lucas_numbers[i - 2]\n        lucas_numbers.append(next_lucas)\n\n    return lucas_numbers[n]\n",
        "def find_lucas(n):\n    \"\"\"\n    Write a function to find the n'th lucas number.\n\n    Examples:\n    find_lucas(9) == 76\n    find_lucas(4) == 7\n    find_lucas(3) == 4\n    \"\"\"\n    if n == 1:\n        return 2\n    elif n == 2:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(3, n+1):\n            a, b = b, a + b\n        return b\n",
        "def find_lucas(n):\n    \"\"\"\n    Write a function to find the n'th Lucas number.\n\n    Examples:\n    find_lucas(9) == 76\n    find_lucas(4) == 7\n    find_lucas(3) == 4\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for i in range(2, n+1):\n            a, b = b, a + b\n        return b\n",
        "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for i in range(2, n+1):\n            a, b = b, a + b\n        return b\n",
        "def find_lucas(n):\n    \"\"\"\n    Find the n'th Lucas number.\n\n    Args:\n        n (int): The index of the Lucas number to find.\n\n    Returns:\n        int: The n'th Lucas number.\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for i in range(2, n + 1):\n            a, b = b, a + b\n        return a\n"
    ],
    "MbppEval/390": [
        "def add_string(list_, string):\n    result = []\n    for item in list_:\n        result.append(string.format(item))\n    return result\n",
        "def add_string(list_, string):\n    formatted_strings = []\n    for item in list_:\n        formatted_strings.append(string.format(item))\n    return formatted_strings\n",
        "def add_string(list_, string):\n    result = []\n    for element in list_:\n        formatted_string = string.format(element)\n        result.append(formatted_string)\n    return result\n",
        "def add_string(list_, string):\n    formatted_strings = []\n    for element in list_:\n        formatted_string = string.format(element)\n        formatted_strings.append(formatted_string)\n    return formatted_strings\n",
        "def add_string(list_, string):\n    modified_strings = []\n    for item in list_:\n        modified_strings.append(string.format(item))\n    return modified_strings\n"
    ],
    "MbppEval/391": [
        "def convert_list_dictionary(l1, l2, l3):\n    result = []\n    for key, name, value in zip(l1, l2, l3):\n        d = {key: {name: value}}\n        result.append(d)\n    return result\n",
        "def convert_list_dictionary(l1, l2, l3):\n    result = []\n    for item1, item2, item3 in zip(l1, l2, l3):\n        nested_dict = {item1: {item2: item3}}\n        result.append(nested_dict)\n    return result\n",
        "def convert_list_dictionary(l1, l2, l3):\n    result = []\n    for key, name, value in zip(l1, l2, l3):\n        result.append({key: {name: value}})\n    return result\n",
        "def convert_list_dictionary(l1, l2, l3):\n    result = []\n    for key, name, value in zip(l1, l2, l3):\n        result.append({key: {name: value}})\n    return result\n",
        "def convert_list_dictionary(l1, l2, l3):\n    if len(l1) != len(l2) or len(l1) != len(l3):\n        return \"Error: Input lists must have the same length.\"\n    \n    result = []\n    \n    for i in range(len(l1)):\n        d = {l1[i]: {l2[i]: l3[i]}}\n        result.append(d)\n    \n    return result\n"
    ],
    "MbppEval/392": [
        "def get_max_sum(n):\n    if n <= 1:\n        return n\n\n    memo = {1: 1, 2: 2}\n\n    for i in range(3, n + 1):\n        max_sum = i\n        for div in (2, 3, 4, 5):\n            if i % div == 0:\n                max_sum = max(max_sum, memo[i // div] + i // div)\n        memo[i] = max_sum\n\n    return memo[n]\n",
        "def get_max_sum(n):\n    return f(n)\n\ndef f(n):\n    if n <= 1:\n        return n\n    \n    return max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n",
        "def get_max_sum(n):\n    \"\"\"\n    Find the maximum sum possible by using the given equation f(n) = max((f(n//2) + f(n//3) + f(n//4) + f(n//5)), n).\n    \"\"\"\n    if n <= 1:\n        return n\n    if n <= 2:\n        return n\n    \n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n",
        "def f(n):\n    if n <= 1:\n        return n\n    \n    f_n_2 = f(n // 2)\n    f_n_3 = f(n // 3)\n    f_n_4 = f(n // 4)\n    f_n_5 = f(n // 5)\n    \n    return max(f_n_2 + f_n_3 + f_n_4 + f_n_5, n)\n\ndef get_max_sum(n):\n    return f(n)\n",
        "def get_max_sum(n):\n    if n <= 1:\n        return n\n\n    recursive_sum = get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5)\n    return max(recursive_sum, n)\n"
    ],
    "MbppEval/393": [
        "def max_length_list(input_list):\n    max_length = 0\n    max_list = []\n\n    for lst in input_list:\n        if len(lst) > max_length:\n            max_length = len(lst)\n            max_list = lst\n\n    return (max_length, max_list)\n",
        "def max_length_list(input_list):\n    max_length = 0\n    max_length_list = None\n\n    for lst in input_list:\n        length = len(lst)\n        if length > max_length:\n            max_length = length\n            max_length_list = lst\n\n    return max_length, max_length_list\n",
        "def max_length_list(input_list):\n    \"\"\"\n    Write a function to find the list with maximum length.\n\n    Examples:\n    max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])\n    max_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]]) == (5,[1,2,3,4,5])\n    max_length_list([[3,4,5],[6,7,8,9],[10,11,12]]) == (4,[6,7,8,9])\n    \"\"\"\n    if not isinstance(input_list, list) or not all(isinstance(inner_list, list) for inner_list in input_list):\n        raise ValueError(\"Input must be a list of lists\")\n\n    max_length = 0\n    max_list = []\n\n    for inner_list in input_list:\n        if len(inner_list) > max_length:\n            max_length = len(inner_list)\n            max_list = inner_list\n\n    return max_length, max_list\n",
        "def max_length_list(input_list):\n    max_length = 0\n    max_length_list = None\n\n    for lst in input_list:\n        if len(lst) > max_length:\n            max_length = len(lst)\n            max_length_list = lst\n\n    return max_length, max_length_list\n",
        "def max_length_list(input_list):\n    max_length = 0\n    max_list = None\n    \n    for lst in input_list:\n        if len(lst) > max_length:\n            max_length = len(lst)\n            max_list = lst\n    \n    return (max_length, max_list)\n"
    ],
    "MbppEval/394": [
        "def check_distinct(test_tup):\n    return len(test_tup) == len(set(test_tup))\n",
        "def check_distinct(test_tup):\n    return len(set(test_tup)) == len(test_tup)\n",
        "def check_distinct(test_tup):\n    return len(set(test_tup)) == len(test_tup)\n",
        "def check_distinct(test_tup):\n    return len(set(test_tup)) == len(test_tup)\n",
        "def check_distinct(test_tup):\n    return len(test_tup) == len(set(test_tup))\n"
    ],
    "MbppEval/395": [
        "def first_non_repeating_character(str1):\n    char_count = {}\n    \n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    return None\n",
        "def first_non_repeating_character(str1):\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    return None\n",
        "def first_non_repeating_character(str1):\n    \"\"\"\n    Write a python function to find the first non-repeated character in a given string.\n\n    Examples:\n    first_non_repeating_character(\"abcabc\") == None\n    first_non_repeating_character(\"abc\") == \"a\"\n    first_non_repeating_character(\"ababc\") == \"c\"\n    \"\"\"\n    char_count = {}\n    first_occurrence = {}\n\n    for i, char in enumerate(str1):\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n            first_occurrence[char] = i\n\n    for char, count in char_count.items():\n        if count == 1:\n            return str1[first_occurrence[char]]\n\n    return None\n",
        "def first_non_repeating_character(str1):\n    \"\"\"\n    Write a python function to find the first non-repeated character in a given string.\n\n    Examples:\n    first_non_repeating_character(\"abcabc\") == None\n    first_non_repeating_character(\"abc\") == \"a\"\n    first_non_repeating_character(\"ababc\") == \"c\"\n    \"\"\"\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n\n    return None\n",
        "def first_non_repeating_character(str1):\n    char_count = {}\n    \n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    return None\n"
    ],
    "MbppEval/396": [
        "import re\n\nregex = r'^[a-z]$|^([a-z]).*\\1$'\n\ndef check_char(string):\n    if re.match(regex, string):\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n",
        "import re\n\nregex = r'^[a-z]$|^([a-z]).*\\1$'\n\ndef check_char(string):\n    if re.match(regex, string):\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n",
        "import re\n\ndef check_char(string):\n    if re.match(r'^[a-z]$|^([a-z]).*\\1$', string):\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n",
        "import re\n\nregex = r'^[a-z]$|^([a-z]).*\\1$'\n\ndef check_char(string):\n    if re.match(regex, string):\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n",
        "import re\n\nregex = r'^[a-z]$|^([a-z]).*\\1$'\n\ndef check_char(string):\n    if re.match(regex, string):\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n"
    ],
    "MbppEval/397": [
        "def median_numbers(a, b, c):\n    numbers = [a, b, c]\n    numbers.sort()\n    return float(numbers[1])\n",
        "def median_numbers(a, b, c):\n    numbers = [a, b, c]\n    sorted_numbers = sorted(numbers)\n    median = sorted_numbers[1]\n    return float(median)\n",
        "def median_numbers(a, b, c):\n    numbers = [a, b, c]\n    numbers.sort()\n    return numbers[1]\n",
        "def median_numbers(a, b, c):\n    numbers = [a, b, c]\n    numbers.sort()\n    return numbers[1]\n",
        "def median_numbers(a, b, c):\n    min_num = min(a, b, c)\n    max_num = max(a, b, c)\n    middle_value = (a + b + c) - min_num - max_num\n    median = middle_value / 2\n    return median\n"
    ],
    "MbppEval/398": [
        "def sum_of_digits(nums):\n    total_sum = 0\n    for num in nums:\n        if isinstance(num, (int, float)):\n            for digit in str(abs(num)):\n                total_sum += int(digit)\n    return total_sum\n",
        "def sum_of_digits(nums):\n    total_sum = 0\n    for num in nums:\n        if isinstance(num, (int, float)):\n            num = abs(int(num))\n            while num > 0:\n                total_sum += num % 10\n                num //= 10\n    return total_sum\n",
        "def sum_of_digits(nums):\n    total_sum = 0\n    for num in nums:\n        for char in str(num):\n            if char.isdigit():\n                total_sum += int(char)\n    return total_sum\n",
        "def sum_of_digits(nums):\n    total_sum = 0\n    for item in nums:\n        if isinstance(item, (int, float)):\n            item = abs(item)\n            for digit in str(item):\n                total_sum += int(digit)\n        elif isinstance(item, list):\n            total_sum += sum_of_digits(item)\n    return total_sum\n",
        "def sum_of_digits(nums):\n    total = 0\n    for num in nums:\n        if isinstance(num, (int, float)):\n            num = abs(int(num))\n            while num > 0:\n                total += num % 10\n                num //= 10\n    return total\n"
    ],
    "MbppEval/399": [
        "def bitwise_xor(test_tup1, test_tup2):\n    result = []\n    for i in range(len(test_tup1)):\n        result.append(test_tup1[i] ^ test_tup2[i])\n    return tuple(result)\n",
        "def bitwise_xor(test_tup1, test_tup2):\n    result = tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n    return result\n",
        "def bitwise_xor(test_tup1, test_tup2):\n    \"\"\"\n    Write a function to perform the mathematical bitwise xor operation across the given tuples.\n\n    Examples:\n    bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)\n    bitwise_xor((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)\n    bitwise_xor((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)\n    \"\"\"\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length.\")\n    return tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n",
        "def bitwise_xor(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length\")\n    \n    result = []\n    for i in range(len(test_tup1)):\n        result.append(test_tup1[i] ^ test_tup2[i])\n    \n    return tuple(result)\n",
        "def bitwise_xor(test_tup1, test_tup2):\n    result = []\n    for a, b in zip(test_tup1, test_tup2):\n        result.append(a ^ b)\n    return tuple(result)\n"
    ],
    "MbppEval/400": [
        "def extract_freq(test_list):\n    unique_tuples = set(test_list)\n    return len(unique_tuples)\n",
        "def extract_freq(test_list):\n    \"\"\"\n    Write a function to extract the number of unique tuples in the given list.\n\n    Examples:\n    extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)]) == 3\n    extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)]) == 4\n    extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)]) == 4\n    \"\"\"\n    unique_tuples = set()\n    for tuple_item in test_list:\n        unique_tuples.add(tuple_item)\n    return len(unique_tuples)\n",
        "def extract_freq(test_list):\n    unique_tuples = set()\n    for tup in test_list:\n        unique_tuples.add(tup)\n    return len(unique_tuples)\n",
        "def extract_freq(test_list):\n    unique_tuples = set()\n    for tup in test_list:\n        unique_tuples.add(tup)\n    return len(unique_tuples)\n",
        "def extract_freq(test_list):\n    freq_dict = {}\n    for tup in test_list:\n        if tup not in freq_dict:\n            freq_dict[tup] = 1\n        else:\n            freq_dict[tup] += 1\n    return len(freq_dict)\n"
    ],
    "MbppEval/401": [
        "def add_nested_tuples(test_tup1, test_tup2):\n    result = []\n    for t1, t2 in zip(test_tup1, test_tup2):\n        new_tuple = (t1[0] + t2[0], t1[1] + t2[1])\n        result.append(new_tuple)\n    return tuple(result)\n",
        "def add_nested_tuples(test_tup1, test_tup2):\n    result = []\n    for tup1, tup2 in zip(test_tup1, test_tup2):\n        result.append(tuple(a + b for a, b in zip(tup1, tup2)))\n    return tuple(result)\n",
        "def add_nested_tuples(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same number of inner tuples.\")\n\n    result = []\n    for i in range(len(test_tup1)):\n        new_tuple = (test_tup1[i][0] + test_tup2[i][0], test_tup1[i][1] + test_tup2[i][1])\n        result.append(new_tuple)\n\n    return tuple(result)\n",
        "def add_nested_tuples(test_tup1, test_tup2):\n    result = []\n    for t1, t2 in zip(test_tup1, test_tup2):\n        new_tuple = (t1[0] + t2[0], t1[1] + t2[1])\n        result.append(new_tuple)\n    return tuple(result)\n",
        "def add_nested_tuples(test_tup1, test_tup2):\n    result = []\n    for t1, t2 in zip(test_tup1, test_tup2):\n        result.append((t1[0] + t2[0], t1[1] + t2[1]))\n    return tuple(result)\n"
    ],
    "MbppEval/404": [
        "def minimum(a, b):\n    \"\"\"\n    Write a python function to find the minimum of two numbers.\n\n    Examples:\n    minimum(1, 2) == 1\n    minimum(-5, -4) == -5\n    minimum(0, 0) == 0\n\n    Args:\n        a (int or float): The first number to compare.\n        b (int or float): The second number to compare.\n\n    Returns:\n        int or float: The minimum of the two input numbers.\n    \"\"\"\n    if a < b:\n        return a\n    else:\n        return b\n",
        "def minimum(a, b):\n    \"\"\"\n    Write a python function to find the minimum of two numbers.\n\n    Examples:\n    minimum(1, 2) == 1\n    minimum(-5, -4) == -5\n    minimum(0, 0) == 0\n    \"\"\"\n    if a <= b:\n        return a\n    else:\n        return b\n",
        "def minimum(a, b):\n    \"\"\"\n    Write a python function to find the minimum of two numbers.\n\n    Examples:\n    minimum(1, 2) == 1\n    minimum(-5, -4) == -5\n    minimum(0, 0) == 0\n    \"\"\"\n    return min(a, b)\n",
        "def minimum(a, b):\n    if a < b:\n        return a\n    else:\n        return b\n",
        "def minimum(a, b):\n    if a <= b:\n        return a\n    else:\n        return b\n"
    ],
    "MbppEval/405": [
        "def check_tuplex(tuplex, tuple1):\n    return tuple1 in tuplex\n",
        "def check_tuplex(tuplex, tuple1):\n    return tuple1 in tuplex\n",
        "def check_tuplex(tuplex, tuple1):\n    return tuple1 in tuplex\n",
        "def check_tuplex(tuplex, tuple1):\n    return tuple1 in tuplex\n",
        "def check_tuplex(tuplex, tuple1):\n    return tuple1 in tuplex\n"
    ],
    "MbppEval/406": [
        "def find_Parity(x):\n    if x & 1 == 1:\n        return \"Odd Parity\"\n    else:\n        return \"Even Parity\"\n",
        "def find_Parity(x):\n    if x & 1 == 1:\n        return \"Odd Parity\"\n    else:\n        return \"Even Parity\"\n",
        "def find_Parity(x):\n    \"\"\"\n    Write a python function to find whether the parity of a given number is odd.\n\n    Examples:\n    find_Parity(12) == \"Even Parity\"\n    find_Parity(7) == \"Odd Parity\"\n    find_Parity(10) == \"Even Parity\"\n    \"\"\"\n    x = int(x)\n    if x & 1 == 1:\n        return \"Odd Parity\"\n    else:\n        return \"Even Parity\"\n",
        "def find_Parity(x):\n    if x % 2 == 0:\n        return \"Even Parity\"\n    else:\n        return \"Odd Parity\"\n",
        "def find_Parity(x):\n    \"\"\"\n    Write a python function to find whether the parity of a given number is odd.\n\n    Examples:\n    find_Parity(12) == \"Even Parity\"\n    find_Parity(7) == \"Odd Parity\"\n    find_Parity(10) == \"Even Parity\"\n    \"\"\"\n    if x & 1 == 1:\n        return \"Odd Parity\"\n    else:\n        return \"Even Parity\"\n"
    ],
    "MbppEval/407": [
        "def rearrange_bigger(n):\n    digits = list(str(n))\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i+1]:\n        i -= 1\n    if i < 0:\n        return False\n    j = len(digits) - 1\n    while j > i and digits[j] <= digits[i]:\n        j -= 1\n    digits[i], digits[j] = digits[j], digits[i]\n    digits[i+1:] = digits[i+1:][::-1]\n    return int(''.join(digits))\n",
        "def rearrange_bigger(n):\n    digits = list(str(n))\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i+1]:\n        i -= 1\n    if i < 0:\n        return False\n    j = len(digits) - 1\n    while j > i and digits[j] <= digits[i]:\n        j -= 1\n    digits[i], digits[j] = digits[j], digits[i]\n    digits[i+1:] = digits[i+1:][::-1]\n    return int(''.join(digits))\n",
        "def rearrange_bigger(n):\n    \"\"\"\n    Write a function to create the next bigger number by rearranging the digits of a given number.\n    \n    Examples:\n    rearrange_bigger(12) == 21\n    rearrange_bigger(10) == False\n    rearrange_bigger(102) == 120\n    \"\"\"\n    digits = list(str(n))\n    \n    # Find the first digit from the right that is smaller than the digit to its right\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i+1]:\n        i -= 1\n    \n    if i < 0:\n        return False\n    \n    # Find the smallest digit to the right of the digit found in the previous step\n    # that is greater than it\n    j = len(digits) - 1\n    while j > i and digits[j] <= digits[i]:\n        j -= 1\n    \n    # Swap the two digits\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Reverse the digits to the right of the swapped digits\n    digits[i+1:] = digits[i+1:][::-1]\n    \n    return int(''.join(digits))\n",
        "def rearrange_bigger(n):\n    digits = list(str(n))\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i+1]:\n        i -= 1\n    if i < 0:\n        return False\n    j = len(digits) - 1\n    while j > i and digits[j] <= digits[i]:\n        j -= 1\n    digits[i], digits[j] = digits[j], digits[i]\n    digits[i+1:] = sorted(digits[i+1:])\n    return int(''.join(digits))\n",
        "def rearrange_bigger(n):\n    \"\"\"\n    Write a function to create the next bigger number by rearranging the digits of a given number.\n\n    Examples:\n    rearrange_bigger(12) == 21\n    rearrange_bigger(10) == False\n    rearrange_bigger(102) == 120\n    \"\"\"\n    digits = list(str(n))\n    \n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i+1]:\n        i -= 1\n    \n    if i < 0:\n        return False\n    \n    j = len(digits) - 1\n    while j > i and digits[j] <= digits[i]:\n        j -= 1\n    \n    digits[i], digits[j] = digits[j], digits[i]\n    digits[i+1:] = digits[i+1:][::-1]\n    \n    return int(''.join(digits))\n"
    ],
    "MbppEval/408": [
        "import heapq\n\ndef k_smallest_pairs(nums1, nums2, k):\n    if not nums1 or not nums2:\n        return []\n\n    min_heap = []\n    for x in nums1:\n        for y in nums2:\n            pair_sum = x + y\n            heapq.heappush(min_heap, (pair_sum, x, y))\n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n\n    return [[x, y] for _, x, y in min_heap]\n",
        "import heapq\n\ndef k_smallest_pairs(nums1, nums2, k):\n    result = []\n    heap = []\n\n    # Add the first pair to the min-heap\n    heapq.heappush(heap, (nums1[0] + nums2[0], 0, 0))\n\n    # Populate the result list\n    while len(result) < k and heap:\n        _, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n\n        if j < len(nums2) - 1:\n            heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))\n\n    return result\n",
        "import heapq\n\ndef k_smallest_pairs(nums1, nums2, k):\n    if not nums1 or not nums2:\n        return []\n\n    minheap = []\n    for num1 in nums1:\n        heapq.heappush(minheap, (num1 + nums2[0], num1, nums2[0]))\n\n    result = []\n    while k > 0 and minheap:\n        _, num1, num2 = heapq.heappop(minheap)\n        result.append([num1, num2])\n        k -= 1\n\n        if len(nums2) > 1:\n            heapq.heappush(minheap, (num1 + nums2[1], num1, nums2[1]))\n\n    return result\n",
        "def k_smallest_pairs(nums1, nums2, k):\n    pairs = []\n    for num1 in nums1:\n        for num2 in nums2:\n            pairs.append([num1, num2])\n    pairs.sort(key=lambda x: x[0] + x[1])\n    return pairs[:min(k, len(pairs))]\n",
        "import heapq\n\ndef k_smallest_pairs(nums1, nums2, k):\n    if not nums1 or not nums2:\n        return []\n\n    pq = [(nums1[0] + nums2[0], 0, 0)]  # (sum, i, j)\n    seen = set()\n    result = []\n\n    while len(result) < k and pq:\n        _, i, j = heapq.heappop(pq)\n        if (i, j) not in seen:\n            seen.add((i, j))\n            result.append([nums1[i], nums2[j]])\n\n            if i + 1 < len(nums1):\n                heapq.heappush(pq, (nums1[i + 1] + nums2[j], i + 1, j))\n            if j + 1 < len(nums2):\n                heapq.heappush(pq, (nums1[i] + nums2[j + 1], i, j + 1))\n\n    return result\n"
    ],
    "MbppEval/409": [
        "def min_product_tuple(list1):\n    min_product = float('inf')\n    for a, b in list1:\n        product = a * b\n        if product < min_product:\n            min_product = product\n    return min_product\n",
        "def min_product_tuple(list1):\n    min_product = float('inf')\n    \n    for a, b in list1:\n        product = a * b\n        if product < min_product:\n            min_product = product\n    \n    return min_product\n",
        "def min_product_tuple(list1):\n    min_product = float('inf')\n    for a, b in list1:\n        product = a * b\n        if product < min_product:\n            min_product = product\n    return min_product\n",
        "def min_product_tuple(list1):\n    min_product = float('inf')\n\n    for a, b in list1:\n        product = a * b\n        min_product = min(min_product, product)\n\n    return min_product\n",
        "def min_product_tuple(list1):\n    \"\"\"\n    Write a function to find the minimum product from the pairs of tuples within a given list.\n\n    Examples:\n    min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] ) == 8\n    min_product_tuple([(10,20), (15,2), (5,10)] ) == 30\n    min_product_tuple([(11,44), (10,15), (20,5), (12, 9)] ) == 100\n    \"\"\"\n    min_product = float('inf')\n    \n    for a, b in list1:\n        current_product = a * b\n        if current_product < min_product:\n            min_product = current_product\n    \n    return min_product\n"
    ],
    "MbppEval/410": [
        "def min_val(listval):\n    \"\"\"\n    Write a function to find the minimum value in a given heterogeneous list.\n\n    Examples:\n    min_val(['Python', 3, 2, 4, 5, 'version']) == 2\n    min_val(['Python', 15, 20, 25]) == 15\n    min_val(['Python', 30, 20, 40, 50, 'version']) == 20\n    \"\"\"\n    min_value = float('inf')  # Initialize min_value to the largest possible value\n    \n    for item in listval:\n        if isinstance(item, (int, float)):\n            min_value = min(min_value, item)\n    \n    return min_value\n",
        "def min_val(listval):\n    \"\"\"\n    Write a function to find the minimum value in a given heterogeneous list.\n\n    Examples:\n    min_val(['Python', 3, 2, 4, 5, 'version']) == 2\n    min_val(['Python', 15, 20, 25]) == 15\n    min_val(['Python', 30, 20, 40, 50, 'version']) == 20\n    \"\"\"\n    min_value = float('inf')\n\n    for item in listval:\n        if isinstance(item, (int, float)):\n            min_value = min(min_value, item)\n\n    return min_value\n",
        "def min_val(listval):\n    min_value = float('inf')\n    for element in listval:\n        if isinstance(element, (int, float)):\n            min_value = min(min_value, element)\n    return min_value\n",
        "def min_val(listval):\n    min_value = float('inf')\n    for item in listval:\n        if isinstance(item, (int, float)):\n            min_value = min(min_value, item)\n    return min_value\n",
        "def min_val(listval):\n    \"\"\"\n    Write a function to find the minimum value in a given heterogeneous list.\n\n    Examples:\n    min_val(['Python', 3, 2, 4, 5, 'version']) == 2\n    min_val(['Python', 15, 20, 25]) == 15\n    min_val(['Python', 30, 20, 40, 50, 'version']) == 20\n    \"\"\"\n    if not listval:\n        return None\n\n    min_value = listval[0]\n    for item in listval[1:]:\n        if isinstance(item, (int, float)):\n            min_value = min(min_value, item)\n\n    return min_value\n"
    ],
    "MbppEval/411": [
        "def snake_to_camel(word):\n    words = word.split('_')\n    camel_case_words = [words[0]] + [w.capitalize() for w in words[1:]]\n    camel_case = ''.join(camel_case_words)\n    return camel_case\n",
        "import re\n\ndef snake_to_camel(word):\n    result = \"\"\n    words = word.split(\"_\")\n    \n    # Convert the first word to start with uppercase\n    result += words[0].capitalize()\n    \n    # Convert the remaining words to start with uppercase\n    for w in words[1:]:\n        result += w.capitalize()\n    \n    return result\n",
        "def snake_to_camel(word):\n    camel_case = \"\"\n    words = word.split('_')\n    camel_case += words[0]\n    for w in words[1:]:\n        camel_case += w.capitalize()\n    return camel_case\n",
        "import re\n\ndef snake_to_camel(word):\n    words = word.split('_')\n    camel_case_words = [words[0]]\n    for w in words[1:]:\n        camel_case_words.append(w.capitalize())\n    camel_case = ''.join(camel_case_words)\n    return camel_case\n",
        "import re\n\ndef snake_to_camel(word):\n    words = word.split('_')\n    camel_case = [words[0]]\n    for w in words[1:]:\n        camel_case.append(w.capitalize())\n    return ''.join(camel_case)\n"
    ],
    "MbppEval/412": [
        "def remove_odd(l):\n    even_nums = []\n    for num in l:\n        if num % 2 == 0:\n            even_nums.append(num)\n    return even_nums\n",
        "def remove_odd(l):\n    even_list = []\n    for num in l:\n        if num % 2 == 0:\n            even_list.append(num)\n    return even_list\n",
        "def remove_odd(l):\n    new_list = []\n    for num in l:\n        if num % 2 == 0:\n            new_list.append(num)\n    return new_list\n",
        "def remove_odd(l):\n    even_list = []\n    for num in l:\n        if num % 2 == 0:\n            even_list.append(num)\n    return even_list\n",
        "def remove_odd(l):\n    new_list = []\n    for num in l:\n        if num % 2 == 0:\n            new_list.append(num)\n    return new_list\n"
    ],
    "MbppEval/413": [
        "def extract_nth_element(list1, n):\n    extracted_elements = []\n    for tup in list1:\n        extracted_elements.append(tup[n])\n    return extracted_elements\n",
        "def extract_nth_element(list1, n):\n    result = [item[n] for item in list1]\n    return result\n",
        "def extract_nth_element(list1, n):\n    return [item[n] for item in list1]\n",
        "def extract_nth_element(list1, n):\n    result = []\n    for tup in list1:\n        result.append(tup[n])\n    return result\n",
        "def extract_nth_element(list1, n):\n    result = []\n    for t in list1:\n        result.append(t[n])\n    return result\n"
    ],
    "MbppEval/414": [
        "def overlapping(list1, list2):\n    is_overlapping = False\n    for item in list1:\n        if item in list2:\n            is_overlapping = True\n            break\n    return is_overlapping\n",
        "def overlapping(list1, list2):\n    overlap = False\n    for item in list1:\n        if item in list2:\n            overlap = True\n            break\n    return overlap\n",
        "def overlapping(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    return len(set1.intersection(set2)) > 0\n",
        "def overlapping(list1, list2):\n    is_overlapping = False\n    for item in list1:\n        if item in list2:\n            is_overlapping = True\n            break\n    return is_overlapping\n",
        "def overlapping(list1, list2):\n    is_overlapping = False\n    for element in list1:\n        if element in list2:\n            is_overlapping = True\n            break\n    return is_overlapping\n"
    ],
    "MbppEval/415": [
        "def max_Product(arr):\n    if not arr:\n        return (None, None)\n    if len(arr) == 1:\n        return (arr[0], arr[0])\n\n    max1 = max(arr[0], arr[1])\n    max2 = min(arr[0], arr[1])\n    min1 = min(arr[0], arr[1])\n    min2 = max(arr[0], arr[1])\n\n    for i in range(2, len(arr)):\n        num = arr[i]\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n\n    if max1 * max2 >= min1 * min2:\n        return (max1, max2)\n    else:\n        return (min1, min2)\n",
        "def max_Product(arr):\n    max_product = float('-inf')\n    max_pair = None\n    \n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n                max_pair = (arr[i], arr[j])\n    \n    return max_pair\n",
        "def max_Product(arr):\n    if not arr:\n        return None\n    \n    max1 = float('-inf')\n    max2 = float('-inf')\n    min1 = float('inf')\n    min2 = float('inf')\n    \n    for num in arr:\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n        \n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n    \n    if min1 * min2 > max1 * max2:\n        return (min1, min2)\n    else:\n        return (max1, max2)\n",
        "def max_Product(arr):\n    \"\"\"\n    Write a python function to find a pair with highest product from a given array of integers.\n\n    Examples:\n    max_Product([1,2,3,4,7,0,8,4]) == (7,8)\n    max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)\n    max_Product([1,2,3]) == (2,3)\n    \"\"\"\n    if len(arr) < 2:\n        return None\n\n    max1 = max(arr[0], arr[1])\n    max2 = min(arr[0], arr[1])\n\n    for i in range(2, len(arr)):\n        if arr[i] > max1:\n            max2 = max1\n            max1 = arr[i]\n        elif arr[i] > max2:\n            max2 = arr[i]\n\n    return (max1, max2)\n",
        "def max_Product(arr):\n    if len(arr) < 2:\n        return None\n    \n    max1 = None\n    max2 = None\n    \n    for num in arr:\n        if max1 is None or num > max1:\n            max2 = max1\n            max1 = num\n        elif max2 is None or num > max2:\n            max2 = num\n    \n    return (max1, max2)\n"
    ],
    "MbppEval/417": [
        "def group_tuples(input_list):\n    result = {}\n    for tup in input_list:\n        first_element = tup[0]\n        if first_element in result:\n            result[first_element].append(tup[1])\n        else:\n            result[first_element] = [tup[1]]\n    \n    return [(*key, *value) for key, value in result.items()]\n",
        "def group_tuples(input_list):\n    result = {}\n    for tup in input_list:\n        first_element = tup[0]\n        if first_element not in result:\n            result[first_element] = [tup]\n        else:\n            result[first_element].append(tup)\n    return [tuple(v) for v in result.values()]\n",
        "def group_tuples(input_list):\n    result = {}\n    for tup in input_list:\n        first_element = tup[0]\n        if first_element in result:\n            result[first_element].append(tup[1])\n        else:\n            result[first_element] = [tup[1]]\n    return [(key, *value) for key, value in result.items()]\n",
        "def group_tuples(input_list):\n    grouped = {}\n    \n    for tup in input_list:\n        first_element = tup[0]\n        if first_element not in grouped:\n            grouped[first_element] = []\n        grouped[first_element].append(tup)\n    \n    return [tuple(group) for group in grouped.values()]\n",
        "def group_tuples(input_list):\n    result = {}\n    for tup in input_list:\n        first_element = tup[0]\n        if first_element not in result:\n            result[first_element] = [tup[1]]\n        else:\n            result[first_element].append(tup[1])\n    return [tuple([first] + list(rest)) for first, rest in result.items()]\n"
    ],
    "MbppEval/418": [
        "def Find_Max(lst):\n    max_length = 0\n    max_element = None\n\n    for element in lst:\n        if len(element) > max_length:\n            max_length = len(element)\n            max_element = element\n\n    return max_element\n",
        "def Find_Max(lst):\n    max_length = 0\n    max_element = None\n\n    for element in lst:\n        if len(element) > max_length:\n            max_length = len(element)\n            max_element = element\n\n    return max_element\n",
        "def Find_Max(lst):\n    max_length = 0\n    max_element = None\n    \n    for element in lst:\n        if len(element) > max_length:\n            max_length = len(element)\n            max_element = element\n    \n    return max_element\n",
        "def Find_Max(lst):\n    max_length = 0\n    max_element = None\n    \n    for element in lst:\n        if len(element) > max_length:\n            max_length = len(element)\n            max_element = element\n    \n    return max_element\n",
        "def Find_Max(lst):\n    max_length = 0\n    max_element = None\n\n    for sublst in lst:\n        if len(sublst) > max_length:\n            max_length = len(sublst)\n            max_element = sublst\n\n    return max_element\n"
    ],
    "MbppEval/419": [
        "def round_and_sum(list1):\n    rounded_list = [round(num) for num in list1]\n    total_sum = sum(rounded_list)\n    result = total_sum * len(list1)\n    return result\n",
        "def round_and_sum(list1):\n    rounded_numbers = [round(num) for num in list1]\n    total_sum = sum(rounded_numbers)\n    result = total_sum * len(list1)\n    return result\n",
        "def round_and_sum(list1):\n    total_sum = 0\n    for num in list1:\n        total_sum += round(num)\n    return total_sum * len(list1)\n",
        "def round_and_sum(list1):\n    total_sum = 0\n    for num in list1:\n        total_sum += round(num)\n    return total_sum * len(list1)\n",
        "def round_and_sum(list1):\n    rounded_list = [round(num) for num in list1]\n    total_sum = sum(rounded_list)\n    return total_sum * len(rounded_list)\n"
    ],
    "MbppEval/420": [
        "def cube_Sum(n):\n    total_sum = 0\n    for i in range(1, n+1):\n        even_number = 2 * i\n        cube = even_number ** 3\n        total_sum += cube\n    return total_sum\n",
        "def cube_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2 * i) ** 3\n    return sum\n",
        "def cube_Sum(n):\n    total = 0\n    for i in range(2, 2*n+1, 2):\n        total += i**3\n    return total\n",
        "def cube_Sum(n):\n    sum_cubes = 0\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            sum_cubes += i**3\n    return sum_cubes\n",
        "def cube_Sum(n):\n    return (n * (n+1))**2 // 4\n"
    ],
    "MbppEval/421": [
        "def concatenate_tuple(test_tup):\n    result = \"\"\n    for item in test_tup:\n        result += str(item) + \"-\"\n    return result[:-1]\n",
        "def concatenate_tuple(test_tup):\n    result = \"-\".join(map(str, test_tup))\n    return result\n",
        "def concatenate_tuple(test_tup):\n    result = \"\"\n    for i, item in enumerate(test_tup):\n        if i > 0:\n            result += \"-\"\n        result += str(item)\n    return result\n",
        "def concatenate_tuple(test_tup):\n    result = \"-\".join(map(str, test_tup))\n    return result\n",
        "def concatenate_tuple(test_tup):\n    return '-'.join(str(item) for item in test_tup)\n"
    ],
    "MbppEval/422": [
        "def find_Average_Of_Cube(n):\n    sum_of_cubes = 0\n    for i in range(1, n+1):\n        sum_of_cubes += i**3\n    return sum_of_cubes / n\n",
        "def find_Average_Of_Cube(n):\n    sum_of_numbers = n * (n + 1) / 2\n    sum_of_cubes = n * (n + 1) * (2 * n + 1) / 6\n    return sum_of_cubes / sum_of_numbers\n",
        "def find_Average_Of_Cube(n):\n    sum_of_cubes = 0\n    for i in range(1, n+1):\n        sum_of_cubes += i**3\n    return sum_of_cubes / n\n",
        "def find_Average_Of_Cube(n):\n    total_cube = 0\n    for i in range(1, n+1):\n        total_cube += i**3\n    return total_cube / n\n",
        "def find_Average_Of_Cube(n):\n    total_cubes = 0\n    for i in range(1, n+1):\n        total_cubes += i**3\n    return total_cubes / n\n"
    ],
    "MbppEval/424": [
        "def extract_rear(test_tuple):\n    rear_elements = []\n    for item in test_tuple:\n        rear_elements.append(item[-1])\n    return rear_elements\n",
        "def extract_rear(test_tuple):\n    result = []\n    for item in test_tuple:\n        result.append(str(item)[-1])\n    return result\n",
        "def extract_rear(test_tuple):\n    rear_elements = []\n    for string in test_tuple:\n        rear_elements.append(string[-1])\n    return rear_elements\n",
        "def extract_rear(test_tuple):\n    rear_elements = []\n    for item in test_tuple:\n        rear_elements.append(item[-1])\n    return rear_elements\n",
        "def extract_rear(test_tuple):\n    result = []\n    for string in test_tuple:\n        result.append(string[-1])\n    return result\n"
    ],
    "MbppEval/425": [
        "def count_element_in_list(list1, x):\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n",
        "def count_element_in_list(list1, x):\n    count = 0\n    for sub_list in list1:\n        if x in sub_list:\n            count += 1\n    return count\n",
        "def count_element_in_list(list1, x):\n    count = 0\n    for sub_list in list1:\n        if x in sub_list:\n            count += 1\n    return count\n",
        "def count_element_in_list(list1, x):\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n",
        "def count_element_in_list(list1, x):\n    count = 0\n    for sublist in list1:\n        if x in sublist:\n            count += 1\n    return count\n"
    ],
    "MbppEval/426": [
        "def filter_oddnumbers(nums):\n    odd_nums = []\n    for num in nums:\n        if num % 2 != 0:\n            odd_nums.append(num)\n    return odd_nums\n",
        "def filter_oddnumbers(nums):\n    odd_numbers = []\n    for num in nums:\n        if num % 2 != 0:\n            odd_numbers.append(num)\n    return odd_numbers\n",
        "def filter_oddnumbers(nums):\n    odd_nums = []\n    for num in nums:\n        if num % 2 == 1:\n            odd_nums.append(num)\n    return odd_nums\n",
        "def filter_oddnumbers(nums):\n    odd_nums = [num for num in nums if num % 2 != 0]\n    return odd_nums\n",
        "def filter_oddnumbers(nums):\n    odd_nums = []\n    for num in nums:\n        if num % 2 != 0:\n            odd_nums.append(num)\n    return odd_nums\n"
    ],
    "MbppEval/427": [
        "def change_date_format(dt):\n    if not isinstance(dt, str) or len(dt.split('-')) != 3:\n        return dt\n    year, month, day = dt.split('-')\n    return f\"{day}-{month}-{year}\"\n",
        "import re\n\ndef change_date_format(dt):\n    match = re.match(r'(\\d{4})-(\\d{2})-(\\d{2})', dt)\n    if match:\n        year, month, day = match.groups()\n        return f'{day}-{month}-{year}'\n    else:\n        return None\n",
        "import re\n\ndef change_date_format(dt):\n    \"\"\"\n    Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n\n    Examples:\n    change_date_format(\"2026-01-02\") == '02-01-2026'\n    change_date_format(\"2020-11-13\") == '13-11-2020'\n    change_date_format(\"2021-04-26\") == '26-04-2021'\n    \"\"\"\n    match = re.match(r\"(\\d{4})-(\\d{2})-(\\d{2})\", dt)\n    if match:\n        year, month, day = match.groups()\n        return f\"{day}-{month}-{year}\"\n    else:\n        raise ValueError(\"Invalid date format. Expected 'yyyy-mm-dd'.\")\n",
        "import re\n\ndef change_date_format(dt):\n    '''\n    Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n\n    Examples:\n    change_date_format(\"2026-01-02\") == '02-01-2026'\n    change_date_format(\"2020-11-13\") == '13-11-2020'\n    change_date_format(\"2021-04-26\") == '26-04-2021'\n    '''\n    match = re.match(r\"(\\d{4})-(\\d{2})-(\\d{2})\", dt)\n    if match:\n        year, month, day = match.groups()\n        return f\"{day}-{month}-{year}\"\n    else:\n        raise ValueError(\"Invalid date format: {dt}\")\n",
        "import re\n\ndef change_date_format(dt):\n    match = re.match(r\"(\\d{4})-(\\d{2})-(\\d{2})\", dt)\n    if match:\n        year, month, day = match.groups()\n        reformatted_date = \"{}-{}-{}\".format(day, month, year)\n        return reformatted_date\n    else:\n        raise ValueError(\"Invalid date format: {}\".format(dt))\n"
    ],
    "MbppEval/428": [
        "def shell_sort(my_list):\n    n = len(my_list)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j-gap] > temp:\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n    \n    return my_list\n",
        "def shell_sort(my_list):\n    n = len(my_list)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j-gap] > temp:\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n    \n    return my_list\n",
        "def shell_sort(my_list):\n    n = len(my_list)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list\n",
        "def shell_sort(my_list):\n    n = len(my_list)\n    gap = n // 2  # Initialize the gap\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2  # Decrease the gap\n\n    return my_list\n",
        "def shell_sort(my_list):\n    n = len(my_list)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j-gap] > temp:\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n\n    return my_list\n"
    ],
    "MbppEval/429": [
        "def and_tuples(test_tup1, test_tup2):\n    result = ()\n    for a, b in zip(test_tup1, test_tup2):\n        result += (a & b,)\n    return result\n",
        "def and_tuples(test_tup1, test_tup2):\n    result = tuple(a & b for a, b in zip(test_tup1, test_tup2))\n    return result\n",
        "def and_tuples(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length\")\n    \n    result = ()\n    for i in range(len(test_tup1)):\n        result_element = test_tup1[i] & test_tup2[i]\n        result += (result_element,)\n    \n    return result\n",
        "def and_tuples(test_tup1, test_tup2):\n    return tuple(a & b for a, b in zip(test_tup1, test_tup2))\n",
        "def and_tuples(test_tup1, test_tup2):\n    result = tuple(a & b for a, b in zip(test_tup1, test_tup2))\n    return result\n"
    ],
    "MbppEval/430": [
        "def parabola_directrix(a, b, c):\n    return -b / (2 * a)\n",
        "def parabola_directrix(a, b, c):\n    x_directrix = -b / (2 * a)\n    return x_directrix\n",
        "def parabola_directrix(a, b, c):\n    p = -1 / (4 * a)\n    return -p\n",
        "def parabola_directrix(a, b, c):\n    return -b / (2 * a)\n",
        "def parabola_directrix(a, b, c):\n    return -b / (2 * a)\n"
    ],
    "MbppEval/431": [
        "def common_element(list1, list2):\n    common_found = False\n    for elem in list1:\n        if elem in list2:\n            common_found = True\n            break\n    return common_found\n",
        "def common_element(list1, list2):\n    has_common = False\n    for item in list1:\n        if item in list2:\n            has_common = True\n            break\n    return has_common\n",
        "def common_element(list1, list2):\n    has_common = False\n    for element in list1:\n        if element in list2:\n            has_common = True\n            break\n    return has_common\n",
        "def common_element(list1, list2):\n    has_common_element = False\n    for item in list1:\n        if item in list2:\n            has_common_element = True\n            break\n    return has_common_element\n",
        "def common_element(list1, list2):\n    has_common_element = False\n    \n    for element in list1:\n        if element in list2:\n            has_common_element = True\n            break\n    \n    return has_common_element\n"
    ],
    "MbppEval/432": [
        "def median_trapezium(base1, base2, height):\n    middle_line_length = (base1 + base2) / 2\n    return middle_line_length\n",
        "def median_trapezium(base1, base2, height):\n    median = (base1 + base2) / 2\n    return median\n",
        "def median_trapezium(base1, base2, height):\n    median_length = (base1 + base2) / 2\n    return median_length\n",
        "def median_trapezium(base1, base2, height):\n    median = (base1 + base2) / 2\n    return median\n",
        "def median_trapezium(base1, base2, height):\n    return (base1 + base2) / 2\n"
    ],
    "MbppEval/433": [
        "def check_greater(arr, number):\n    is_greater = True\n    for element in arr:\n        if number <= element:\n            is_greater = False\n            break\n    if is_greater:\n        return 'Yes, the entered number is greater than those in the array'\n    else:\n        return 'No, entered number is less than those in the array'\n",
        "def check_greater(arr, number):\n    is_greater = True\n    for element in arr:\n        if number <= element:\n            is_greater = False\n            break\n    if is_greater:\n        return \"Yes, the entered number is greater than those in the array\"\n    else:\n        return \"No, entered number is less than those in the array\"\n",
        "def check_greater(arr, number):\n    greater_count = 0\n    for element in arr:\n        if element < number:\n            greater_count += 1\n    \n    if greater_count == len(arr):\n        return \"Yes, the entered number is greater than those in the array\"\n    else:\n        return \"No, the entered number is not greater than those in the array\"\n",
        "def check_greater(arr, number):\n    is_greater = True\n    for element in arr:\n        if number <= element:\n            is_greater = False\n            break\n    if is_greater:\n        return \"Yes, the entered number is greater than those in the array\"\n    else:\n        return \"No, entered number is less than those in the array\"\n",
        "def check_greater(arr, number):\n    is_greater = True\n    for element in arr:\n        if number <= element:\n            is_greater = False\n            break\n    if is_greater:\n        return \"Yes, the entered number is greater than those in the array\"\n    else:\n        return \"No, entered number is less than those in the array\"\n"
    ],
    "MbppEval/434": [
        "import re\n\ndef text_match_one(text):\n    pattern = r'a(?:b+)'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_one(text):\n    pattern = r'ab+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_one(text):\n    if re.search(r'a[b]+$', text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_one(text):\n    pattern = r\"ab+\"\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
        "import re\n\ndef text_match_one(text):\n    if re.search(r'ab+', text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n"
    ],
    "MbppEval/435": [
        "def last_Digit(n):\n    return int(str(n)[-1])\n",
        "def last_Digit(n):\n    return n % 10\n",
        "def last_Digit(n):\n    return n % 10\n",
        "def last_Digit(n):\n    return n % 10\n",
        "def last_Digit(n):\n    return n % 10\n"
    ],
    "MbppEval/436": [
        "def neg_nos(list1):\n    \"\"\"\n    Write a python function to return the negative numbers in a list.\n\n    Examples:\n    neg_nos([-1,4,5,-6]) == [-1, -6]\n    neg_nos([-1,-2,3,4]) == [-1, -2]\n    neg_nos([-7,-6,8,9]) == [-7, -6]\n    \"\"\"\n    negative_numbers = [num for num in list1 if num < 0]\n    return negative_numbers\n",
        "def neg_nos(list1):\n    \"\"\"\n    Write a python function to return the negative numbers in a list.\n\n    Examples:\n    neg_nos([-1,4,5,-6]) == [-1,-6]\n    neg_nos([-1,-2,3,4]) == [-1,-2]\n    neg_nos([-7,-6,8,9]) == [-7,-6]\n    \"\"\"\n    return [num for num in list1 if num < 0]\n",
        "def neg_nos(list1):\n    negative_nums = [num for num in list1 if num < 0]\n    return negative_nums\n",
        "def neg_nos(list1):\n    negative_numbers = [num for num in list1 if num < 0]\n    return negative_numbers\n",
        "def neg_nos(list1):\n    negative_nums = []\n    for num in list1:\n        if num < 0:\n            negative_nums.append(num)\n    return negative_nums\n"
    ],
    "MbppEval/437": [
        "def remove_odd(str1):\n    result = \"\"\n    for i, char in enumerate(str1):\n        if i % 2 == 0:\n            result += char\n    return result\n",
        "def remove_odd(str1):\n    result = \"\"\n    for i, char in enumerate(str1):\n        if i % 2 == 0:\n            result += char\n    return result\n",
        "def remove_odd(str1):\n    result = \"\"\n    for i, char in enumerate(str1):\n        if i % 2 == 0:\n            result += char\n    return result\n",
        "def remove_odd(str1):\n    result = \"\"\n    for i, char in enumerate(str1):\n        if i % 2 == 0:\n            result += char\n    return result\n",
        "def remove_odd(str1):\n    return str1[::2]\n"
    ],
    "MbppEval/438": [
        "def count_bidirectional(test_list):\n    \"\"\"\n    Write a function to count bidirectional tuple pairs.\n\n    Examples:\n    count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]) == '3'\n    count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)]) == '2'\n    count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)]) == '4'\n    \"\"\"\n    bidirectional_count = {}\n\n    for pair in test_list:\n        reverse_pair = (pair[1], pair[0])\n        if reverse_pair in test_list:\n            bidirectional_count[tuple(sorted(pair))] = bidirectional_count.get(tuple(sorted(pair)), 0) + 1\n\n    return str(sum(bidirectional_count.values()))\n",
        "def count_bidirectional(test_list):\n    count = 0\n    for tup in test_list:\n        reverse_tup = (tup[1], tup[0])\n        if reverse_tup in test_list:\n            count += 1\n    return str(count)\n",
        "def count_bidirectional(test_list):\n    pair_count = {}\n\n    for pair in test_list:\n        reverse_pair = (pair[1], pair[0])\n        if reverse_pair in pair_count:\n            pair_count[reverse_pair] += 1\n        else:\n            pair_count[pair] = 1\n            pair_count[reverse_pair] = 1\n\n    bidirectional_count = sum(1 for count in pair_count.values() if count > 1)\n    return str(bidirectional_count)\n",
        "def count_bidirectional(test_list):\n    tuple_dict = {}\n    count = 0\n    for t in test_list:\n        reverse_t = (t[1], t[0])\n        if reverse_t in tuple_dict:\n            count += 1\n            tuple_dict.pop(reverse_t)\n        else:\n            tuple_dict[t] = reverse_t\n    return str(count)\n",
        "def count_bidirectional(test_list):\n    bidirectional_pairs = set()\n    for tup in test_list:\n        reverse_tup = (tup[1], tup[0])\n        if reverse_tup in test_list:\n            bidirectional_pairs.add(tuple(sorted(tup)))\n    return str(len(bidirectional_pairs))\n"
    ],
    "MbppEval/439": [
        "def multiple_to_single(L):\n    return int(''.join(map(str, L)))\n",
        "def multiple_to_single(L):\n    result = ''\n    for num in L:\n        result += str(num)\n    return result\n",
        "def multiple_to_single(L):\n    if not L:\n        return 0\n    \n    result = 0\n    for i, num in enumerate(L):\n        result = result * 10 + num\n    \n    return result\n",
        "def multiple_to_single(L):\n    result = ''\n    for num in L:\n        result += str(num)\n    return int(result)\n",
        "def multiple_to_single(L):\n    result = \"\"\n    for num in L:\n        result += str(num)\n    return int(result)\n"
    ],
    "MbppEval/440": [
        "import re\n\ndef find_adverb_position(text):\n    pattern = r'^\\w*?(\\w+ly)\\b\\w*'\n    match = re.search(pattern, text)\n    if match:\n        start = match.start()\n        end = match.end()\n        adverb = match.group(1)\n        return (start, end, adverb)\n    else:\n        return None\n",
        "import re\n\ndef find_adverb_position(text):\n    match = re.search(r'\\w+ly', text)\n    if match:\n        start = match.start()\n        end = match.end()\n        adverb = match.group()\n        return (start, end, adverb)\n    else:\n        return None\n",
        "import re\n\ndef find_adverb_position(text):\n    adverb_match = re.search(r'\\w+ly', text)\n    if adverb_match:\n        start = adverb_match.start()\n        end = adverb_match.end()\n        adverb = adverb_match.group()\n        return (start, end, adverb)\n    else:\n        return None\n",
        "import re\n\ndef find_adverb_position(text):\n    adverb_pattern = r'\\w+ly'\n    match = re.search(adverb_pattern, text)\n    if match:\n        start = match.start()\n        end = match.end()\n        adverb = match.group()\n        return (start, end, adverb)\n    else:\n        return None\n",
        "import re\n\ndef find_adverb_position(text):\n    \"\"\"\n    Write a function to find the first adverb and their positions in a given sentence.\n\n    Examples:\n    find_adverb_position(\"clearly!! we can see the sky\") == (0, 7, 'clearly')\n    find_adverb_position(\"seriously!! there are many roses\") == (0, 9, 'seriously')\n    find_adverb_position(\"unfortunately!! sita is going to home\") == (0, 13, 'unfortunately')\n    \"\"\"\n    match = re.search(r'\\w+ly', text)\n    if match:\n        start = match.start()\n        end = match.end()\n        adverb = match.group()\n        return (start, end, adverb)\n    else:\n        return None\n"
    ],
    "MbppEval/441": [
        "def surfacearea_cube(l):\n    return 6 * (l ** 2)\n",
        "def surfacearea_cube(l):\n    return 6 * (l ** 2)\n",
        "def surfacearea_cube(l):\n    return 6 * l**2\n",
        "def surfacearea_cube(l):\n    return 6 * (l ** 2)\n",
        "def surfacearea_cube(l):\n    return 6 * l ** 2\n"
    ],
    "MbppEval/442": [
        "def positive_count(nums):\n    positive_count = 0\n    for num in nums:\n        if num > 0:\n            positive_count += 1\n    return positive_count / len(nums)\n",
        "from array import array\n\ndef positive_count(nums):\n    positive_count = 0\n    for num in nums:\n        if num > 0:\n            positive_count += 1\n    return positive_count / len(nums)\n",
        "def positive_count(nums):\n    positive_count = 0\n    for num in nums:\n        if num > 0:\n            positive_count += 1\n    return positive_count / len(nums)\n",
        "def positive_count(nums):\n    positive_nums = 0\n    for num in nums:\n        if num > 0:\n            positive_nums += 1\n    return positive_nums / len(nums)\n",
        "from array import array\n\ndef positive_count(nums):\n    positive_count = 0\n    for num in nums:\n        if num > 0:\n            positive_count += 1\n    return positive_count / len(nums)\n"
    ],
    "MbppEval/443": [
        "def largest_neg(list1):\n    largest_neg = float('-inf')\n    for num in list1:\n        if num < 0 and num > largest_neg:\n            largest_neg = num\n    return largest_neg\n",
        "def largest_neg(list1):\n    largest_negative = float('-inf')\n    \n    for num in list1:\n        if num < 0 and num > largest_negative:\n            largest_negative = num\n    \n    if largest_negative == float('-inf'):\n        return None\n    else:\n        return largest_negative\n",
        "def largest_neg(list1):\n    largest_neg = float('-inf')\n    for num in list1:\n        if num < 0 and num > largest_neg:\n            largest_neg = num\n    return largest_neg\n",
        "def largest_neg(list1):\n    largest_neg = float('inf')\n    \n    for num in list1:\n        if num < 0 and num > largest_neg:\n            largest_neg = num\n    \n    if largest_neg == float('inf'):\n        return None\n    else:\n        return largest_neg\n",
        "def largest_neg(list1):\n    largest_neg = None\n    \n    for num in list1:\n        if num < 0 and (largest_neg is None or num > largest_neg):\n            largest_neg = num\n    \n    return largest_neg\n"
    ],
    "MbppEval/444": [
        "def trim_tuple(test_list, K):\n    trimmed_tuples = []\n    for tup in test_list:\n        trimmed_tuple = tup[:-K]\n        trimmed_tuples.append(trimmed_tuple)\n    return str(trimmed_tuples)\n",
        "def trim_tuple(test_list, K):\n    return [tup[K:] for tup in test_list]\n",
        "def trim_tuple(test_list, K):\n    trimmed_tuples = [tup[K:] for tup in test_list]\n    return str(trimmed_tuples)\n",
        "def trim_tuple(test_list, K):\n    for i in range(len(test_list)):\n        test_list[i] = test_list[i][K:]\n    return test_list\n",
        "def trim_tuples_by_k(test_list, k):\n    \"\"\"\n    Trim each tuple in the given list by the first k elements.\n\n    Args:\n        test_list (list): A list of tuples.\n        k (int): The number of elements to trim from the beginning of each tuple.\n\n    Returns:\n        list: A list of trimmed tuples.\n    \"\"\"\n    return [tup[k:] for tup in test_list]\n"
    ],
    "MbppEval/445": [
        "def index_multiplication(test_tup1, test_tup2):\n    result = [(a*x, b*y) for (a,b), (x,y) in zip(test_tup1, test_tup2)]\n    return tuple(result)\n",
        "def index_multiplication(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length.\")\n    \n    result = []\n    for pair1, pair2 in zip(test_tup1, test_tup2):\n        result.append((pair1[0] * pair2[0], pair1[1] * pair2[1]))\n    \n    return tuple(result)\n",
        "def index_multiplication(test_tup1, test_tup2):\n    result = []\n    for t1, t2 in zip(test_tup1, test_tup2):\n        temp = tuple(a * b for a, b in zip(t1, t2))\n        result.append(temp)\n    return tuple(result)\n",
        "def index_multiplication(test_tup1, test_tup2):\n    return tuple([(a * x, b * y) for (a, b), (x, y) in zip(test_tup1, test_tup2)])\n",
        "def index_multiplication(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length\")\n\n    result = ()\n    for i in range(len(test_tup1)):\n        result += ((test_tup1[i][0] * test_tup2[i][0], test_tup1[i][1] * test_tup2[i][1]),)\n\n    return result\n"
    ],
    "MbppEval/446": [
        "from collections import Counter\n\ndef count_Occurrence(tup, lst):\n    counter = Counter(tup)\n    total_count = 0\n    for item in lst:\n        total_count += counter[item]\n    return total_count\n",
        "from collections import Counter\n\ndef count_Occurrence(tup, lst):\n    counter = Counter(tup)\n    count = 0\n    for element in lst:\n        if element in counter:\n            count += counter[element]\n    return count\n",
        "from collections import Counter\n\ndef count_Occurrence(tup, lst):\n    tup_counter = Counter(tup)\n    total_count = 0\n    for element in lst:\n        total_count += tup_counter[element]\n    return total_count\n",
        "from collections import Counter \n\ndef count_Occurrence(tup, lst):\n    counter = Counter(tup)\n    count = 0\n    for element in lst:\n        if element in counter:\n            count += counter[element]\n    return count\n",
        "from collections import Counter \n\ndef count_Occurrence(tup, lst):\n    counter = Counter(tup)\n    total_count = 0\n    for item in lst:\n        total_count += counter[item]\n    return total_count\n"
    ],
    "MbppEval/447": [
        "def cube_nums(nums):\n    cubed_nums = []\n    for num in nums:\n        cubed_nums.append(num ** 3)\n    return cubed_nums\n",
        "def cube_nums(nums):\n    cubes = []\n    for num in nums:\n        cubes.append(num ** 3)\n    return cubes\n",
        "def cube_nums(nums):\n    return [num ** 3 for num in nums]\n",
        "def cube_nums(nums):\n    return [num ** 3 for num in nums]\n",
        "def cube_nums(nums):\n    result = []\n    for num in nums:\n        result.append(num ** 3)\n    return result\n"
    ],
    "MbppEval/448": [
        "def cal_sum(n):\n    \"\"\"\n    Write a function to calculate the sum of perrin numbers.\n\n    Examples:\n    cal_sum(9) == 49\n    cal_sum(10) == 66\n    cal_sum(11) == 88\n    \"\"\"\n    perrin_nums = [0, 0, 2]\n    \n    if n <= 3:\n        return sum(perrin_nums[:n])\n    \n    for i in range(3, n):\n        next_num = perrin_nums[-3] + perrin_nums[-2]\n        perrin_nums.append(next_num)\n    \n    return sum(perrin_nums[:n])\n",
        "def cal_sum(n):\n    \"\"\"\n    Write a function to calculate the sum of Perrin numbers.\n\n    Examples:\n    cal_sum(9) == 49\n    cal_sum(10) == 66\n    cal_sum(11) == 88\n    \"\"\"\n    perrin_nums = [3, 0, 2]\n    if n <= 3:\n        return sum(perrin_nums[:n])\n    for i in range(3, n):\n        next_perrin = perrin_nums[-2] + perrin_nums[-3]\n        perrin_nums.append(next_perrin)\n    return sum(perrin_nums)\n",
        "def cal_sum(n):\n    \"\"\"\n    Write a function to calculate the sum of Perrin numbers.\n\n    Examples:\n    cal_sum(9) == 49\n    cal_sum(10) == 66\n    cal_sum(11) == 88\n    \"\"\"\n    perrin = [3, 0, 2]\n    for i in range(3, n+1):\n        perrin.append(perrin[i-2] + perrin[i-3])\n    return sum(perrin)\n",
        "def cal_sum(n):\n    \"\"\"\n    Write a function to calculate the sum of Perrin numbers.\n\n    Examples:\n    cal_sum(9) == 49\n    cal_sum(10) == 66\n    cal_sum(11) == 88\n    \"\"\"\n    if n <= 0:\n        return 0\n\n    # Initialize the first three Perrin numbers\n    perrin = [3, 0, 2]\n\n    # Calculate the Perrin numbers up to the nth term\n    for i in range(3, n):\n        next_perrin = perrin[i-3] + perrin[i-2] + perrin[i-1]\n        perrin.append(next_perrin)\n\n    # Calculate the sum of the Perrin numbers\n    return sum(perrin)\n",
        "def cal_sum(n):\n    \"\"\"\n    Write a function to calculate the sum of perrin numbers.\n\n    Examples:\n    cal_sum(9) == 49\n    cal_sum(10) == 66\n    cal_sum(11) == 88\n    \"\"\"\n    perrin = [3, 0, 2]\n    for i in range(3, n):\n        next_perrin = perrin[-3] + perrin[-2]\n        perrin.append(next_perrin)\n    return sum(perrin)\n"
    ],
    "MbppEval/450": [
        "def extract_string(str_list, length):\n    return [s for s in str_list if len(s) == length]\n",
        "def extract_string(str_list, length):\n    result = []\n    for s in str_list:\n        if len(s) == length:\n            result.append(s)\n    return result\n",
        "def extract_string(str, l):\n    extracted_strings = []\n    for s in str:\n        if len(s) == l:\n            extracted_strings.append(s)\n    return extracted_strings\n",
        "def extract_string(str, l):\n    return [s for s in str if len(s) == l]\n",
        "def extract_string(strings, length):\n    return [s for s in strings if len(s) == length]\n"
    ],
    "MbppEval/451": [
        "import re\n\ndef remove_whitespaces(text1):\n    return re.sub(r'\\s+', '', text1)\n",
        "import re\n\ndef remove_whitespaces(text1):\n    return re.sub(r'\\s+', '', text1)\n",
        "import re\n\ndef remove_whitespaces(text1):\n    return re.sub(r'\\s+', '', text1)\n",
        "import re\n\ndef remove_whitespaces(text1):\n    return re.sub(r'\\s+', '', text1)\n",
        "import re\n\ndef remove_whitespaces(text1):\n    return re.sub(r'\\s+', '', text1)\n"
    ],
    "MbppEval/452": [
        "def loss_amount(actual_cost, sale_amount):\n    \"\"\"\n    Write a function that gives loss amount on a sale if the given amount has loss else return 0.\n\n    Examples:\n    loss_amount(1500, 1200) == 300\n    loss_amount(100, 200) == 0\n    loss_amount(2000, 5000) == 0\n    \"\"\"\n    if sale_amount < actual_cost:\n        return actual_cost - sale_amount\n    else:\n        return 0\n",
        "def loss_amount(actual_cost, sale_amount):\n    \"\"\"\n    Write a function that gives loss amount on a sale if the given amount has loss else return 0.\n\n    Examples:\n    loss_amount(1500, 1200) == 300\n    loss_amount(100, 200) == 0\n    loss_amount(2000, 5000) == 0\n    \"\"\"\n    if sale_amount < actual_cost:\n        return actual_cost - sale_amount\n    else:\n        return 0\n",
        "def loss_amount(actual_cost, sale_amount):\n    if sale_amount < actual_cost:\n        return actual_cost - sale_amount\n    else:\n        return 0\n",
        "def loss_amount(actual_cost, sale_amount):\n    if sale_amount < actual_cost:\n        return actual_cost - sale_amount\n    else:\n        return 0\n",
        "def loss_amount(actual_cost, sale_amount):\n    if sale_amount < actual_cost:\n        return actual_cost - sale_amount\n    else:\n        return 0\n"
    ],
    "MbppEval/453": [
        "import math\n\ndef sumofFactors(n):\n    factors = [i for i in range(1, n+1) if n % i == 0]\n    even_factors = [f for f in factors if f % 2 == 0]\n    return sum(even_factors)\n",
        "import math\n\ndef sumofFactors(n):\n    \"\"\"\n    Write a python function to find the sum of even factors of a number.\n\n    Examples:\n    sumofFactors(18) == 26\n    sumofFactors(30) == 48\n    sumofFactors(6) == 8\n    \"\"\"\n    sum = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                sum += i\n            if (n // i) % 2 == 0 and (n // i) != i:\n                sum += n // i\n    if int(math.sqrt(n)) ** 2 == n:\n        sum += int(math.sqrt(n))\n    return sum\n",
        "import math\n\ndef sumofFactors(n):\n    \"\"\"\n    Write a python function to find the sum of even factors of a number.\n    \n    Examples:\n    sumofFactors(18) == 26\n    sumofFactors(30) == 48\n    sumofFactors(6) == 8\n    \"\"\"\n    total = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                total += i\n            if (n // i) % 2 == 0 and (n // i) != i:\n                total += (n // i)\n    if n % 2 == 0:\n        total += n\n    return total\n",
        "import math\n\ndef sumofFactors(n):\n    even_factors = []\n    for i in range(1, n+1):\n        if n % i == 0 and i % 2 == 0:\n            even_factors.append(i)\n    return sum(even_factors)\n",
        "def sumofFactors(n):\n    \"\"\"\n    Write a python function to find the sum of even factors of a number.\n\n    Examples:\n    sumofFactors(18) == 26\n    sumofFactors(30) == 48\n    sumofFactors(6) == 8\n    \"\"\"\n    sum_of_even_factors = 0\n    for i in range(1, n+1):\n        if n % i == 0 and i % 2 == 0:\n            sum_of_even_factors += i\n    return sum_of_even_factors\n"
    ],
    "MbppEval/454": [
        "import re\n\ndef text_match_wordz(text):\n    pattern = r'\\b\\w*z\\w*\\b'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
        "import re\n\ndef text_match_wordz(text):\n    if re.search(r'\\w*z\\w*', text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_wordz(text):\n    pattern = r'\\bz\\w*\\b'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
        "import re\n\ndef text_match_wordz(text):\n    pattern = r'\\w*z\\w*'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_wordz(text):\n    pattern = r'\\b\\w*z\\w*\\b'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n"
    ],
    "MbppEval/455": [
        "def check_monthnumb_number(monthnum2):\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n    return monthnum2 in months_with_31_days\n",
        "import calendar\n\ndef check_monthnumb_number(month, year):\n    _, num_days = calendar.monthrange(year, month)\n    return num_days == 31\n",
        "def check_monthnumb_number(monthnum2):\n    \"\"\"\n    Write a function to check whether the given month number contains 31 days or not.\n\n    Examples:\n    check_monthnumb_number(5) == True\n    check_monthnumb_number(2) == False\n    check_monthnumb_number(6) == False\n    \"\"\"\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n    if monthnum2 in months_with_31_days:\n        return True\n    else:\n        return False\n",
        "def check_monthnumb_number(monthnum2):\n    months_31_days = [1, 3, 5, 7, 8, 10, 12]\n    return monthnum2 in months_31_days\n",
        "def check_monthnumb_number(monthnum2):\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n    return monthnum2 in months_with_31_days\n"
    ],
    "MbppEval/456": [
        "def reverse_string_list(stringlist):\n    reversed_strings = []\n    for string in stringlist:\n        reversed_strings.append(string[::-1])\n    return reversed_strings\n",
        "def reverse_string_list(stringlist):\n    reversed_strings = []\n    for string in stringlist:\n        reversed_strings.append(string[::-1])\n    return reversed_strings\n",
        "def reverse_string_list(stringlist):\n    reversed_strings = []\n    for string in stringlist:\n        reversed_strings.append(string[::-1])\n    return reversed_strings\n",
        "def reverse_string_list(stringlist):\n    reversed_strings = []\n    for string in stringlist:\n        reversed_strings.append(string[::-1])\n    return reversed_strings\n",
        "def reverse_string_list(stringlist):\n    reversed_strings = []\n    for string in stringlist:\n        reversed_strings.append(string[::-1])\n    return reversed_strings\n"
    ],
    "MbppEval/457": [
        "def Find_Min(lst):\n    \"\"\"\n    Write a python function to find the sublist having minimum length.\n\n    Examples:\n    Find_Min([[1],[1,2],[1,2,3]]) == [1]\n    Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]\n    Find_Min([['x'],['x','y'],['x','y','z']]) == ['x']\n    \"\"\"\n    min_length = float('inf')\n    min_sublist = None\n\n    for sublst in lst:\n        if len(sublst) < min_length:\n            min_length = len(sublst)\n            min_sublist = sublst\n\n    return min_sublist\n",
        "def Find_Min(lst):\n    min_length = float('inf')\n    min_sublist = None\n\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n\n    return min_sublist\n",
        "def Find_Min(lst):\n    min_length = float('inf')\n    min_sublist = None\n\n    for sublst in lst:\n        if len(sublst) < min_length:\n            min_length = len(sublst)\n            min_sublist = sublst\n\n    return min_sublist\n",
        "def Find_Min(lst):\n    min_length = float('inf')\n    min_sublist = None\n\n    for sublst in lst:\n        if len(sublst) < min_length:\n            min_length = len(sublst)\n            min_sublist = sublst\n        elif len(sublst) == min_length:\n            min_sublist = sublst\n\n    return min_sublist\n",
        "def Find_Min(lst):\n    min_length = float('inf')\n    min_sublist = None\n\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n\n    return min_sublist\n"
    ],
    "MbppEval/458": [
        "def rectangle_area(l, b):\n    area = l * b\n    return area\n",
        "def rectangle_area(l, b):\n    return l * b\n",
        "def rectangle_area(length, breadth):\n    \"\"\"\n    Write a function to find the area of a rectangle.\n\n    Examples:\n    rectangle_area(10, 20) == 200\n    rectangle_area(10, 5) == 50\n    rectangle_area(4, 2) == 8\n    \"\"\"\n    return length * breadth\n",
        "def rectangle_area(l, b):\n    area = l * b\n    return area\n",
        "def rectangle_area(l, b):\n    \"\"\"\n    Write a function to find the area of a rectangle.\n\n    Examples:\n    rectangle_area(10, 20) == 200\n    rectangle_area(10, 5) == 50\n    rectangle_area(4, 2) == 8\n    \"\"\"\n    area = l * b\n    return area\n"
    ],
    "MbppEval/459": [
        "import re\n\ndef remove_uppercase(str1):\n    return re.sub(r'[A-Z]+', '', str1)\n",
        "import re\n\ndef remove_uppercase(str1):\n    return re.sub(r'[A-Z]+', '', str1)\n",
        "import re\n\ndef remove_uppercase(str1):\n    return re.sub(r'[A-Z]+', '', str1)\n",
        "import re\n\ndef remove_uppercase(str1):\n    return re.sub(r'[A-Z]+', '', str1)\n",
        "import re\n\ndef remove_uppercase(str1):\n    return re.sub(r'[A-Z]+', '', str1)\n"
    ],
    "MbppEval/460": [
        "def Extract(lst):\n    first_elements = []\n    for sublst in lst:\n        first_elements.append(sublst[0])\n    return first_elements\n",
        "def Extract(lst):\n    first_elements = []\n    for sub_list in lst:\n        first_elements.append(sub_list[0])\n    return first_elements\n",
        "def Extract(lst):\n    result = []\n    for sublst in lst:\n        result.append(sublst[0])\n    return result\n",
        "def Extract(lst):\n    first_elements = []\n    for sub_list in lst:\n        first_elements.append(sub_list[0])\n    return first_elements\n",
        "def Extract(lst):\n    \"\"\"\n    Write a python function to get the first element of each sublist.\n\n    Examples:\n    Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    Extract([[1,2,3],[4, 5]]) == [1,4]\n    Extract([[9,8,1],[1,2]]) == [9,1]\n    \"\"\"\n    return [sub_list[0] for sub_list in lst]\n"
    ],
    "MbppEval/461": [
        "def upper_ctr(string):\n    count = 0\n    for char in string:\n        if char.isupper():\n            count += 1\n    return count\n",
        "def upper_ctr(str):\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count\n",
        "def upper_ctr(str):\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count\n",
        "def upper_ctr(str):\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count\n",
        "def upper_ctr(str):\n    upper_count = 0\n    for char in str:\n        if char.isupper():\n            upper_count += 1\n    return upper_count\n"
    ],
    "MbppEval/462": [
        "def combinations_list(list1):\n    result = [[]]\n    find_combinations([], list1, result)\n    return result\n\ndef find_combinations(current_list, remaining_elements, result):\n    if not remaining_elements:\n        result.append(current_list[:])\n        return\n\n    for i in range(len(remaining_elements)):\n        new_list = current_list + [remaining_elements[i]]\n        result.append(new_list)\n        find_combinations(new_list, remaining_elements[i+1:], result)\n",
        "def combinations_list(list1):\n    result = []\n\n    def generate_combinations(curr_combo, remaining_list):\n        if not remaining_list:\n            result.append(curr_combo[:])\n            return\n\n        # Include the first element\n        curr_combo.append(remaining_list[0])\n        generate_combinations(curr_combo, remaining_list[1:])\n        curr_combo.pop()\n\n        # Exclude the first element\n        generate_combinations(curr_combo, remaining_list[1:])\n\n    generate_combinations([], list1)\n    return result\n",
        "def combinations_list(list1):\n    result = []\n    def generate_combinations(lst, remaining):\n        if not remaining:\n            result.append(lst[:])\n        else:\n            for x in remaining:\n                lst.append(x)\n                generate_combinations(lst, remaining[remaining.index(x)+1:])\n                lst.pop()\n    generate_combinations([], list1)\n    return result\n",
        "def combinations_list(list1):\n    combinations = []\n\n    def helper(current_combination, remaining_list):\n        if not remaining_list:\n            combinations.append(current_combination[:])\n            return\n        \n        for i in range(len(remaining_list)):\n            current_combination.append(remaining_list[i])\n            helper(current_combination, remaining_list[i+1:])\n            current_combination.pop()\n    \n    helper([], list1)\n    return combinations\n",
        "def combinations_list(list1):\n    if not list1:\n        return [[]]\n    \n    combinations = []\n    for i in range(len(list1)):\n        current = list1[i]\n        remaining = list1[i+1:]\n        \n        for combo in combinations_list(remaining):\n            combinations.append([current] + combo)\n        \n        combinations.append([current])\n    \n    return combinations\n"
    ],
    "MbppEval/463": [
        "def max_subarray_product(arr):\n    if not arr:\n        return 0\n    \n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    result = arr[0]\n    \n    for i in range(1, len(arr)):\n        curr = arr[i]\n        temp_max = max(curr, max_so_far * curr, min_so_far * curr)\n        min_so_far = min(curr, max_so_far * curr, min_so_far * curr)\n        \n        max_so_far = temp_max\n        \n        result = max(max_so_far, result)\n    \n    return result\n",
        "def max_subarray_product(arr):\n    if not arr:\n        return 0\n\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        curr = arr[i]\n        temp_max = max(curr, max_so_far * curr, min_so_far * curr)\n        min_so_far = min(curr, max_so_far * curr, min_so_far * curr)\n\n        max_so_far = temp_max\n\n        result = max(max_so_far, result)\n\n    return result\n",
        "def max_subarray_product(arr):\n    if not arr:\n        return 0\n\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        temp = max_so_far\n        max_so_far = max(max(arr[i], max_so_far * arr[i], min_so_far * arr[i]), result)\n        min_so_far = min(min(arr[i], temp * arr[i], min_so_far * arr[i]), result)\n        result = max(result, max_so_far)\n\n    return result\n",
        "def max_subarray_product(arr):\n    if not arr:\n        return 0\n\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    result = max_so_far\n\n    for i in range(1, len(arr)):\n        curr = arr[i]\n        temp_max = max(curr, max_so_far * curr, min_so_far * curr)\n        min_so_far = min(curr, max_so_far * curr, min_so_far * curr)\n\n        max_so_far = temp_max\n\n        result = max(max_so_far, result)\n\n    return result\n",
        "def max_subarray_product(arr):\n    if not arr:\n        return 0\n\n    max_so_far = arr[0]\n    max_ending_here = arr[0]\n\n    for i in range(1, len(arr)):\n        curr = arr[i]\n        temp_max = max(curr, max_ending_here * curr, max_so_far * curr)\n        max_so_far = max(max_so_far, temp_max)\n        max_ending_here = temp_max\n\n    return max_so_far\n"
    ],
    "MbppEval/464": [
        "def check_value(dict, n):\n    for value in dict.values():\n        if value != n:\n            return False\n    return True\n",
        "def check_value(d, n):\n    if not d:\n        return True\n\n    first_value = next(iter(d.values()))\n    for value in d.values():\n        if value != first_value:\n            return False\n\n    return True\n",
        "def check_value(dict, n):\n    return len(set(dict.values())) == 1 and all(value == n for value in dict.values())\n",
        "def check_value(dict, n):\n    same_value = True\n    for value in dict.values():\n        if value != n:\n            same_value = False\n            break\n    return same_value\n",
        "def check_value(dict, n):\n    is_same = True\n    for value in dict.values():\n        if value != n:\n            is_same = False\n            break\n    return is_same\n"
    ],
    "MbppEval/465": [
        "def drop_empty(dict1):\n    new_dict = {}\n    for key, value in dict1.items():\n        if value is not None:\n            new_dict[key] = value\n    return new_dict\n",
        "def drop_empty(dict1):\n    new_dict = {}\n    for key, value in dict1.items():\n        if value is not None:\n            new_dict[key] = value\n    return new_dict\n",
        "def drop_empty(dict1):\n    new_dict = {k:v for k, v in dict1.items() if v is not None}\n    return new_dict\n",
        "def drop_empty(dict1):\n    result = {}\n    for key, value in dict1.items():\n        if value is not None:\n            result[key] = value\n    return result\n",
        "def drop_empty(dict1):\n    result = {}\n    for key, value in dict1.items():\n        if value is not None:\n            result[key] = value\n    return result\n"
    ],
    "MbppEval/468": [
        "def max_product(arr):\n    n = len(arr)\n    arr.sort()\n    max_product = 1\n\n    for i in range(n):\n        product = 1\n        for j in range(i+1):\n            product *= arr[j]\n        max_product = max(max_product, product)\n\n    return max_product\n",
        "def max_product(arr):\n    if len(arr) == 0:\n        return 0\n    \n    max_prod = arr[0]\n    curr_prod = arr[0]\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            curr_prod *= arr[i]\n            max_prod = max(max_prod, curr_prod)\n        else:\n            curr_prod = arr[i]\n    \n    return max_prod\n",
        "def max_product(arr):\n    max_product = 1\n    current_product = 1\n\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            current_product *= arr[i]\n            max_product = max(max_product, current_product)\n        else:\n            current_product = 1\n\n    return max_product\n",
        "def max_product(arr):\n    n = len(arr)\n    lis = [1] * n\n    max_product = 0\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n        max_product = max(max_product, arr[i] * lis[i])\n\n    return max_product\n",
        "def max_product(arr):\n    \"\"\"\n    Find the maximum product formed by multiplying numbers of an increasing subsequence of the given array.\n    \"\"\"\n    n = len(arr)\n    max_prod = arr[0]\n    prev_max = arr[0]\n\n    for i in range(1, n):\n        curr_max = max(arr[i], prev_max * arr[i])\n        max_prod = max(max_prod, curr_max)\n        prev_max = curr_max\n\n    return max_prod\n"
    ],
    "MbppEval/470": [
        "def add_pairwise(test_tup):\n    \"\"\"\n    Write a function to find the pairwise addition of the neighboring elements of the given tuple.\n\n    Examples:\n    add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)\n    add_pairwise((2, 6, 8, 9, 11)) == (8, 14, 17, 20)\n    add_pairwise((3, 7, 9, 10, 12)) == (10, 16, 19, 22)\n    \"\"\"\n    test_list = list(test_tup)\n    result = [test_list[i] + test_list[i+1] for i in range(len(test_list)-1)]\n    return tuple(result)\n",
        "def add_pairwise(test_tup):\n    pairwise_additions = []\n    for i in range(len(test_tup) - 1):\n        pairwise_additions.append(test_tup[i] + test_tup[i+1])\n    return tuple(pairwise_additions)\n",
        "def add_pairwise(test_tup):\n    result = []\n    for i in range(0, len(test_tup) - 1, 2):\n        result.append(test_tup[i] + test_tup[i + 1])\n    return tuple(result)\n",
        "def add_pairwise(test_tup):\n    return tuple(a + b for a, b in zip(test_tup[:-1], test_tup[1:]))\n",
        "def add_pairwise(test_tup):\n    result = []\n    for i in range(len(test_tup) - 1):\n        result.append(test_tup[i] + test_tup[i+1])\n    return tuple(result)\n"
    ],
    "MbppEval/471": [
        "def find_remainder(arr, n):\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n\n",
        "def find_remainder(arr, n):\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n\n",
        "def find_remainder(arr, n):\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n\n",
        "def find_remainder(arr, n):\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n\n",
        "def find_remainder(arr, n):\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n\n"
    ],
    "MbppEval/472": [
        "def check_Consecutive(l):\n    is_consecutive = True\n    for i in range(1, len(l)):\n        if l[i] - l[i-1] != 1:\n            is_consecutive = False\n            break\n    return is_consecutive\n",
        "def check_Consecutive(l):\n    \"\"\"\n    Write a python function to check whether the given list contains consecutive numbers or not.\n\n    Examples:\n    check_Consecutive([1,2,3,4,5]) == True\n    check_Consecutive([1,2,3,5,6]) == False\n    check_Consecutive([1,2,1]) == False\n    \"\"\"\n    is_consecutive = True\n    for i in range(len(l) - 1):\n        if l[i+1] - l[i] != 1:\n            is_consecutive = False\n            break\n    return is_consecutive\n",
        "def check_Consecutive(l):\n    \"\"\"\n    Write a python function to check whether the given list contains consecutive numbers or not.\n\n    Examples:\n    check_Consecutive([1,2,3,4,5]) == True\n    check_Consecutive([1,2,3,5,6]) == False\n    check_Consecutive([1,2,1]) == False\n    \"\"\"\n    if len(l) < 2:\n        return True\n\n    l.sort()\n    for i in range(1, len(l)):\n        if l[i] - l[i-1] != 1:\n            return False\n    return True\n",
        "def check_Consecutive(l):\n    is_consecutive = True\n    for i in range(len(l) - 1):\n        if l[i] + 1 != l[i+1]:\n            is_consecutive = False\n            break\n    return is_consecutive\n",
        "def check_Consecutive(l):\n    is_consecutive = True\n    for i in range(len(l) - 1):\n        if l[i + 1] - l[i] != 1:\n            is_consecutive = False\n            break\n    return is_consecutive\n"
    ],
    "MbppEval/473": [
        "def tuple_intersection(test_list1, test_list2):\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n    return set1 & set2\n",
        "def tuple_intersection(test_list1, test_list2):\n    intersection_set = set()\n\n    for tup in test_list1:\n        reversed_tup = (tup[1], tup[0])\n        if tup in test_list2 or reversed_tup in test_list2:\n            intersection_set.add(tup)\n\n    for tup in test_list2:\n        reversed_tup = (tup[1], tup[0])\n        if tup in test_list1 or reversed_tup in test_list1:\n            intersection_set.add(tup)\n\n    return intersection_set\n",
        "def tuple_intersection(test_list1, test_list2):\n    tuple_set = set()\n    \n    for tup in test_list1:\n        if tup in test_list2 or (tup[1], tup[0]) in test_list2:\n            tuple_set.add(tup)\n    \n    return tuple_set\n",
        "def tuple_intersection(test_list1, test_list2):\n    intersection = set()\n    \n    for tup1 in test_list1:\n        for tup2 in test_list2:\n            if (tup1[0], tup1[1]) in [(tup2[0], tup2[1]), (tup2[1], tup2[0])]:\n                intersection.add(tuple(sorted(tup1)))\n    \n    return intersection\n",
        "def tuple_intersection(test_list1, test_list2):\n    intersection = set()\n    for tup in test_list1:\n        if tup in test_list2 or (tup[1], tup[0]) in test_list2:\n            intersection.add(tuple(sorted(tup)))\n    return intersection\n"
    ],
    "MbppEval/474": [
        "def replace_char(str1, ch, newch):\n    new_str = \"\"\n    for char in str1:\n        if char == ch:\n            new_str += newch\n        else:\n            new_str += char\n    return new_str\n",
        "def replace_char(str1, ch, newch):\n    new_str = \"\"\n    for c in str1:\n        if c == ch:\n            new_str += newch\n        else:\n            new_str += c\n    return new_str\n",
        "def replace_char(str1, ch, newch):\n    new_str = \"\"\n    for c in str1:\n        if c == ch:\n            new_str += newch\n        else:\n            new_str += c\n    return new_str\n",
        "def replace_char(str1, ch, newch):\n    new_str = \"\"\n    for char in str1:\n        if char == ch:\n            new_str += newch\n        else:\n            new_str += char\n    return new_str\n",
        "def replace_char(str1, ch, newch):\n    result = \"\"\n    for c in str1:\n        if c == ch:\n            result += newch\n        else:\n            result += c\n    return result\n"
    ],
    "MbppEval/475": [
        "from collections import Counter\n\ndef sort_counter(dict1):\n    return Counter(dict1).most_common()\n",
        "from collections import Counter\n\ndef sort_counter(dict1):\n    counter = Counter(dict1)\n    sorted_counter = counter.most_common()\n    return sorted_counter\n",
        "from collections import Counter\n\ndef sort_counter(dict1):\n    return sorted(Counter(dict1).items(), key=lambda x: x[1], reverse=True)\n",
        "from collections import Counter\n\ndef sort_counter(dict1):\n    \"\"\"\n    Write a function to sort a dictionary by value.\n\n    Examples:\n    sort_counter({'Math':81, 'Physics':83, 'Chemistry':87}) == [('Chemistry', 87), ('Physics', 83), ('Math', 81)]\n    sort_counter({'Math':400, 'Physics':300, 'Chemistry':250}) == [('Math', 400), ('Physics', 300), ('Chemistry', 250)]\n    sort_counter({'Math':900, 'Physics':1000, 'Chemistry':1250}) == [('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]\n    \"\"\"\n    counter_obj = Counter(dict1)\n    sorted_counter = sorted(counter_obj.items(), key=lambda x: x[1], reverse=True)\n    return sorted_counter\n",
        "from collections import Counter\n\ndef sort_counter(dict1):\n    counter = Counter(dict1)\n    sorted_counter = counter.most_common()\n    return sorted_counter\n"
    ],
    "MbppEval/476": [
        "def big_sum(nums):\n    smallest = min(nums)\n    largest = max(nums)\n    return smallest + largest\n",
        "def big_sum(nums):\n    smallest = min(nums)\n    largest = max(nums)\n    return smallest + largest\n",
        "def big_sum(nums):\n    smallest = min(nums)\n    largest = max(nums)\n    return smallest + largest\n",
        "def big_sum(nums):\n    smallest = min(nums)\n    largest = max(nums)\n    return smallest + largest\n",
        "def big_sum(nums):\n    smallest = min(nums)\n    largest = max(nums)\n    return smallest + largest\n"
    ],
    "MbppEval/477": [
        "def is_lower(string):\n    return string.lower()\n",
        "def is_lower(string):\n    return string.lower()\n",
        "def is_lower(string):\n    return string.lower()\n",
        "def is_lower(string):\n    return string.lower()\n",
        "def is_lower(string):\n    return string.lower()\n"
    ],
    "MbppEval/478": [
        "def remove_lowercase(str1):\n    result = \"\"\n    for char in str1:\n        if char.isupper():\n            result += char\n    return result\n",
        "import re\n\ndef remove_lowercase(str1):\n    lowercase_substrings = re.findall(r'[a-z]+', str1)\n    new_string = ''.join(char for char in str1 if char not in ''.join(lowercase_substrings))\n    return new_string\n",
        "import re\n\ndef remove_lowercase(str1):\n    pattern = r'[a-z]+'\n    result = re.sub(pattern, '', str1)\n    return result\n",
        "import re\n\ndef remove_lowercase(str1):\n    pattern = r'[a-z]+'\n    return re.sub(pattern, '', str1)\n",
        "import re\n\ndef remove_lowercase(str1):\n    pattern = r'[a-z]+'\n    result = re.sub(pattern, '', str1)\n    return result\n"
    ],
    "MbppEval/479": [
        "def first_Digit(n):\n    num_str = str(n)\n    first_digit = int(num_str[0])\n    return first_digit\n",
        "def first_Digit(n):\n    num_str = str(n)\n    first_digit = int(num_str[0])\n    return first_digit\n",
        "def first_Digit(n):\n    n_str = str(n)\n    first_digit = int(n_str[0])\n    return first_digit\n",
        "def first_digit(n):\n    return int(str(n)[0])\n",
        "def first_Digit(n):\n    num_str = str(n)\n    return int(num_str[0])\n"
    ],
    "MbppEval/554": [
        "def Split(list_of_ints):\n    odd_numbers = []\n    for num in list_of_ints:\n        if num % 2 != 0:\n            odd_numbers.append(num)\n    return odd_numbers\n",
        "def Split(list_of_integers):\n    odd_numbers = []\n    for num in list_of_integers:\n        if num % 2 != 0:\n            odd_numbers.append(num)\n    return odd_numbers\n",
        "def Split(list_of_integers):\n    odd_numbers = []\n    for num in list_of_integers:\n        if num % 2 != 0:\n            odd_numbers.append(num)\n    return odd_numbers\n",
        "def Split(list_of_integers):\n    odd_numbers = []\n    for num in list_of_integers:\n        if num % 2 != 0:\n            odd_numbers.append(num)\n    return odd_numbers\n",
        "def Split(lst):\n    return [num for num in lst if num % 2 != 0]\n"
    ],
    "MbppEval/555": [
        "def difference(n):\n    sum_cubes = sum(i**3 for i in range(1, n+1))\n    sum_numbers = sum(range(1, n+1))\n    return sum_cubes - sum_numbers\n",
        "def difference(n):\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    sum_of_numbers = sum(range(1, n+1))\n    return sum_of_cubes - sum_of_numbers\n",
        "def difference(n):\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    sum_of_numbers = sum(range(1, n+1))\n    return sum_of_cubes - sum_of_numbers\n",
        "def difference(n):\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    sum_of_numbers = sum(range(1, n+1))\n    return sum_of_cubes - sum_of_numbers\n",
        "def difference(n):\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    sum_of_numbers = sum(range(1, n+1))\n    return sum_of_cubes - sum_of_numbers\n"
    ],
    "MbppEval/556": [
        "def find_Odd_Pair(A, N):\n    odd_count = 0\n    for num in A:\n        if num % 2 == 1:\n            odd_count += 1\n    return odd_count * (N - odd_count)\n",
        "def find_Odd_Pair(A, N):\n    even_count = 0\n    odd_count = 0\n    \n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return even_count * odd_count\n",
        "def find_Odd_Pair(A, N):\n    odd_count = 0\n    even_count = 0\n    \n    for num in A:\n        if num % 2 == 1:\n            odd_count += 1\n        else:\n            even_count += 1\n    \n    return odd_count * even_count\n",
        "def find_Odd_Pair(A, N):\n    count = 0\n    for num in A:\n        if count_set_bits(num) % 2 == 1:\n            count += N - 1\n    return count\n\ndef count_set_bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n",
        "def find_Odd_Pair(A, N):\n    count = 0\n    for i in range(N):\n        if A[i] % 2 == 1:\n            count += (N - i - 1)\n    return count\n"
    ],
    "MbppEval/557": [
        "def toggle_string(string):\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char.lower()\n        else:\n            result += char.upper()\n    return result\n",
        "def toggle_string(string):\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char.lower()\n        else:\n            result += char.upper()\n    return result\n",
        "def toggle_string(string):\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char.lower()\n        else:\n            result += char.upper()\n    return result\n",
        "def toggle_string(string):\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char.lower()\n        else:\n            result += char.upper()\n    return result\n",
        "def toggle_string(string):\n    new_string = \"\"\n    for char in string:\n        if char.isupper():\n            new_string += char.lower()\n        else:\n            new_string += char.upper()\n    return new_string\n"
    ],
    "MbppEval/558": [
        "def digit_distance_nums(n1, n2):\n    n1_str = str(n1)\n    n2_str = str(n2)\n    total_distance = 0\n    for i in range(max(len(n1_str), len(n2_str))):\n        d1 = int(n1_str[i]) if i < len(n1_str) else 0\n        d2 = int(n2_str[i]) if i < len(n2_str) else 0\n        total_distance += abs(d1 - d2)\n    return total_distance\n",
        "def digit_distance_nums(n1, n2):\n    n1_str = str(n1)\n    n2_str = str(n2)\n\n    total_diff = 0\n\n    for i in range(max(len(n1_str), len(n2_str))):\n        d1 = int(n1_str[i]) if i < len(n1_str) else 0\n        d2 = int(n2_str[i]) if i < len(n2_str) else 0\n\n        total_diff += abs(d1 - d2)\n\n    return total_diff\n",
        "def digit_distance_nums(n1, n2):\n    \"\"\"\n    Write a python function to find the sum of the per-digit difference between two integers.\n\n    Examples:\n    digit_distance_nums(1,2) == 1\n    digit_distance_nums(23,56) == 6\n    digit_distance_nums(123,256) == 7\n    \"\"\"\n    n1_str = str(n1)\n    n2_str = str(n2)\n\n    distance = 0\n\n    for i in range(max(len(n1_str), len(n2_str))):\n        d1 = int(n1_str[i]) if i < len(n1_str) else 0\n        d2 = int(n2_str[i]) if i < len(n2_str) else 0\n        distance += abs(d1 - d2)\n\n    return distance\n",
        "def digit_distance_nums(n1, n2):\n    max_len = max(len(str(n1)), len(str(n2)))\n    n1_str = str(n1).zfill(max_len)\n    n2_str = str(n2).zfill(max_len)\n    total_distance = 0\n    for i in range(max_len):\n        total_distance += abs(int(n1_str[i]) - int(n2_str[i]))\n    return total_distance\n",
        "def digit_distance_nums(n1, n2):\n    n1_str = str(n1)\n    n2_str = str(n2)\n    \n    total_diff = 0\n    \n    # Iterate through the digits\n    for i in range(max(len(n1_str), len(n2_str))):\n        # Get the digits at the same position\n        d1 = int(n1_str[i]) if i < len(n1_str) else 0\n        d2 = int(n2_str[i]) if i < len(n2_str) else 0\n        \n        # Calculate the absolute difference and add it to the total\n        total_diff += abs(d1 - d2)\n    \n    return total_diff\n"
    ],
    "MbppEval/559": [
        "def max_sub_array_sum(a, size):\n    max_sum = a[0]\n    current_sum = a[0]\n\n    for i in range(1, size):\n        current_sum = max(a[i], current_sum + a[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n",
        "def max_sub_array_sum(a, size):\n    max_so_far = a[0]\n    max_ending_here = a[0]\n\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n",
        "def max_sub_array_sum(a, size):\n    max_sum = a[0]\n    current_sum = a[0]\n    \n    for i in range(1, size):\n        current_sum = max(a[i], current_sum + a[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n",
        "def max_sub_array_sum(a, size):\n    max_sum = a[0]\n    current_sum = a[0]\n\n    for i in range(1, size):\n        current_sum = max(a[i], current_sum + a[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n",
        "def max_sub_array_sum(a, size):\n    max_sum = a[0]\n    current_sum = a[0]\n\n    for i in range(1, size):\n        current_sum = max(a[i], current_sum + a[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n"
    ],
    "MbppEval/560": [
        "def union_elements(test_tup1, test_tup2):\n    combined_list = list(test_tup1) + list(test_tup2)\n    unique_list = list(set(combined_list))\n    sorted_list = sorted(unique_list)\n    return tuple(sorted_list)\n",
        "def union_elements(test_tup1, test_tup2):\n    return tuple(sorted(set(list(test_tup1) + list(test_tup2))))\n",
        "def union_elements(test_tup1, test_tup2):\n    return tuple(sorted(set(test_tup1) | set(test_tup2)))\n",
        "def union_elements(test_tup1, test_tup2):\n    return tuple(sorted(set(test_tup1 + test_tup2)))\n",
        "def union_elements(test_tup1, test_tup2):\n    \"\"\"\n    Write a function to find the union of the elements of two given tuples and output them in sorted order.\n\n    Examples:\n    union_elements((3, 4, 5, 6),(5, 7, 4, 10)) == (3, 4, 5, 6, 7, 10)\n    union_elements((1, 2, 3, 4),(3, 4, 5, 6)) == (1, 2, 3, 4, 5, 6)\n    union_elements((11, 12, 13, 14),(13, 15, 16, 17)) == (11, 12, 13, 14, 15, 16, 17)\n    \"\"\"\n    combined_list = list(test_tup1) + list(test_tup2)\n    unique_list = list(set(combined_list))\n    sorted_list = sorted(unique_list)\n    return tuple(sorted_list)\n"
    ],
    "MbppEval/562": [
        "def Find_Max_Length(lst):\n    max_length = 0\n    for sublst in lst:\n        current_length = len(sublst)\n        if current_length > max_length:\n            max_length = current_length\n    return max_length\n",
        "def Find_Max_Length(lst):\n    max_length = 0\n    for sublst in lst:\n        current_length = len(sublst)\n        if current_length > max_length:\n            max_length = current_length\n    return max_length\n",
        "def Find_Max_Length(lst):\n    max_length = 0\n    for sublst in lst:\n        current_length = len(sublst)\n        if current_length > max_length:\n            max_length = current_length\n    return max_length\n",
        "def Find_Max_Length(lst):\n    max_length = 0\n    for sublst in lst:\n        current_length = len(sublst)\n        if current_length > max_length:\n            max_length = current_length\n    return max_length\n",
        "def Find_Max_Length(lst):\n    \"\"\"\n    Write a python function to find the length of the longest sublists.\n\n    Examples:\n    Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4\n    Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3\n    Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5\n    Find_Max_Length([]) == 0\n    Find_Max_Length([[]]) == 0\n    \"\"\"\n    if not lst:\n        return 0\n    \n    max_length = len(lst[0])\n    \n    for sublst in lst:\n        curr_length = len(sublst)\n        if curr_length > max_length:\n            max_length = curr_length\n    \n    return max_length\n"
    ],
    "MbppEval/563": [
        "import re\n\ndef extract_values(text):\n    return re.findall(r'\"([^\"]*)\"', text)\n",
        "import re\n\ndef extract_values(text):\n    values = re.findall(r'\"(.*?)\"', text)\n    return values\n",
        "import re\n\ndef extract_values(text):\n    values = re.findall(r'\"([^\"]*)\"', text)\n    return values\n",
        "import re\n\ndef extract_values(text):\n    return re.findall(r'\"([^\"]*)\"', text)\n",
        "import re\n\ndef extract_values(text):\n    values = re.findall(r'\"(.*?)\"', text)\n    values = [value.strip() for value in values]\n    return values\n"
    ],
    "MbppEval/564": [
        "def count_Pairs(arr, n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count\n",
        "def count_Pairs(arr, n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count\n",
        "def count_Pairs(arr, n):\n    unique_elements = set(arr)\n    return n * (n - 1) // 2 - len(unique_elements)\n",
        "def count_Pairs(arr, n):\n    element_counts = {}\n    for num in arr:\n        if num in element_counts:\n            element_counts[num] += 1\n        else:\n            element_counts[num] = 1\n    \n    total_pairs = 0\n    for count in element_counts.values():\n        total_pairs += count * (n - count)\n    \n    return total_pairs // 2\n",
        "def count_Pairs(arr, n):\n    if n < 2:\n        return 0\n    return n * (n-1) // 2\n"
    ],
    "MbppEval/565": [
        "def split(word):\n    characters = []\n    for char in word:\n        characters.append(char)\n    return characters\n",
        "def split(word):\n    characters = []\n    for char in word:\n        characters.append(char)\n    return characters\n",
        "def split(word):\n    chars = []\n    for char in word:\n        chars.append(char)\n    return chars\n",
        "def split(word):\n    return list(word)\n",
        "def split(word):\n    return list(word)\n"
    ],
    "MbppEval/566": [
        "def sum_digits(n):\n    total = 0\n    for digit in str(n):\n        total += int(digit)\n    return total\n",
        "def sum_digits(n):\n    total = 0\n    for digit in str(n):\n        total += int(digit)\n    return total\n",
        "def sum_digits(n):\n    total_sum = 0\n    for digit in str(n):\n        total_sum += int(digit)\n    return total_sum\n",
        "def sum_digits(n):\n    total = 0\n    for digit in str(n):\n        total += int(digit)\n    return total\n",
        "def sum_digits(n):\n    total = 0\n    while n > 0:\n        digit = n % 10\n        total += digit\n        n //= 10\n    return total\n"
    ],
    "MbppEval/567": [
        "def issort_list(list1):\n    is_sorted = True\n    for i in range(len(list1) - 1):\n        if list1[i] > list1[i+1]:\n            is_sorted = False\n            break\n    return is_sorted\n",
        "def issort_list(list1):\n    return all(list1[i] <= list1[i+1] for i in range(len(list1) - 1))\n",
        "def issort_list(list1):\n    is_sorted = True\n    for i in range(len(list1) - 1):\n        if list1[i] > list1[i + 1]:\n            is_sorted = False\n            break\n    return is_sorted\n",
        "def issort_list(list1):\n    is_sorted = True\n    for i in range(1, len(list1)):\n        if list1[i] < list1[i-1]:\n            is_sorted = False\n            break\n    return is_sorted\n",
        "def issort_list(list1):\n    is_sorted = True\n    for i in range(1, len(list1)):\n        if list1[i] < list1[i-1]:\n            is_sorted = False\n            break\n    return is_sorted\n"
    ],
    "MbppEval/568": [
        "def empty_list(length):\n    \"\"\"\n    Write a function to create a list of N empty dictionaries.\n\n    Examples:\n    empty_list(5) == [{},{},{},{},{}]\n    empty_list(6) == [{},{},{},{},{},{}]\n    empty_list(7) == [{},{},{},{},{},{},{}]\n    \"\"\"\n    empty_dicts = []\n    for _ in range(length):\n        empty_dicts.append({})\n    return empty_dicts\n",
        "def empty_list(length):\n    return [{} for _ in range(length)]\n",
        "def empty_list(length):\n    result = [{} for _ in range(length)]\n    return result\n",
        "def empty_list(length):\n    \"\"\"\n    Write a function to create a list of N empty dictionaries.\n\n    Examples:\n    empty_list(5) == [{}, {}, {}, {}, {}]\n    empty_list(6) == [{}, {}, {}, {}, {}, {}]\n    empty_list(7) == [{}, {}, {}, {}, {}, {}, {}]\n    \"\"\"\n    return [{} for _ in range(length)]\n",
        "def empty_list(length):\n    \"\"\"\n    Write a function to create a list of N empty dictionaries.\n\n    Examples:\n    empty_list(5) == [{}, {}, {}, {}, {}]\n    empty_list(6) == [{}, {}, {}, {}, {}, {}]\n    empty_list(7) == [{}, {}, {}, {}, {}, {}, {}]\n    \"\"\"\n    empty_dicts = []\n    for _ in range(length):\n        empty_dicts.append({})\n    return empty_dicts\n"
    ],
    "MbppEval/569": [
        "def sort_sublists(list1):\n    sorted_sublists = []\n    for sublist in list1:\n        sorted_sublists.append(sorted(sublist))\n    return sorted_sublists\n",
        "def sort_sublists(list1):\n    sorted_list = []\n    for sublist in list1:\n        sorted_list.append(sorted(sublist))\n    return sorted_list\n",
        "def sort_sublists(list1):\n    sorted_list = []\n    for sub_list in list1:\n        sorted_sub_list = sorted(sub_list)\n        sorted_list.append(sorted_sub_list)\n    return sorted_list\n",
        "def sort_sublists(list1):\n    result = []\n    for sublist in list1:\n        result.append(sorted(sublist))\n    return result\n",
        "def sort_sublists(list1):\n    sorted_sublists = []\n    for sublist in list1:\n        sorted_sublists.append(sorted(sublist))\n    return sorted_sublists\n"
    ],
    "MbppEval/572": [
        "def two_unique_nums(nums):\n    unique_nums = set(nums)\n    return list(unique_nums)\n",
        "def two_unique_nums(nums):\n    return list(set(nums))\n",
        "def two_unique_nums(nums):\n    unique_nums = set()\n    for num in nums:\n        unique_nums.add(num)\n    return list(unique_nums)\n",
        "def two_unique_nums(nums):\n    \"\"\"\n    Write a python function to remove duplicate numbers from a given number of lists.\n\n    Examples:\n    two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]\n    two_unique_nums([1,2,3,2,4,5]) == [1, 3, 4, 5]\n    two_unique_nums([1,2,3,4,5]) == [1, 2, 3, 4, 5]\n    \"\"\"\n    unique_nums = []\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums\n",
        "def two_unique_nums(nums):\n    unique_nums = set()\n    for num in nums:\n        unique_nums.add(num)\n    return list(unique_nums)\n"
    ],
    "MbppEval/573": [
        "def unique_product(list_data):\n    product = 1\n    unique_nums = set()\n\n    for num in list_data:\n        if num not in unique_nums:\n            unique_nums.add(num)\n            product *= num\n\n    return product\n",
        "def unique_product(list_data):\n    unique_nums = set()\n    for num in list_data:\n        unique_nums.add(num)\n    \n    product = 1\n    for num in unique_nums:\n        product *= num\n    \n    return product\n",
        "def unique_product(list_data):\n    unique_nums = set()\n    product = 1\n    \n    for num in list_data:\n        if num not in unique_nums:\n            unique_nums.add(num)\n            product *= num\n    \n    return product\n",
        "def unique_product(list_data):\n    product = 1\n    unique_nums = set(list_data)\n    for num in unique_nums:\n        product *= num\n    return product\n",
        "def unique_product(list_data):\n    product = 1\n    unique_nums = set()\n    \n    for num in list_data:\n        if num not in unique_nums:\n            unique_nums.add(num)\n            product *= num\n    \n    return product\n"
    ],
    "MbppEval/574": [
        "import math\n\ndef surfacearea_cylinder(r, h):\n    \"\"\"\n    Write a function to find the surface area of a cylinder.\n\n    Examples:\n    surfacearea_cylinder(10, 5) == 942.4784176044735\n    surfacearea_cylinder(4, 5) == 226.18800000000002\n    surfacearea_cylinder(4, 10) == 351.848\n    \"\"\"\n    surface_area = 2 * math.pi * r * (r + h)\n    return surface_area\n",
        "import math\n\ndef surfacearea_cylinder(r, h):\n    \"\"\"\n    Write a function to find the surface area of a cylinder.\n\n    Examples:\n    surfacearea_cylinder(10, 5) == 942.45\n    surfacearea_cylinder(4, 5) == 226.18\n    surfacearea_cylinder(4, 10) == 351.85\n    \"\"\"\n    surface_area = 2 * math.pi * r * (r + h)\n    return round(surface_area, 2)\n",
        "import math\n\ndef surfacearea_cylinder(r, h):\n    surface_area = 2 * math.pi * r * (r + h)\n    return round(surface_area, 2)\n",
        "import math\n\ndef surfacearea_cylinder(r, h):\n    surface_area = 2 * math.pi * r**2 + 2 * math.pi * r * h\n    return round(surface_area, 5)\n",
        "import math\n\ndef surfacearea_cylinder(r, h):\n    surface_area = 2 * math.pi * r**2 + 2 * math.pi * r * h\n    return round(surface_area, 5)\n"
    ],
    "MbppEval/576": [
        "def is_Sub_Array(A, B):\n    i = 0\n    j = 0\n    \n    for _ in range(len(A)):\n        if A[i] == B[j]:\n            i += 1\n            j += 1\n            if j == len(B):\n                return True\n        else:\n            i += 1\n    \n    return False\n",
        "def is_Sub_Array(A, B):\n    i, j = 0, 0\n    while i < len(A) and j < len(B):\n        if A[i] == B[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n        if j == len(B):\n            return True\n    return False\n",
        "def is_Sub_Array(A, B):\n    i, j = 0, 0\n    while i < len(A) and j < len(B):\n        if A[i] == B[j]:\n            i += 1\n            j += 1\n            if j == len(B):\n                return True\n        else:\n            i += 1\n    return False\n",
        "def is_Sub_Array(A, B):\n    i, j = 0, 0\n    while i < len(A) and j < len(B):\n        if A[i] == B[j]:\n            j += 1\n            if j == len(B):\n                return True\n        else:\n            j = 0\n        i += 1\n    return False\n",
        "def is_Sub_Array(A, B):\n    i, j = 0, 0\n    while i < len(A) and j < len(B):\n        if A[i] == B[j]:\n            i += 1\n            j += 1\n            if j == len(B):\n                return True\n        else:\n            i += 1\n            j = 0\n    return False\n"
    ],
    "MbppEval/577": [
        "def last_Digit_Factorial(n):\n    factorial = 1\n    for i in range(1, n+1):\n        factorial *= i\n    return factorial % 10\n",
        "def last_Digit_Factorial(n):\n    \"\"\"\n    Write a python function to find the last digit in factorial of a given number.\n\n    Examples:\n    last_Digit_Factorial(4) == 4\n    last_Digit_Factorial(21) == 0\n    last_Digit_Factorial(30) == 0\n    \"\"\"\n    if n == 0:\n        return 1\n\n    last_digits = [1, 1, 2, 6, 4, 2, 2, 4, 2, 8]\n    return last_digits[n % 10]\n",
        "def last_Digit_Factorial(n):\n    last_digit_cycle = [1, 2, 6, 4]\n    return last_digit_cycle[n % 4]\n",
        "def last_Digit_Factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result % 10\n",
        "def last_Digit_Factorial(n):\n    factorial = 1\n    for i in range(1, n+1):\n        factorial *= i\n    return factorial % 10\n"
    ],
    "MbppEval/578": [
        "def interleave_lists(list1, list2, list3):\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        return []\n\n    interleaved_list = []\n\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n\n    return interleaved_list\n",
        "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for x, y, z in zip(list1, list2, list3):\n        interleaved_list.append(x)\n        interleaved_list.append(y)\n        interleaved_list.append(z)\n    return interleaved_list\n",
        "def interleave_lists(list1, list2, list3):\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        return []\n\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n\n    return result\n",
        "def interleave_lists(list1, list2, list3):\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        return []\n\n    interleaved_list = []\n\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n\n    return interleaved_list\n",
        "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Write a function to interleave 3 lists of the same length into a single flat list.\n    \"\"\"\n    # Check if the input lists have the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        return []\n\n    # Initialize the result list\n    result = []\n\n    # Interleave the lists\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n\n    return result\n"
    ],
    "MbppEval/579": [
        "def find_dissimilar(test_tup1, test_tup2):\n    dissimilar = []\n    for element in test_tup1:\n        if element not in test_tup2:\n            dissimilar.append(element)\n    for element in test_tup2:\n        if element not in test_tup1:\n            dissimilar.append(element)\n    return dissimilar\n",
        "def find_dissimilar(test_tup1, test_tup2):\n    dissimilar_elements = set()\n    \n    for element in test_tup1:\n        if element not in test_tup2:\n            dissimilar_elements.add(element)\n            \n    for element in test_tup2:\n        if element not in test_tup1:\n            dissimilar_elements.add(element)\n            \n    return tuple(dissimilar_elements)\n",
        "def find_dissimilar(test_tup1, test_tup2):\n    dissimilar_elements = set()\n    \n    for element in test_tup1:\n        if element not in test_tup2:\n            dissimilar_elements.add(element)\n    \n    for element in test_tup2:\n        if element not in test_tup1:\n            dissimilar_elements.add(element)\n    \n    return tuple(dissimilar_elements)\n",
        "def find_dissimilar(test_tup1, test_tup2):\n    dissimilar = set()\n    \n    # Find elements in test_tup1 that are not in test_tup2\n    for elem in test_tup1:\n        if elem not in test_tup2:\n            dissimilar.add(elem)\n    \n    # Find elements in test_tup2 that are not in test_tup1\n    for elem in test_tup2:\n        if elem not in test_tup1:\n            dissimilar.add(elem)\n    \n    return tuple(dissimilar)\n",
        "def find_dissimilar(test_tup1, test_tup2):\n    dissimilar_set = set()\n    \n    for element in test_tup1:\n        if element not in test_tup2:\n            dissimilar_set.add(element)\n    \n    for element in test_tup2:\n        if element not in test_tup1:\n            dissimilar_set.add(element)\n    \n    return tuple(dissimilar_set)\n"
    ],
    "MbppEval/580": [
        "def even_ele(test_tuple, even_fnc):\n    result = []\n    for element in test_tuple:\n        if isinstance(element, tuple):\n            result.append(even_ele(element, even_fnc))\n        elif even_fnc(element):\n            result.append(element)\n    return tuple(result)\n",
        "def even_ele(test_tuple, even_fnc):\n    even_list = []\n    for element in test_tuple:\n        if isinstance(element, tuple):\n            even_list.append(even_ele(element, even_fnc))\n        elif even_fnc(element):\n            even_list.append(element)\n    return tuple(even_list)\n",
        "def even_ele(test_tuple, even_fnc):\n    result = ()\n    for element in test_tuple:\n        if isinstance(element, tuple):\n            result += (even_ele(element, even_fnc),)\n        elif even_fnc(element):\n            result += (element,)\n    return result\n",
        "def even_ele(test_tuple, even_fnc):\n    result = []\n    for elem in test_tuple:\n        if isinstance(elem, tuple):\n            result.append(even_ele(elem, even_fnc))\n        elif even_fnc(elem):\n            result.append(elem)\n    return tuple(result)\n",
        "def even_ele(test_tuple, even_fnc):\n    def is_even(x):\n        return even_fnc(x)\n\n    new_tuple = ()\n    for element in test_tuple:\n        if isinstance(element, tuple):\n            new_tuple += (even_ele(element, even_fnc),)\n        elif is_even(element):\n            new_tuple += (element,)\n    return new_tuple\n"
    ],
    "MbppEval/581": [
        "def surface_area(b, s):\n    base_area = b * b\n    face_area = 0.5 * b * s\n    total_area = base_area + 4 * face_area\n    return total_area\n",
        "def surface_Area(b, s):\n    base_area = b ** 2\n    slant_area = 0.5 * b * s\n    surface_area = base_area + 4 * slant_area\n    return surface_area\n",
        "def surface_Area(b, s):\n    base_area = b ** 2\n    face_area = 4 * ((b * s) / 2)\n    total_area = base_area + face_area\n    return total_area\n",
        "def surface_Area(b, s):\n    base_area = b ** 2\n    slant_area = 0.5 * b * s\n    surface_area = base_area + 4 * slant_area\n    return surface_area\n",
        "def surface_Area(b, h):\n    surface_area = b**2 + 2 * b * h\n    return surface_area\n"
    ],
    "MbppEval/582": [
        "def my_dict(dict1):\n    \"\"\"\n    Write a function to check if a dictionary is empty.\n\n    Examples:\n    my_dict({10}) == False\n    my_dict({11}) == False\n    my_dict({}) == True\n    \"\"\"\n    return not bool(dict1)\n",
        "def my_dict(dict1):\n    return not dict1\n",
        "def my_dict(dict1):\n    if len(dict1) == 0:\n        return True\n    else:\n        return False\n",
        "def my_dict(dict1):\n    return len(dict1) == 0\n",
        "def my_dict(dict1):\n    \"\"\"\n    Write a function to check if a dictionary is empty.\n\n    Examples:\n    my_dict({10}) == False\n    my_dict({11}) == False\n    my_dict({}) == True\n    \"\"\"\n    return bool(dict1)\n"
    ],
    "MbppEval/583": [
        "import math\n\ndef catalan_number(num):\n    \"\"\"\n    Write a function which returns nth catalan number.\n\n    Examples:\n    catalan_number(10) == 16796\n    catalan_number(9) == 4862\n    catalan_number(7) == 429\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n\n    # Calculate the binomial coefficient (2*n)! / (n! * n!)\n    numerator = math.factorial(2 * num)\n    denominator = math.factorial(num) * math.factorial(num)\n    binomial_coeff = numerator // denominator\n\n    # Calculate the nth Catalan number\n    catalan_num = binomial_coeff // (num + 1)\n    return catalan_num\n",
        "from math import gamma\n\ndef catalan_number(num):\n    \"\"\"\n    Returns the nth Catalan number.\n    \"\"\"\n    numerator = gamma(2 * num + 1)\n    denominator = gamma(num + 1) * gamma(num + 1)\n    return int(numerator / denominator)\n",
        "def catalan_number(num):\n    \"\"\"\n    Returns the nth Catalan number.\n\n    Args:\n        num (int): The index of the Catalan number to calculate.\n\n    Returns:\n        int: The nth Catalan number.\n    \"\"\"\n    def factorial(n):\n        \"\"\"Helper function to calculate the factorial of a number.\"\"\"\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n\n    numerator = factorial(2*num)\n    denominator = factorial(num+1) * factorial(num)\n    return numerator // denominator\n",
        "from math import factorial\n\ndef catalan_number(n):\n    \"\"\"\n    Returns the nth Catalan number.\n    \n    Args:\n        n (int): The index of the Catalan number to be calculated.\n        \n    Returns:\n        int: The nth Catalan number.\n    \"\"\"\n    return factorial(2 * n) // (factorial(n + 1) * factorial(n))\n",
        "def catalan_number(num):\n    dp = [0] * (num + 1)\n    dp[0] = 1\n    for i in range(1, num + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n    return dp[num]\n"
    ],
    "MbppEval/584": [
        "import re\n\ndef find_adverbs(text):\n    pattern = r'\\w+ly'\n    match = re.search(pattern, text)\n    if match:\n        start = match.start()\n        end = match.end()\n        adverb = match.group()\n        return f'{start}-{end}: {adverb}'\n    else:\n        return None\n",
        "import re\n\ndef find_adverbs(text):\n    pattern = r'\\w+ly'\n    match = re.search(pattern, text)\n    if match:\n        adverb = match.group()\n        start = match.start()\n        end = match.end()\n        return f\"{start}-{end}: {adverb}\"\n    else:\n        return \"\"\n",
        "import re\n\ndef find_adverbs(text):\n    pattern = r'\\w+ly'\n    match = re.search(pattern, text)\n    if match:\n        adverb = match.group()\n        start = match.start()\n        end = match.end()\n        return f\"{start}-{end}: {adverb}\"\n    else:\n        return None\n",
        "import re\n\ndef find_adverbs(text):\n    pattern = r'\\w+ly'\n    match = re.search(pattern, text)\n    if match:\n        adverb = match.group()\n        start = match.start()\n        end = match.end()\n        return f\"{start}-{end}: {adverb}\"\n    else:\n        return \"\"\n",
        "import re\n\ndef find_adverbs(text):\n    match = re.search(r'\\w+ly', text)\n    if match:\n        start = match.start()\n        end = match.end()\n        return f\"{start}-{end}: {match.group()}\"\n    else:\n        return \"\"\n"
    ],
    "MbppEval/585": [
        "import heapq\n\ndef expensive_items(items, n):\n    \"\"\"\n    Find the n most expensive items in a given dataset.\n    \"\"\"\n    # Create a max heap to store the n most expensive items\n    heap = [(-item['price'], item) for item in items]\n    heapq.heapify(heap)\n\n    # Extract the n most expensive items from the heap\n    return [heapq.heappop(heap)[1] for _ in range(min(n, len(heap)))]\n",
        "import heapq\n\ndef expensive_items(items, n):\n    price_items = [(item['price'], item) for item in items]\n    most_expensive = [item[1] for item in heapq.nlargest(n, price_items)]\n    return most_expensive\n",
        "import heapq\n\ndef expensive_items(items, n):\n    \"\"\"\n    Find the n most expensive items in a given dataset.\n    \"\"\"\n    # Create a max heap to store the n most expensive items\n    heap = []\n\n    # Iterate through the items and update the heap\n    for item in items:\n        if len(heap) < n:\n            heapq.heappush(heap, (-item['price'], item))\n        elif -heap[0][0] < item['price']:\n            heapq.heappop(heap)\n            heapq.heappush(heap, (-item['price'], item))\n\n    # Return the n most expensive items\n    return [item for _, item in heap]\n",
        "import heapq\n\ndef expensive_items(items, n):\n    \"\"\"\n    Find the n most expensive items in a given dataset.\n\n    Args:\n        items (list): A list of dictionaries, where each dictionary represents an item with keys 'name' and 'price'.\n        n (int): The number of most expensive items to return.\n\n    Returns:\n        list: A list of the n most expensive items.\n    \"\"\"\n    # Create a max-heap of the items, sorted by price in descending order\n    heap = [(-item['price'], item) for item in items]\n    heapq.heapify(heap)\n\n    # Get the n most expensive items (the n items with the highest prices)\n    result = [heapq.heappop(heap)[1] for _ in range(n)]\n\n    return result\n",
        "import heapq\n\ndef expensive_items(items, n):\n    most_expensive = []\n\n    for item in items:\n        if len(most_expensive) < n:\n            heapq.heappush(most_expensive, (item['price'], item))\n        elif item['price'] > most_expensive[0][0]:\n            heapq.heappop(most_expensive)\n            heapq.heappush(most_expensive, (item['price'], item))\n\n    return [item[1] for item in most_expensive]\n"
    ],
    "MbppEval/586": [
        "def split_Arr(l, n):\n    first_part = l[:n]\n    second_part = l[n:]\n    modified_list = second_part + first_part\n    return modified_list\n",
        "def split_Arr(l, n):\n    \"\"\"\n    Write a python function to split a list at the nth element and add the first part to the end.\n\n    Examples:\n    split_Arr([12,10,5,6,52,36],6,2) == [5,6,52,36,12,10]\n    split_Arr([1,2,3,4],4,1) == [2,3,4,1]\n    split_Arr([0,1,2,3,4,5,6,7],8,3) == [3,4,5,6,7,0,1,2]\n    \"\"\"\n    if n < 0 or n > len(l):\n        return l\n    \n    first_part = l[:n]\n    second_part = l[n:]\n    \n    return second_part + first_part\n",
        "def split_Arr(l, n):\n    return l[n:] + l[:n]\n",
        "def split_Arr(l, n):\n    length = len(l)\n    if n < 0 or n >= length:\n        return l\n    return l[n:] + l[:n]\n",
        "def split_Arr(l, n):\n    first_part = l[:n]\n    second_part = l[n:]\n    return second_part + first_part\n"
    ],
    "MbppEval/587": [
        "def list_tuple(listx):\n    return tuple(listx)\n",
        "def list_tuple(listx):\n    return tuple(listx)\n",
        "def list_tuple(listx):\n    return tuple(listx)\n",
        "def list_tuple(listx):\n    return tuple(listx)\n",
        "def list_tuple(listx):\n    return tuple(listx)\n"
    ],
    "MbppEval/588": [
        "def big_diff(nums):\n    if not nums:\n        return 0\n    \n    largest = max(nums)\n    smallest = min(nums)\n    \n    return largest - smallest\n",
        "def big_diff(nums):\n    max_num = max(nums)\n    min_num = min(nums)\n    return max_num - min_num\n",
        "def big_diff(nums):\n    max_num = max(nums)\n    min_num = min(nums)\n    return max_num - min_num\n",
        "def big_diff(nums):\n    largest = max(nums)\n    smallest = min(nums)\n    return largest - smallest\n",
        "def big_diff(nums):\n    largest = max(nums)\n    smallest = min(nums)\n    return largest - smallest\n"
    ],
    "MbppEval/589": [
        "import math\n\ndef perfect_squares(a, b):\n    start = math.ceil(math.sqrt(a))\n    end = math.floor(math.sqrt(b))\n    return [num**2 for num in range(start, end+1)]\n",
        "import math\n\ndef perfect_squares(a, b):\n    \"\"\"\n    Write a function to find perfect squares between two given numbers.\n\n    Examples:\n    perfect_squares(1,30) == [1, 4, 9, 16, 25]\n    perfect_squares(50,100) == [64, 81, 100]\n    perfect_squares(100,200) == [100, 121, 144, 169, 196]\n    \"\"\"\n    if not (isinstance(a, int) and isinstance(b, int) and a > 0 and b > 0):\n        raise ValueError(\"a and b must be positive integers\")\n\n    perfect_squares_list = []\n\n    for num in range(a, b+1):\n        sqrt = math.sqrt(num)\n        if sqrt.is_integer():\n            perfect_squares_list.append(num)\n\n    return perfect_squares_list\n",
        "import math\n\ndef perfect_squares(a, b):\n    perfect_squares_list = []\n\n    for num in range(a, b + 1):\n        if int(math.sqrt(num)) ** 2 == num:\n            perfect_squares_list.append(num)\n\n    return perfect_squares_list\n",
        "import math\n\ndef perfect_squares(a, b):\n    perfect_squares_list = []\n    for num in range(a, b + 1):\n        if int(math.sqrt(num)) ** 2 == num:\n            perfect_squares_list.append(num)\n    return perfect_squares_list\n",
        "import math\n\ndef perfect_squares(a, b):\n    perfect_squares_list = []\n    for num in range(a, b+1):\n        sqrt = math.sqrt(num)\n        if sqrt.is_integer():\n            perfect_squares_list.append(int(sqrt) ** 2)\n    return perfect_squares_list\n"
    ],
    "MbppEval/590": [
        "import cmath\n\ndef polar_rect(x, y):\n    r = (x**2 + y**2) ** 0.5\n    theta = cmath.atan2(y, x)\n    return (r, theta), complex(r * cmath.cos(theta), r * cmath.sin(theta))\n",
        "import cmath\n\ndef polar_rect(x, y):\n    r = (x ** 2 + y ** 2) ** 0.5\n    theta = cmath.atan2(y, x)\n    real = r * cmath.cos(theta)\n    imag = r * cmath.sin(theta)\n    return (real, imag), complex(real, imag)\n",
        "import cmath\n\ndef polar_rect(x, y):\n    r = cmath.sqrt(x**2 + y**2)\n    theta = cmath.atan2(y, x)\n    x_rect = r * cmath.cos(theta)\n    y_rect = r * cmath.sin(theta)\n    return ((x_rect, y_rect), complex(x_rect, y_rect))\n",
        "import cmath\n\ndef polar_rect(x, y):\n    r = (x**2 + y**2) ** 0.5\n    theta = cmath.atan2(y, x)\n    a = r * cmath.cos(theta)\n    b = r * cmath.sin(theta)\n    return ((r, theta), complex(a, b))\n",
        "import cmath\n\ndef polar_rect(x, y):\n    r = (x**2 + y**2)**0.5\n    theta = cmath.atan2(y, x)\n    a = r * cmath.cos(theta)\n    b = r * cmath.sin(theta)\n    return ((a, theta), complex(a, b))\n"
    ],
    "MbppEval/591": [
        "def swap_List(newList):\n    first = newList[0]\n    last = newList[-1]\n    newList[0] = last\n    newList[-1] = first\n    return newList\n",
        "def swap_List(newList):\n    if len(newList) < 2:\n        return newList\n    newList[0], newList[-1] = newList[-1], newList[0]\n    return newList\n",
        "def swap_List(new_list):\n    first = new_list[0]\n    last = new_list[-1]\n    new_list[0] = last\n    new_list[-1] = first\n    return new_list\n",
        "def swap_List(newList):\n    first_element = newList[0]\n    last_element = newList[-1]\n\n    newList[0] = last_element\n    newList[-1] = first_element\n\n    return newList\n",
        "def swap_List(newList):\n    first_elem = newList[0]\n    last_elem = newList[-1]\n    new_list = newList[1:-1]\n    new_list.insert(0, last_elem)\n    new_list.append(first_elem)\n    return new_list\n"
    ],
    "MbppEval/592": [
        "def sum_Of_product(n):\n    total = 0\n    for k in range(n+1):\n        total += factorial(n) / (factorial(k) * factorial(n-k))\n    return total\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n",
        "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\ndef binomial_Coeff(n, k):\n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef sum_Of_product(n):\n    result = 0\n    for i in range(n):\n        result += binomial_Coeff(n, i) * binomial_Coeff(n, i+1)\n    return result\n",
        "def sum_Of_product(n):\n    return n * (2 ** n - 1)\n",
        "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\ndef binomial_Coeff(n, k):\n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef sum_Of_product(n):\n    total = 0\n    for k in range(n):\n        total += binomial_Coeff(n, k) * binomial_Coeff(n, k+1)\n    return total\n",
        "import math\n\ndef binomial_Coeff(n, k):\n    return math.factorial(n) // (math.factorial(k) * math.factorial(n-k))\n\ndef sum_Of_product(n):\n    total = 0\n    for i in range(n):\n        total += binomial_Coeff(n, i) * binomial_Coeff(n, i+1)\n    return total\n"
    ],
    "MbppEval/593": [
        "import re\n\ndef removezero_ip(ip):\n    octets = ip.split('.')\n    octets = [str(int(octet)) for octet in octets]\n    result = '.'.join(octets)\n    return result\n",
        "import re\n\ndef removezero_ip(ip):\n    octets = ip.split('.')\n    cleaned_octets = [str(int(octet)) for octet in octets]\n    cleaned_ip = '.'.join(cleaned_octets)\n    return cleaned_ip\n",
        "import re\n\ndef removezero_ip(ip):\n    octets = ip.split('.')\n    cleaned_octets = [str(int(octet)) for octet in octets]\n    cleaned_ip = '.'.join(cleaned_octets)\n    return cleaned_ip\n",
        "import re\n\ndef removezero_ip(ip):\n    \"\"\"\n    Write a function to remove leading zeroes from an IP address.\n\n    Examples:\n    removezero_ip(\"216.08.094.196\") == \"216.8.94.196\"\n    removezero_ip(\"12.01.024\") == \"12.1.24\"\n    removezero_ip(\"216.08.094.0196\") == \"216.8.94.196\"\n    \"\"\"\n    octets = ip.split('.')\n    octets = [re.sub(r'^0+(\\d+)', r'\\1', octet) for octet in octets]\n    return '.'.join(octets)\n",
        "import re\n\ndef removezero_ip(ip):\n    octets = re.split(r'\\.', ip)\n    modified_octets = [octet.lstrip('0') for octet in octets]\n    modified_ip = '.'.join(modified_octets)\n    return modified_ip\n"
    ],
    "MbppEval/594": [
        "def diff_even_odd(list1):\n    first_even = None\n    first_odd = None\n\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n\n        if first_even is not None and first_odd is not None:\n            break\n\n    if first_even is None or first_odd is None:\n        return None\n    else:\n        return abs(first_even - first_odd)\n",
        "def diff_even_odd(list1):\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None or first_odd is None:\n        return None\n    \n    return abs(first_even - first_odd)\n",
        "def diff_even_odd(list1):\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None:\n        first_even = 0\n    if first_odd is None:\n        first_odd = 0\n    \n    return abs(first_even - first_odd)\n",
        "def diff_even_odd(list1):\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        \n        if first_even is not None and first_odd is not None:\n            return abs(first_even - first_odd)\n    \n    return 0\n",
        "def diff_even_odd(list1):\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None or first_odd is None:\n        return 0\n    else:\n        return abs(first_even - first_odd)\n"
    ],
    "MbppEval/595": [
        "def min_Swaps(str1, str2):\n    count1 = str1.count('1')\n    count2 = str2.count('1')\n\n    if count1 != count2:\n        return \"Not Possible\"\n\n    diff_positions = [i for i in range(len(str1)) if str1[i] != str2[i]]\n    return len(diff_positions) // 2\n",
        "def min_Swaps(str1, str2):\n    if len(str1) != len(str2):\n        return \"Not Possible\"\n    \n    diff = sum(1 for c1, c2 in zip(str1, str2) if c1 != c2)\n    \n    if diff % 2 != 0:\n        return \"Not Possible\"\n    \n    return diff // 2\n",
        "def min_Swaps(str1, str2):\n    if len(str1) != len(str2):\n        return \"Not Possible\"\n\n    diff_count = 0\n    for i in range(len(str1)):\n        if str1[i] != str2[i]:\n            diff_count += 1\n\n    if diff_count % 2 != 0:\n        return \"Not Possible\"\n\n    return diff_count // 2\n",
        "def min_Swaps(str1, str2):\n    if len(str1) != len(str2):\n        return \"Not Possible\"\n    \n    differences = 0\n    for i in range(len(str1)):\n        if str1[i] != str2[i]:\n            differences += 1\n    \n    if differences % 2 != 0:\n        return \"Not Possible\"\n    \n    return differences // 2\n",
        "def min_Swaps(str1, str2):\n    if len(str1) != len(str2):\n        return \"Not Possible\"\n    \n    count = 0\n    for i in range(len(str1)):\n        if str1[i] != str2[i]:\n            count += 1\n    \n    if count % 2 == 0:\n        return count // 2\n    else:\n        return \"Not Possible\"\n"
    ],
    "MbppEval/596": [
        "import sys\n\ndef tuple_size(tuple_list):\n    return sys.getsizeof(tuple_list)\n",
        "import sys\n\ndef tuple_size(tuple_list):\n    '''\n    Write a function to find the size in bytes of the given tuple.\n\n    Examples:\n    tuple_size((\"A\", 1, \"B\", 2, \"C\", 3)) == 42\n    tuple_size((1, \"Raju\", 2, \"Nikhil\", 3, \"Deepanshu\")) == 72\n    tuple_size(((1, \"Lion\"), (2, \"Tiger\"), (3, \"Fox\"), (4, \"Wolf\"))) == 80\n    '''\n    total_size = 0\n    for tup in tuple_list:\n        tup_size = 0\n        for item in tup:\n            tup_size += sys.getsizeof(item)\n        total_size += tup_size\n    return total_size\n",
        "import sys\n\ndef tuple_size(tuple_list):\n    \"\"\"\n    Write a function to find the size in bytes of the given tuple.\n\n    Examples:\n    tuple_size((\"A\", 1, \"B\", 2, \"C\", 3)) == 72\n    tuple_size((1, \"Raju\", 2, \"Nikhil\", 3, \"Deepanshu\")) == 192\n    tuple_size(((1, \"Lion\"), (2, \"Tiger\"), (3, \"Fox\"), (4, \"Wolf\"))) == 160\n    \"\"\"\n    total_size = 0\n    for element in tuple_list:\n        total_size += sys.getsizeof(element)\n    return total_size\n",
        "import sys\n\ndef tuple_size(tuple_list):\n    return sys.getsizeof(tuple_list)\n",
        "import sys\n\ndef tuple_size(tup):\n    total_size = 0\n    for item in tup:\n        total_size += sys.getsizeof(item)\n    return total_size\n"
    ],
    "MbppEval/597": [
        "def find_kth(arr1, arr2, k):\n    m, n = len(arr1), len(arr2)\n\n    def binary_search(start1, end1, start2, end2):\n        if start1 > end1:\n            return arr2[start2 + k - 1]\n        if start2 > end2:\n            return arr1[start1 + k - 1]\n        if k == 1:\n            return min(arr1[start1], arr2[start2])\n\n        mid1 = (start1 + end1) // 2\n        mid2 = (start2 + end2) // 2\n        if arr1[mid1] < arr2[mid2]:\n            return binary_search(mid1 + 1, end1, start2, end2)\n        else:\n            return binary_search(start1, end1, mid2 + 1, end2)\n\n    return binary_search(0, m - 1, 0, n - 1)\n",
        "def find_kth(arr1, arr2, k):\n    i, j = 0, 0\n    count = 0\n\n    while count < k - 1:\n        if i < len(arr1) and (j >= len(arr2) or arr1[i] < arr2[j]):\n            i += 1\n        else:\n            j += 1\n        count += 1\n\n    return min(arr1[i] if i < len(arr1) else float('inf'), arr2[j] if j < len(arr2) else float('inf'))\n",
        "def find_kth(arr1, arr2, k):\n    i, j = 0, 0\n    count = 0\n\n    while count < k - 1:\n        if i < len(arr1) and (j >= len(arr2) or arr1[i] < arr2[j]):\n            i += 1\n        else:\n            j += 1\n        count += 1\n\n    if i < len(arr1) and (j >= len(arr2) or arr1[i] < arr2[j]):\n        return arr1[i]\n    else:\n        return arr2[j]\n",
        "def find_kth(arr1, arr2, k):\n    i, j = 0, 0\n    while k > 1:\n        if i < len(arr1) and j < len(arr2):\n            if arr1[i] < arr2[j]:\n                i += 1\n            else:\n                j += 1\n        else:\n            if i < len(arr1):\n                i += 1\n            else:\n                j += 1\n        k -= 1\n    \n    if i < len(arr1) and j < len(arr2):\n        return min(arr1[i], arr2[j])\n    elif i < len(arr1):\n        return arr1[i]\n    else:\n        return arr2[j]\n",
        "def find_kth(arr1, arr2, k):\n    if not arr1:\n        return arr2[k - 1]\n    if not arr2:\n        return arr1[k - 1]\n\n    if k == 1:\n        return min(arr1[0], arr2[0])\n\n    mid1, mid2 = len(arr1) // 2, len(arr2) // 2\n    if mid1 + mid2 < k - 1:\n        if arr1[mid1] < arr2[mid2]:\n            return find_kth(arr1[mid1 + 1:], arr2, k - (mid1 + 1))\n        else:\n            return find_kth(arr1, arr2[mid2 + 1:], k - (mid2 + 1))\n    else:\n        if arr1[mid1] < arr2[mid2]:\n            return find_kth(arr1[:mid1 + 1], arr2, k)\n        else:\n            return find_kth(arr1, arr2[:mid2 + 1], k)\n"
    ],
    "MbppEval/598": [
        "def armstrong_number(number):\n    \"\"\"\n    Write a function to check whether the given number is armstrong or not.\n\n    Examples:\n    armstrong_number(153) == True\n    armstrong_number(259) == False\n    armstrong_number(4458) == False\n    \"\"\"\n    num_str = str(number)\n    sum_of_cubes = 0\n    for digit in num_str:\n        sum_of_cubes += int(digit) ** len(num_str)\n    return sum_of_cubes == number\n",
        "def armstrong_number(number):\n    \"\"\"\n    Write a function to check whether the given number is armstrong or not.\n\n    Examples:\n    armstrong_number(153) == True\n    armstrong_number(259) == False\n    armstrong_number(4458) == False\n    \"\"\"\n    num_str = str(number)\n    sum_of_cubes = 0\n    for digit in num_str:\n        sum_of_cubes += int(digit) ** len(num_str)\n    return sum_of_cubes == number\n",
        "def armstrong_number(number):\n    \"\"\"\n    Write a function to check whether the given number is armstrong or not.\n\n    Examples:\n    armstrong_number(153) == True\n    armstrong_number(259) == False\n    armstrong_number(4458) == False\n    \"\"\"\n    num_str = str(number)\n    length = len(num_str)\n    sum_of_cubes = 0\n\n    for digit in num_str:\n        sum_of_cubes += int(digit) ** length\n\n    return number == sum_of_cubes\n",
        "def armstrong_number(number):\n    \"\"\"\n    Write a function to check whether the given number is armstrong or not.\n\n    Examples:\n    armstrong_number(153) == True\n    armstrong_number(259) == False\n    armstrong_number(4458) == False\n    \"\"\"\n    # Convert the number to a list of digits\n    digits = [int(digit) for digit in str(number)]\n\n    # Calculate the sum of the cubes of the digits\n    sum_of_cubes = sum(digit ** len(digits) for digit in digits)\n\n    # Check if the sum is equal to the original number\n    return sum_of_cubes == number\n",
        "def armstrong_number(number):\n    \"\"\"\n    Write a function to check whether the given number is armstrong or not.\n\n    Examples:\n    armstrong_number(153) == True\n    armstrong_number(259) == False\n    armstrong_number(4458) == False\n    \"\"\"\n    num_str = str(number)\n    sum_of_cubes = sum(int(digit) ** len(num_str) for digit in num_str)\n    return sum_of_cubes == number\n"
    ],
    "MbppEval/599": [
        "def sum_average(number):\n    total = 0\n    for i in range(1, number + 1):\n        total += i\n    average = total / number\n    return (total, average)\n",
        "def sum_average(number):\n    sum_of_numbers = 0\n    for i in range(1, number + 1):\n        sum_of_numbers += i\n    average_of_numbers = sum_of_numbers / number\n    return (sum_of_numbers, average_of_numbers)\n",
        "def sum_average(number):\n    \"\"\"\n    Write a function to find the sum and average of the first n natural numbers.\n\n    Examples:\n    sum_average(10) == (55, 5.5)\n    sum_average(15) == (120, 8.0)\n    sum_average(20) == (210, 10.5)\n    \"\"\"\n    total_sum = (number * (number + 1)) // 2\n    average = total_sum / number\n    return (total_sum, average)\n",
        "def sum_average(number):\n    total = 0\n    for i in range(1, number+1):\n        total += i\n    average = total / number\n    return (total, average)\n",
        "def sum_average(number):\n    total = 0\n    for i in range(1, number+1):\n        total += i\n    average = total / number\n    return (total, average)\n"
    ],
    "MbppEval/600": [
        "def is_Even(n):\n    if n % 2 == 0:\n        return True\n    else:\n        return False\n",
        "def is_Even(n):\n    if n % 2 == 0:\n        return True\n    else:\n        return False\n",
        "def is_Even(n):\n    if n % 2 == 0:\n        return True\n    else:\n        return False\n",
        "def is_Even(n):\n    if n % 2 == 0:\n        return True\n    else:\n        return False\n",
        "def is_Even(n):\n    if n % 2 == 0:\n        return True\n    else:\n        return False\n"
    ],
    "MbppEval/602": [
        "def first_repeated_char(str1):\n    char_dict = {}\n    \n    for i, char in enumerate(str1):\n        if char in char_dict:\n            return char\n        else:\n            char_dict[char] = i\n    \n    return \"None\"\n",
        "def first_repeated_char(str1):\n    char_dict = {}\n\n    for i, char in enumerate(str1):\n        if char in char_dict:\n            return char\n        else:\n            char_dict[char] = i\n\n    return \"None\"\n",
        "def first_repeated_char(str1):\n    unique_chars = set()\n    for char in str1:\n        if char in unique_chars:\n            return char\n        unique_chars.add(char)\n    return \"None\"\n",
        "def first_repeated_char(str1):\n    char_dict = {}\n    for i, char in enumerate(str1):\n        if char in char_dict:\n            return char\n        else:\n            char_dict[char] = i\n    return \"None\"\n",
        "def first_repeated_char(str1):\n    char_dict = {}\n    for i, char in enumerate(str1):\n        if char in char_dict:\n            return char\n        else:\n            char_dict[char] = i\n    return \"None\"\n"
    ],
    "MbppEval/603": [
        "def get_ludic(n):\n    ludic_numbers = [1]\n    current_ludic = 1\n\n    while current_ludic <= n:\n        next_ludic = ludic_numbers[-1] + current_ludic\n        ludic_numbers.append(next_ludic)\n        current_ludic = next_ludic\n\n    return ludic_numbers[:-1]\n",
        "def get_ludic(n):\n    ludic_numbers = []\n    for i in range(1, n+1):\n        if is_ludic(i):\n            ludic_numbers.append(i)\n    return ludic_numbers\n\ndef is_ludic(num):\n    if num == 1:\n        return True\n    \n    curr = 1\n    while curr < num:\n        curr = 2 * curr + 1\n    \n    return curr == num\n",
        "def get_ludic(n):\n    ludic_numbers = [1]\n    current_ludic = 1\n    \n    while current_ludic <= n:\n        next_ludic = current_ludic + len(ludic_numbers)\n        ludic_numbers.append(next_ludic)\n        current_ludic = next_ludic\n    \n    return ludic_numbers[:-1]\n",
        "def get_ludic(n):\n    ludic = [1]\n    current = 2\n\n    while current <= n:\n        is_ludic = True\n        for num in ludic:\n            if (current - num) in ludic:\n                is_ludic = False\n                break\n        if is_ludic:\n            ludic.append(current)\n        current += 1\n\n    return ludic\n",
        "def is_ludic(n):\n    \"\"\"\n    Helper function to check if a given number is Ludic.\n    \"\"\"\n    if n <= 1:\n        return True\n    \n    # Create a list of numbers from 1 to n\n    numbers = list(range(1, n + 1))\n    \n    # Remove every nth number from the list\n    i = 0\n    while len(numbers) > 1:\n        i = (i + numbers[i] - 1) % len(numbers)\n        numbers.pop(i)\n    \n    return numbers[0] == n\n\ndef get_ludic(n):\n    \"\"\"\n    Get all Ludic numbers smaller than or equal to a given integer.\n    \"\"\"\n    ludic_numbers = []\n    for i in range(1, n + 1):\n        if is_ludic(i):\n            ludic_numbers.append(i)\n    return ludic_numbers\n"
    ],
    "MbppEval/604": [
        "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    result = ' '.join(reversed_words)\n    return result\n",
        "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_sentence = ' '.join(reversed_words)\n    return reversed_sentence\n",
        "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n",
        "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    result = ' '.join(reversed_words)\n    return result\n",
        "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    result = ' '.join(reversed_words)\n    return result\n"
    ],
    "MbppEval/605": [
        "import math\n\ndef prime_num(num):\n    '''\n    Write a function to check if the given integer is a prime number.\n\n    Examples:\n    prime_num(13) == True\n    prime_num(7) == True\n    prime_num(-1010) == False\n    '''\n    is_prime = True\n    \n    if num <= 1:\n        is_prime = False\n        return is_prime\n    \n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            is_prime = False\n            break\n    \n    return is_prime\n",
        "def prime_num(num):\n    '''\n    Write a function to check if the given integer is a prime number.\n\n    Examples:\n    prime_num(13) == True\n    prime_num(7) == True\n    prime_num(-1010) == False\n    '''\n    is_prime = True\n\n    # Check if the number is less than 2\n    if num < 2:\n        is_prime = False\n        return is_prime\n\n    # Check if the number is divisible by any number between 2 and its square root\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            is_prime = False\n            break\n\n    return is_prime\n",
        "def prime_num(num):\n    \"\"\"\n    Write a function to check if the given integer is a prime number.\n\n    Examples:\n    prime_num(13) == True\n    prime_num(7) == True\n    prime_num(-1010) == False\n    \"\"\"\n    is_prime = True\n\n    # Handle negative numbers\n    if num < 0:\n        is_prime = False\n        return is_prime\n\n    # Handle 0 and 1\n    if num in [0, 1]:\n        is_prime = False\n        return is_prime\n\n    # Check if the number is divisible by any number from 2 to the square root of the number\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            is_prime = False\n            break\n\n    return is_prime\n",
        "def prime_num(num):\n    \"\"\"\n    Write a function to check if the given integer is a prime number.\n\n    Examples:\n    prime_num(13) == True\n    prime_num(7) == True\n    prime_num(-1010) == False\n    \"\"\"\n    # Check for edge cases\n    if num <= 1:\n        return False\n\n    # Check for 2\n    if num == 2:\n        return True\n\n    # Check for all other numbers\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n\n    return True\n",
        "import math\n\ndef prime_num(num):\n    '''\n    Write a function to check if the given integer is a prime number.\n\n    Examples:\n    prime_num(13) == True\n    prime_num(7) == True\n    prime_num(-1010) == False\n    '''\n    if num <= 1:\n        return False\n    elif num == 2:\n        return True\n    else:\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n"
    ],
    "MbppEval/606": [
        "import math\n\ndef radian_degree(degree):\n    return degree * (math.pi / 180)\n",
        "import math\n\ndef radian_degree(degree):\n    return degree * (math.pi / 180)\n",
        "import math\n\ndef radian_degree(degree):\n    \"\"\"\n    Write a function to convert degrees to radians.\n\n    Examples:\n    radian_degree(90) == 1.5707963267948966\n    radian_degree(60) == 1.0471975511965976\n    radian_degree(120) == 2.0943951023931953\n    \"\"\"\n    return math.radians(degree)\n",
        "import math\n\ndef radian_degree(degree):\n    return degree * (math.pi / 180)\n",
        "import math\n\ndef radian_degree(degree):\n    \"\"\"\n    Write a function to convert degrees to radians.\n\n    Examples:\n    radian_degree(90) == 1.5707963267948966\n    radian_degree(60) == 1.0471975511965976\n    radian_degree(120) == 2.0943951023931953\n    \"\"\"\n    radians = degree * (math.pi / 180)\n    return radians\n"
    ],
    "MbppEval/607": [
        "import re\n\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return (None, -1, -1)\n",
        "import re\n\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return None\n",
        "import re\n\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return None\n",
        "import re\n\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return None\n",
        "import re\n\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return None\n"
    ],
    "MbppEval/608": [
        "def bell_Number(n):\n    # Base cases\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    \n    # Recursive case\n    bell_sum = 0\n    for k in range(n):\n        bell_sum += bell_Number(k) * bell_Number(n-k-1)\n    return bell_sum\n",
        "def bell_Number(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n\n    bell_numbers = [1, 1]\n    for i in range(2, n+1):\n        bell_num = sum(bell_numbers[j] * bell_numbers[i-j-1] for j in range(i))\n        bell_numbers.append(bell_num)\n\n    return bell_numbers[n]\n",
        "from math import e, factorial\n\ndef bell_Number(n):\n    \"\"\"\n    Find the nth Bell number.\n    \n    Parameters:\n    n (int): The index of the Bell number to find.\n    \n    Returns:\n    int: The nth Bell number.\n    \"\"\"\n    return round(e ** sum((-1)**k * factorial(n) / (factorial(k) * factorial(n-k)) for k in range(n+1)))\n",
        "from math import comb\n\ndef bell_Number(n):\n    if n == 0:\n        return 1\n    \n    return sum(bell_Number(k) * comb(n, k) for k in range(n))\n",
        "def bell_Number(n):\n    \"\"\"\n    Finds the nth Bell number.\n    \n    Args:\n        n (int): The index of the Bell number to be calculated.\n    \n    Returns:\n        int: The nth Bell number.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    bell_numbers = [0] * (n + 1)\n    bell_numbers[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            bell_numbers[i] += (binomial(i, j) * bell_numbers[j])\n    \n    return bell_numbers[n]\n\ndef binomial(n, k):\n    \"\"\"\n    Calculates the binomial coefficient C(n, k).\n    \n    Args:\n        n (int): The total number of elements.\n        k (int): The number of elements being chosen.\n    \n    Returns:\n        int: The binomial coefficient C(n, k).\n    \"\"\"\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef factorial(n):\n    \"\"\"\n    Calculates the factorial of a given number.\n    \n    Args:\n        n (int): The number to calculate the factorial for.\n    \n    Returns:\n        int: The factorial of the given number.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n - 1)\n"
    ],
    "MbppEval/610": [
        "def remove_kth_element(list1, L):\n    if not list1 or L < 1 or L > len(list1):\n        return list1\n    \n    new_list = []\n    for i in range(len(list1)):\n        if i != L - 1:\n            new_list.append(list1[i])\n    \n    return new_list\n",
        "def remove_kth_element(list1, k):\n    result = []\n    for i, item in enumerate(list1):\n        if i != k:\n            result.append(item)\n    return result\n",
        "def remove_kth_element(list1, k):\n    new_list = []\n    for i in range(len(list1)):\n        if i != k-1:\n            new_list.append(list1[i])\n    return new_list\n",
        "def remove_kth_element(list1, L):\n    result = []\n    for i, element in enumerate(list1):\n        if i != L:\n            result.append(element)\n    return result\n",
        "def remove_kth_element(list1, L):\n    if not list1 or L >= len(list1):\n        return list1\n\n    new_list = []\n    for i, item in enumerate(list1):\n        if i != L:\n            new_list.append(item)\n\n    return new_list\n"
    ],
    "MbppEval/611": [
        "def max_of_nth(test_list, N):\n    if not test_list or any(len(row) < N for row in test_list):\n        raise ValueError(\"Invalid input list. Each row must have at least N elements.\")\n\n    max_value = test_list[0][N-1]\n\n    for row in test_list:\n        max_value = max(max_value, row[N-1])\n\n    return max_value\n",
        "def max_of_nth(test_list, N):\n    max_value = float('-inf')\n    for row in test_list:\n        if len(row) > N:\n            max_value = max(max_value, row[N])\n    return max_value\n",
        "def max_of_nth(test_list, N):\n    max_value = float('-inf')\n    \n    for row in test_list:\n        max_value = max(max_value, row[N])\n    \n    return max_value\n",
        "def max_of_nth(test_list, N):\n    if not test_list:\n        return None\n    if N < 0 or N >= len(test_list[0]):\n        return None\n\n    max_value = test_list[0][N]\n    for row in test_list:\n        max_value = max(max_value, row[N])\n\n    return max_value\n",
        "def max_of_nth(test_list, N):\n    if not isinstance(test_list, list) or not all(isinstance(inner_list, tuple) for inner_list in test_list):\n        raise ValueError(\"test_list must be a list of tuples\")\n    if N < 0 or N >= len(test_list[0]):\n        raise ValueError(\"N must be a valid index within the range of the inner lists\")\n\n    max_value = float('-inf')\n    for inner_list in test_list:\n        max_value = max(max_value, inner_list[N])\n\n    return max_value\n"
    ],
    "MbppEval/612": [
        "def merge(lst):\n    first_elements = []\n    second_elements = []\n    for sub_list in lst:\n        first_elements.append(sub_list[0])\n        second_elements.append(sub_list[1])\n    return [first_elements, second_elements]\n",
        "def merge(lst):\n    first_elements = []\n    second_elements = []\n    \n    for sub_list in lst:\n        first_elements.append(sub_list[0])\n        second_elements.append(sub_list[1])\n    \n    return [first_elements, second_elements]\n",
        "def merge(lst):\n    first_elements = []\n    second_elements = []\n\n    for sub_list in lst:\n        first_elements.append(sub_list[0])\n        second_elements.append(sub_list[1])\n\n    return [first_elements, second_elements]\n",
        "def merge(lst):\n    first = []\n    second = []\n    \n    for sublist in lst:\n        first.append(sublist[0])\n        second.append(sublist[1])\n    \n    return [first, second]\n",
        "def merge(lst):\n    first_elements = []\n    second_elements = []\n    \n    for sublist in lst:\n        first_elements.append(sublist[0])\n        second_elements.append(sublist[1])\n    \n    return [first_elements, second_elements]\n"
    ],
    "MbppEval/614": [
        "def cummulative_sum(test_list):\n    total = 0\n    for tup in test_list:\n        total += sum(tup)\n    return total\n",
        "def cummulative_sum(test_list):\n    total_sum = 0\n    for tup in test_list:\n        for value in tup:\n            total_sum += value\n    return total_sum\n",
        "def cummulative_sum(test_list):\n    total = 0\n    for tup in test_list:\n        total += sum(tup)\n    return total\n",
        "def cummulative_sum(test_list):\n    total_sum = 0\n    for tup in test_list:\n        for num in tup:\n            total_sum += num\n    return total_sum\n",
        "def cummulative_sum(test_list):\n    total_sum = 0\n    for tup in test_list:\n        total_sum += sum(tup)\n    return total_sum\n"
    ],
    "MbppEval/615": [
        "def average_tuple(nums):\n    averages = []\n    for inner_tuple in nums:\n        average = sum(inner_tuple) / len(inner_tuple)\n        averages.append(average)\n    return averages\n",
        "def average_tuple(nums):\n    averages = []\n    for num_tuple in nums:\n        avg = sum(num_tuple) / len(num_tuple)\n        averages.append(avg)\n    return averages\n",
        "def average_tuple(nums):\n    averages = []\n    for tup in nums:\n        avg = sum(tup) / len(tup)\n        averages.append(avg)\n    return averages\n",
        "def average_tuple(nums):\n    averages = []\n    for inner_tuple in nums:\n        avg = sum(inner_tuple) / len(inner_tuple)\n        averages.append(avg)\n    return averages\n",
        "def average_tuple(nums):\n    averages = []\n    for num_tuple in nums:\n        avg = sum(num_tuple) / len(num_tuple)\n        averages.append(avg)\n    return averages\n"
    ],
    "MbppEval/616": [
        "def tuple_modulo(test_tup1, test_tup2):\n    return tuple(a % b for a, b in zip(test_tup1, test_tup2))\n",
        "def tuple_modulo(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        return \"Error: Tuples must be of the same length.\"\n    return tuple(a % b for a, b in zip(test_tup1, test_tup2))\n",
        "def tuple_modulo(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length\")\n    \n    result = []\n    for a, b in zip(test_tup1, test_tup2):\n        result.append(a % b)\n    \n    return tuple(result)\n",
        "def tuple_modulo(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    result = ()\n    for i in range(len(test_tup1)):\n        result += (test_tup1[i] % test_tup2[i],)\n\n    return result\n",
        "def tuple_modulo(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        return \"Error: Tuples must have the same length.\"\n    return tuple(a % b for a, b in zip(test_tup1, test_tup2))\n"
    ],
    "MbppEval/617": [
        "import math\n\ndef min_Jumps(steps, d):\n    if d == 0:\n        return 0\n    elif d % steps == 0:\n        return d // steps\n    else:\n        return math.ceil(d / steps)\n",
        "import math\n\ndef min_Jumps(steps, d):\n    if d == 0:\n        return 0\n\n    jumps = math.ceil(d / (math.sqrt(2) * steps))\n    return jumps\n",
        "import math\n\ndef min_Jumps(steps, d):\n    n = 1\n    while True:\n        total_distance = n * steps * math.sqrt(2)\n        if total_distance == d:\n            return n\n        elif total_distance < d:\n            n += 1\n        else:\n            return n + (d - (n-1) * steps * math.sqrt(2)) / (steps * math.sqrt(2))\n",
        "import math\n\ndef min_Jumps(steps, d):\n    if d == 0:\n        return 0\n    \n    diagonal_distance = math.sqrt(d**2)\n    jumps = math.ceil(diagonal_distance / steps)\n    return jumps\n",
        "import math\n\ndef min_Jumps(steps, d):\n    if d == 0:\n        return 0\n    elif d % steps == 0:\n        return d // steps\n    else:\n        return math.ceil(d / steps)\n"
    ],
    "MbppEval/618": [
        "def div_list(nums1, nums2):\n    result = []\n    for num1, num2 in zip(nums1, nums2):\n        try:\n            result.append(num1 / num2)\n        except ZeroDivisionError:\n            result.append(float('nan'))\n    return result\n",
        "def div_list(nums1, nums2):\n    if len(nums1) != len(nums2):\n        return []\n    \n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] / nums2[i])\n    \n    return result\n",
        "def div_list(nums1, nums2):\n    \"\"\"\n    Write a function to divide two lists element-wise.\n\n    Examples:\n    div_list([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]\n    div_list([3, 2], [1, 4]) == [3.0, 0.5]\n    div_list([90, 120], [50, 70]) == [1.8, 1.7142857142857142]\n    \"\"\"\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    return [a / b for a, b in zip(nums1, nums2)]\n",
        "def div_list(nums1, nums2):\n    '''\n    Write a function to divide two lists element wise.\n\n    Examples:\n    div_list([4,5,6],[1, 2, 3]) == [4.0,2.5,2.0]\n    div_list([3,2],[1,4]) == [3.0, 0.5]\n    div_list([90,120],[50,70]) == [1.8, 1.7142857142857142]\n    '''\n    if len(nums1) != len(nums2):\n        return \"Error: Input lists must have the same length.\"\n\n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] / nums2[i])\n    return result\n",
        "def div_list(nums1, nums2):\n    \"\"\"\n    Write a function to divide two lists element wise.\n\n    Examples:\n    div_list([4,5,6],[1, 2, 3]) == [4.0,2.5,2.0]\n    div_list([3,2],[1,4]) == [3.0, 0.5]\n    div_list([90,120],[50,70]) == [1.8, 1.7142857142857142]\n    \"\"\"\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Input lists must have the same length\")\n\n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] / nums2[i])\n\n    return result\n"
    ],
    "MbppEval/619": [
        "def move_num(test_str):\n    result = \"\"\n    digits = \"\"\n    digit_pos = 0\n    for char in test_str:\n        if char.isdigit():\n            digits += char\n        else:\n            result = result[:digit_pos] + digits + result[digit_pos:]\n            result += char\n            digit_pos += len(digits)\n            digits = \"\"\n    return result + digits\n",
        "def move_num(test_str):\n    non_numeric = \"\"\n    numbers = \"\"\n    for char in test_str:\n        if char.isdigit():\n            numbers += char\n        else:\n            non_numeric += char\n    return non_numeric + numbers\n",
        "def move_num(test_str):\n    non_numeric = \"\"\n    numeric = \"\"\n    \n    for char in test_str:\n        if char.isdigit():\n            numeric += char\n        else:\n            non_numeric += char\n    \n    return non_numeric + numeric\n",
        "def move_num(test_str):\n    non_numeric = \"\"\n    numeric = \"\"\n    for char in test_str:\n        if char.isdigit():\n            numeric += char\n        else:\n            non_numeric += char\n    return non_numeric + numeric\n",
        "def move_num(test_str):\n    result = \"\"\n    for char in test_str:\n        if char.isdigit():\n            result += char\n        else:\n            result = char + result\n    return result\n"
    ],
    "MbppEval/620": [
        "def largest_subset(a):\n    max_size = 0\n    for subset in find_subsets(a):\n        if is_divisible_subset(subset):\n            max_size = max(max_size, len(subset))\n    return max_size\n\ndef is_divisible_subset(subset):\n    for i in range(len(subset)):\n        for j in range(i+1, len(subset)):\n            if subset[i] % subset[j] != 0 and subset[j] % subset[i] != 0:\n                return False\n    return True\n\ndef find_subsets(a):\n    if not a:\n        return [[]]\n    subsets = []\n    for i in range(len(a)):\n        for subset in find_subsets(a[i+1:]):\n            subsets.append([a[i]] + subset)\n    return subsets + find_subsets(a[1:])\n",
        "def largest_subset(a):\n    max_size = 0\n    subset = []\n\n    for i in range(1, 2 ** len(a)):\n        current_subset = []\n        for j in range(len(a)):\n            if i & (1 << j):\n                current_subset.append(a[j])\n\n        if all(a % b == 0 or b % a == 0 for a in current_subset for b in current_subset):\n            if len(current_subset) > max_size:\n                max_size = len(current_subset)\n                subset = current_subset\n\n    return max_size\n",
        "def largest_subset(a):\n    a.sort()\n    subset = [a[0]]\n    max_size = 1\n\n    for i in range(1, len(a)):\n        if all(a[i] % num == 0 or num % a[i] == 0 for num in subset):\n            subset.append(a[i])\n            max_size = max(max_size, len(subset))\n\n    return max_size\n",
        "def largest_subset(a):\n    largest_subset = []\n    a.sort()\n    for num in a:\n        if all(num % x == 0 for x in largest_subset):\n            largest_subset.append(num)\n    return len(largest_subset)\n",
        "def largest_subset(a):\n    max_size = 0\n    current_subset = []\n    \n    for num in a:\n        can_add = True\n        for subset_num in current_subset:\n            if num % subset_num != 0 and subset_num % num != 0:\n                can_add = False\n                break\n        \n        if can_add:\n            current_subset.append(num)\n            if len(current_subset) > max_size:\n                max_size = len(current_subset)\n        else:\n            current_subset = [num]\n    \n    return max_size\n"
    ],
    "MbppEval/622": [
        "def get_median(arr1, arr2, n):\n    i, j = 0, 0\n    while i < n and j < n:\n        if arr1[i] <= arr2[j]:\n            i += 1\n        else:\n            j += 1\n    \n    if n % 2 == 0:\n        return (max(arr1[i-1], arr2[j-1]) + min(arr1[i], arr2[j])) / 2\n    else:\n        return min(arr1[i-1], arr2[j-1])\n",
        "def get_median(arr1, arr2, n):\n    merged = []\n    i, j = 0, 0\n    while i < n and j < n:\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    \n    while i < n:\n        merged.append(arr1[i])\n        i += 1\n    while j < n:\n        merged.append(arr2[j])\n        j += 1\n    \n    length = len(merged)\n    if length % 2 == 0:\n        return (merged[length // 2 - 1] + merged[length // 2]) / 2\n    else:\n        return merged[length // 2]\n",
        "def get_median(arr1, arr2, n):\n    i, j = 0, 0\n    count = 0\n    median = 0\n\n    while i < n and j < n:\n        if arr1[i] < arr2[j]:\n            count += 1\n            if count == (n - 1) // 2:\n                median = arr1[i]\n            i += 1\n        else:\n            count += 1\n            if count == (n - 1) // 2:\n                median = arr2[j]\n            j += 1\n\n    if n % 2 == 0:\n        if i < n:\n            median = (median + arr1[i]) / 2\n        else:\n            median = (median + arr2[j]) / 2\n\n    return median\n",
        "def get_median(arr1, arr2, n):\n    merged_arr = sorted(arr1 + arr2)\n    length = 2 * n\n    if length % 2 == 0:\n        mid1 = merged_arr[length // 2 - 1]\n        mid2 = merged_arr[length // 2]\n        return (mid1 + mid2) / 2\n    else:\n        return merged_arr[length // 2]\n",
        "def get_median(arr1, arr2, n):\n    combined = sorted(arr1 + arr2)\n    if n % 2 == 0:\n        middle1 = combined[n - 1]\n        middle2 = combined[n]\n        median = (middle1 + middle2) / 2\n    else:\n        median = combined[n // 2]\n    return median\n"
    ],
    "MbppEval/623": [
        "def nth_nums(nums, n):\n    results = []\n    for num in nums:\n        results.append(num ** n)\n    return results\n",
        "def nth_nums(nums, n):\n    results = []\n    for num in nums:\n        result = num ** n\n        results.append(result)\n    return results\n",
        "def nth_nums(nums, n):\n    return [num ** n for num in nums]\n",
        "def nth_nums(nums, n):\n    result = []\n    for num in nums:\n        result.append(num ** n)\n    return result\n",
        "def nth_nums(nums, n):\n    results = [num ** n for num in nums]\n    return results\n"
    ],
    "MbppEval/624": [
        "def is_upper(string):\n    return string.upper()\n",
        "def is_upper(string):\n    return string.upper()\n",
        "def is_upper(string):\n    return string.upper()\n",
        "def is_upper(string):\n    \"\"\"\n    Write a python function to convert a given string to uppercase.\n\n    Examples:\n    is_upper(\"person\") == \"PERSON\"\n    is_upper(\"final\") == \"FINAL\"\n    is_upper(\"Valid\") == \"VALID\"\n    \"\"\"\n    return string.upper()\n",
        "def is_upper(string):\n    return string.upper()\n"
    ],
    "MbppEval/625": [
        "def swap_List(newList):\n    if len(newList) < 2:\n        return newList\n    newList[0], newList[-1] = newList[-1], newList[0]\n    return newList\n",
        "def swap_List(new_list):\n    first = new_list[0]\n    last = new_list[-1]\n    new_list[0] = last\n    new_list[-1] = first\n    return new_list\n",
        "def swap_List(newList):\n    if len(newList) < 2:\n        return newList\n\n    first_element = newList[0]\n    newList[0] = newList[-1]\n    newList[-1] = first_element\n\n    return newList\n",
        "def swap_List(newList):\n    \"\"\"\n    Write a python function to interchange the first and last element in a given list.\n\n    Examples:\n    swap_List([1,2,3]) == [3,2,1]\n    swap_List([1,2,3,4,4]) == [4,2,3,4,1]\n    swap_List([4,5,6]) == [6,5,4]\n    swap_List([1]) == [1]\n    swap_List([]) == []\n    \"\"\"\n    if len(newList) < 2:\n        return newList\n    return [newList[-1]] + newList[1:-1] + [newList[0]]\n",
        "def swap_List(newList):\n    first = newList[0]\n    last = newList[-1]\n\n    newList[0] = last\n    newList[-1] = first\n\n    return newList\n"
    ],
    "MbppEval/626": [
        "def triangle_area(r):\n    \"\"\"\n    Write a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n\n    Examples:\n    triangle_area(0) == 0\n    triangle_area(-1) == -1\n    triangle_area(2) == 4\n    \"\"\"\n    if r < 0:\n        return -1\n    return r**2\n",
        "def triangle_area(r):\n    \"\"\"\n    Write a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n\n    Examples:\n    triangle_area(0) == 0\n    triangle_area(-1) == -1\n    triangle_area(2) == 4\n    \"\"\"\n    if r < 0:\n        return -1\n    return r ** 2\n",
        "def triangle_area(r):\n    if r == 0:\n        return 0\n    elif r < 0:\n        return -1\n    else:\n        return r ** 2\n",
        "def triangle_area(r):\n    if r < 0:\n        return -1\n    elif r == 0:\n        return 0\n    else:\n        return 0.5 * 2 * r * r\n",
        "def triangle_area(r):\n    if r < 0:\n        return -1\n    return r ** 2\n"
    ],
    "MbppEval/627": [
        "def find_First_Missing(array, start=0, end=None):\n    if not array:\n        return 0\n\n    if array[0] != 0:\n        return 0\n\n    if end is None:\n        end = len(array) - 1\n\n    if array[-1] == len(array) - 1:\n        return len(array)\n\n    while start <= end:\n        mid = (start + end) // 2\n        if array[mid] != mid + start:\n            return mid + start\n        elif array[mid] > mid + start:\n            end = mid - 1\n        else:\n            start = mid + 1\n\n    return start\n",
        "def find_First_Missing(array, start=0, end=None):\n    if not array:\n        return 0\n\n    if array[0] != 0:\n        return 0\n\n    if end is None:\n        end = len(array) - 1\n\n    if array[end] == end:\n        return end + 1\n\n    for i in range(start, end + 1):\n        if array[i] != i:\n            return i\n\n    return len(array)\n",
        "def find_First_Missing(array, start=0, array_length=None):\n    '''\n    Write a python function to find the smallest missing number from a sorted list of natural numbers.\n\n    Examples:\n    find_First_Missing([0,1,2,3],0,3) == 4\n    find_First_Missing([0,1,2,6,9],0,4) == 3\n    find_First_Missing([2,3,5,8,9],0,4) == 0\n    '''\n    \n    # Check if the array is empty\n    if not array:\n        return 0\n    \n    # Check if the array starts with 0 and has length 1\n    if array[0] == 0 and len(array) == 1:\n        return 1\n    \n    # If array_length is not provided, set it to the length of the array\n    if array_length is None:\n        array_length = len(array)\n    \n    # Iterate through the array\n    for i in range(start, array_length):\n        if array[i] != i:\n            return i\n    \n    # If no missing number is found, return the length of the array\n    return array_length\n",
        "def find_First_Missing(array, start=0, end=None):\n    if not array:\n        return 0\n    \n    if array[0] != 0:\n        return 0\n    \n    if array[-1] == len(array) - 1:\n        return len(array)\n    \n    if end is None:\n        end = len(array) - 1\n    \n    while start <= end:\n        middle = (start + end) // 2\n        if array[middle] == middle + start:\n            start = middle + 1\n        else:\n            end = middle - 1\n    \n    return start\n",
        "def find_first_missing(array):\n    \"\"\"\n    Find the smallest missing number from a sorted list of natural numbers.\n\n    Examples:\n    find_first_missing([0, 1, 2, 3]) == 4\n    find_first_missing([0, 1, 2, 6, 9]) == 3\n    find_first_missing([2, 3, 5, 8, 9]) == 0\n    \"\"\"\n    array.sort()\n    for i, num in enumerate(array):\n        if num != i:\n            return i\n    return len(array)\n"
    ],
    "MbppEval/628": [
        "def replace_spaces(string):\n    result = \"\"\n    for char in string:\n        if char == \" \":\n            result += \"%20\"\n        else:\n            result += char\n    return result\n",
        "def replace_spaces(string):\n    result = \"\"\n    for char in string:\n        if char == \" \":\n            result += \"%20\"\n        else:\n            result += char\n    return result\n",
        "def replace_spaces(string):\n    result = \"\"\n    for char in string:\n        if char == \" \":\n            result += \"%20\"\n        else:\n            result += char\n    return result\n",
        "def replace_spaces(string):\n    result = \"\"\n    for char in string:\n        if char == \" \":\n            result += \"%20\"\n        else:\n            result += char\n    return result\n",
        "def replace_spaces(string):\n    result = \"\"\n    for char in string:\n        if char == \" \":\n            result += \"%20\"\n        else:\n            result += char\n    return result\n"
    ],
    "MbppEval/629": [
        "def Split(list_of_numbers):\n    even_numbers = []\n    for num in list_of_numbers:\n        if num % 2 == 0:\n            even_numbers.append(num)\n    return even_numbers\n",
        "def Split(list_of_numbers):\n    even_nums = []\n    for num in list_of_numbers:\n        if num % 2 == 0:\n            even_nums.append(num)\n    return even_nums\n",
        "def Split(lst):\n    even_numbers = []\n    for num in lst:\n        if num % 2 == 0:\n            even_numbers.append(num)\n    return even_numbers\n",
        "def Split(lst):\n    even_numbers = []\n    for num in lst:\n        if num % 2 == 0:\n            even_numbers.append(num)\n    return even_numbers\n",
        "def Split(list_of_numbers):\n    even_numbers = []\n    for num in list_of_numbers:\n        if num % 2 == 0:\n            even_numbers.append(num)\n    return even_numbers\n"
    ],
    "MbppEval/630": [
        "def adjac(ele):\n    '''\n    Write a function to extract all the adjacent coordinates of the given coordinate tuple.\n\n    Examples:\n    get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n    get_coordinates((4, 5)) == [[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]\n    get_coordinates((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]\n    '''\n    x, y = ele\n    adjacent = []\n\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            if dx == dy == 0:\n                continue\n            new_x = x + dx\n            new_y = y + dy\n            if 0 <= new_x <= 9 and 0 <= new_y <= 9:\n                adjacent.append([new_x, new_y])\n\n    return adjacent\n",
        "def adjac(ele, sub=None):\n    if sub is None:\n        sub = []\n\n    x, y = ele\n\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_y >= 0:\n                sub.append([new_x, new_y])\n\n    return sub\n",
        "def adjac(ele):\n    \"\"\"\n    Write a function to extract all the adjacent coordinates of the given coordinate tuple.\n\n    Examples:\n    adjac((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n    adjac((4, 5)) == [[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]\n    adjac((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]\n    \"\"\"\n    return [[x, y] for x in range(ele[0] - 1, ele[0] + 2) for y in range(ele[1] - 1, ele[1] + 2) if (x, y) != ele]\n",
        "def adjac(ele, sub = []):\n    x_coords = []\n    y_coords = []\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            new_x = ele[0] + dx\n            new_y = ele[1] + dy\n            if new_x >= 0 and new_y >= 0:\n                sub.append((new_x, new_y))\n    return sub\n",
        "def adjac(ele, sub = []):\n    result = []\n    for x in range(ele[0]-1, ele[0]+2):\n        for y in range(ele[1]-1, ele[1]+2):\n            if (x, y) != ele:\n                result.append([x, y])\n    return result\n"
    ],
    "MbppEval/631": [
        "def replace_spaces(text):\n    return text.replace(\" \", \"_\").replace(\"_\", \" \")\n",
        "def replace_spaces(text):\n    return text.replace(\" \", \"_\").replace(\"_\", \" \")\n",
        "def replace_spaces(text):\n    new_text = \"\"\n    for char in text:\n        if char.isspace():\n            new_text += \"_\"\n        elif char == \"_\":\n            new_text += \" \"\n        else:\n            new_text += char\n    return new_text\n",
        "def replace_spaces(text):\n    new_text = \"\"\n    for char in text:\n        if char == \" \":\n            new_text += \"_\"\n        elif char == \"_\":\n            new_text += \" \"\n        else:\n            new_text += char\n    return new_text\n",
        "def replace_spaces(text):\n    result = ''\n    for char in text:\n        if char.isspace():\n            result += '_'\n        else:\n            result += char\n    return result\n"
    ],
    "MbppEval/632": [
        "def move_zero(num_list):\n    new_list = []\n    zero_count = 0\n    \n    for num in num_list:\n        if num != 0:\n            new_list.append(num)\n        else:\n            zero_count += 1\n    \n    new_list.extend([0] * zero_count)\n    return new_list\n",
        "def move_zero(num_list):\n    result = []\n    zero_count = 0\n\n    for num in num_list:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n\n    result.extend([0] * zero_count)\n    return result\n",
        "def move_zero(num_list):\n    \"\"\"\n    Write a python function to move all zeroes to the end of the given list.\n\n    Examples:\n    move_zero([1,0,2,0,3,4]) == [1,2,3,4,0,0]\n    move_zero([2,3,2,0,0,4,0,5,0]) == [2,3,2,4,5,0,0,0,0]\n    move_zero([0,1,0,1,1]) == [1,1,1,0,0]\n    \"\"\"\n    result = [x for x in num_list if x != 0]\n    result.extend([0] * num_list.count(0))\n    return result\n",
        "def move_zero(num_list):\n    result = []\n    for num in num_list:\n        if num != 0:\n            result.append(num)\n    result.extend([0] * num_list.count(0))\n    return result\n",
        "def move_zero(num_list):\n    non_zero_list = []\n    zero_count = 0\n    \n    for num in num_list:\n        if num != 0:\n            non_zero_list.append(num)\n        else:\n            zero_count += 1\n    \n    non_zero_list.extend([0] * zero_count)\n    \n    return non_zero_list\n"
    ],
    "MbppEval/633": [
        "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            total_xor_sum ^= (arr[i] ^ arr[j])\n    return total_xor_sum * 2\n",
        "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            total_xor_sum ^= (arr[i] ^ arr[j])\n    \n    return total_xor_sum\n",
        "def pair_xor_Sum(arr, n):\n    total_sum = 0\n    for i in range(n):\n        temp_xor = 0\n        for j in range(i+1, n):\n            temp_xor ^= arr[j]\n        total_sum += temp_xor\n    return total_sum\n",
        "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n    for a in arr:\n        total_xor_sum ^= a\n    \n    result = 0\n    for a in arr:\n        result += total_xor_sum ^ a\n    \n    return result\n",
        "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n    \n    # Step 2: Calculate the XOR of all elements\n    for num in arr:\n        total_xor_sum ^= num\n    \n    # Step 3: XOR each element with the total XOR\n    for num in arr:\n        total_xor_sum ^= num\n    \n    return total_xor_sum\n"
    ],
    "MbppEval/635": [
        "import heapq as hq\n\ndef heap_sort(iterable):\n    \"\"\"\n    Write a function to sort the given list.\n\n    Examples:\n    heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    heap_sort([25, 35, 22, 85, 14, 65, 75, 25, 58]) == [14, 22, 25, 25, 35, 58, 65, 75, 85]\n    heap_sort([7, 1, 9, 5]) == [1, 5, 7, 9]\n    \"\"\"\n    heap = list(iterable)\n    hq.heapify(heap)\n    return [hq.heappop(heap) for _ in range(len(heap))]\n",
        "import heapq as hq\n\ndef heap_sort(iterable):\n    \"\"\"\n    Sort the given list using heap sort.\n\n    Args:\n        iterable (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    # Step 1: Create a max-heap from the given list\n    heap = [-x for x in iterable]\n    hq.heapify(heap)\n\n    # Step 2: Repeatedly extract the maximum element from the heap\n    result = []\n    while heap:\n        result.append(-hq.heappop(heap))\n\n    return result\n",
        "import heapq as hq\n\ndef heap_sort(iterable):\n    \"\"\"\n    Write a function to sort the given list.\n\n    Examples:\n    heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    heap_sort([25, 35, 22, 85, 14, 65, 75, 25, 58]) == [14, 22, 25, 25, 35, 58, 65, 75, 85]\n    heap_sort([7, 1, 9, 5]) == [1, 5, 7, 9]\n    \"\"\"\n    heap = list(iterable)\n    hq.heapify(heap)\n    return [hq.heappop(heap) for _ in range(len(heap))]\n",
        "import heapq as hq\n\ndef heap_sort(iterable):\n    \"\"\"\n    Sort the given list using heap sort.\n    \n    Args:\n        iterable (list): The list to be sorted.\n    \n    Returns:\n        list: The sorted list.\n    \"\"\"\n    heap = list(iterable)\n    hq.heapify(heap)\n    sorted_list = []\n    while heap:\n        sorted_list.append(hq.heappop(heap))\n    return sorted_list\n",
        "import heapq as hq\n\ndef heap_sort(iterable):\n    \"\"\"\n    Write a function to sort the given list.\n\n    Examples:\n    heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    heap_sort([25, 35, 22, 85, 14, 65, 75, 25, 58]) == [14, 22, 25, 25, 35, 58, 65, 75, 85]\n    heap_sort([7, 1, 9, 5]) == [1, 5, 7, 9]\n    \"\"\"\n    # Step 1: Convert the list into a max-heap\n    heap = list(iterable)\n    hq.heapify(heap)\n\n    # Step 2: Repeatedly extract the maximum element and append it to the result\n    result = []\n    while heap:\n        result.append(hq.heappop(heap))\n\n    return result\n"
    ],
    "MbppEval/637": [
        "def noprofit_noloss(actual_cost, sale_amount):\n    if actual_cost == sale_amount:\n        return True\n    else:\n        return False\n",
        "def noprofit_noloss(actual_cost, sale_amount):\n    if actual_cost == sale_amount:\n        return True\n    else:\n        return False\n",
        "def noprofit_noloss(actual_cost, sale_amount):\n    profit_loss = sale_amount - actual_cost\n    return profit_loss == 0\n",
        "def noprofit_noloss(actual_cost, sale_amount):\n    if actual_cost == sale_amount:\n        return True\n    else:\n        return False\n",
        "def noprofit_noloss(actual_cost, sale_amount):\n    if actual_cost == sale_amount:\n        return True\n    else:\n        return False\n"
    ],
    "MbppEval/638": [
        "import math\n\ndef wind_chill(v, t):\n    \"\"\"\n    Write a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\n    Examples:\n    wind_chill(120, 35) == 40\n    wind_chill(40, 70) == 86\n    wind_chill(10, 100) == 116\n    \"\"\"\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return math.ceil(wci)\n",
        "import math\n\ndef wind_chill(v, t):\n    \"\"\"\n    Write a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\n    Examples:\n    wind_chill(120, 35) == 40\n    wind_chill(40, 70) == 86\n    wind_chill(10, 100) == 116\n    \"\"\"\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wind_chill_index)\n",
        "import math\n\ndef wind_chill(v, t):\n    \"\"\"\n    Write a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\n    Examples:\n    wind_chill(120, 35) == 40\n    wind_chill(40, 70) == 86\n    wind_chill(10, 100) == 116\n    \"\"\"\n    wind_chill = 13.12 + 0.6215 * t - 11.37 * v**0.16 + 0.3965 * t * v**0.16\n    return math.ceil(wind_chill)\n",
        "import math\n\ndef wind_chill(v, t):\n    wci = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wci)\n",
        "import math\n\ndef wind_chill(v, t):\n    wind_chill = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return math.ceil(wind_chill)\n"
    ],
    "MbppEval/639": [
        "def sample_nam(sample_names):\n    total_length = 0\n    for name in sample_names:\n        if name[0].isupper():\n            total_length += len(name)\n    return total_length\n",
        "def sample_nam(sample_names):\n    total_length = 0\n    for name in sample_names:\n        if name[0].isupper():\n            total_length += len(name)\n    return total_length\n",
        "def sample_nam(sample_names):\n    uppercase_names = []\n    for name in sample_names:\n        if name[0].isupper():\n            uppercase_names.append(name)\n    return sum(len(name) for name in uppercase_names)\n",
        "def sample_nam(sample_names):\n    uppercase_names = [name for name in sample_names if name[0].isupper()]\n    return sum(len(name) for name in uppercase_names)\n",
        "def sample_nam(sample_names):\n    total_length = 0\n    for name in sample_names:\n        if name[0].isupper():\n            total_length += len(name)\n    return total_length\n"
    ],
    "MbppEval/640": [
        "import re\n\ndef remove_parenthesis(items):\n    result = []\n    for item in items:\n        result.append(re.sub(r'\\([^)]*\\)', '', item))\n    return result\n",
        "import re\n\ndef remove_parenthesis(items):\n    result = []\n    for item in items:\n        cleaned_item = re.sub(r'\\([^)]*\\)', '', item)\n        result.append(cleaned_item.strip())\n    return result\n",
        "import re\n\ndef remove_parenthesis(items):\n    result = []\n    for item in items:\n        modified_item = re.sub(r'\\([^)]*\\)', '', item)\n        result.append(modified_item)\n    return result\n",
        "import re\n\ndef remove_parenthesis(items):\n    output = []\n    for item in items:\n        modified = re.sub(r'\\(.*?\\)', '', item)\n        output.append(modified)\n    return output\n",
        "import re\n\ndef remove_parenthesis(items):\n    output = []\n    for item in items:\n        modified_item = re.sub(r'\\([^)]*\\)', '', item)\n        output.append(modified_item)\n    return output\n"
    ],
    "MbppEval/641": [
        "def is_nonagonal(n):\n    \"\"\"\n    Find the nth nonagonal number.\n\n    Args:\n        n (int): The index of the nonagonal number to find.\n\n    Returns:\n        int: The nth nonagonal number.\n    \"\"\"\n    return n * (7 * n - 5) // 2\n",
        "def get_nth_nonagonal(n):\n    \"\"\"\n    Calculate the nth nonagonal number.\n\n    Args:\n        n (int): A positive integer representing the index of the nonagonal number.\n\n    Returns:\n        int: The nth nonagonal number.\n\n    Raises:\n        ValueError: If `n` is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (7 * n - 5) // 2\n",
        "def is_nonagonal(n):\n    return (n * (7 * n - 5)) // 2\n",
        "def is_nonagonal(n):\n    \"\"\"\n    Finds the nth nonagonal number.\n\n    Args:\n        n (int): The index of the nonagonal number to find.\n\n    Returns:\n        int: The nth nonagonal number.\n    \"\"\"\n    return n * (7 * n - 5) // 2\n",
        "def is_nonagonal(n):\n    \"\"\"\n    Find the nth nonagonal number.\n\n    Args:\n        n (int): The position of the nonagonal number to find.\n\n    Returns:\n        int: The nth nonagonal number.\n    \"\"\"\n    return n * (7 * n - 5) // 2\n"
    ],
    "MbppEval/643": [
        "import re\n\ndef text_match_wordz_middle(text):\n    pattern = r'\\b\\w*z\\w*\\b'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
        "import re\n\ndef text_match_wordz_middle(text):\n    pattern = r'\\b\\w*z\\w*\\b'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
        "import re\n\ndef text_match_wordz_middle(text):\n    pattern = r'\\b\\w*z\\w*\\b'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
        "import re\n\ndef text_match_wordz_middle(text):\n    pattern = r'\\b\\w*z\\w*\\b'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
        "import re\n\ndef text_match_wordz_middle(text):\n    pattern = r'\\b\\w*z\\w*\\b'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n"
    ],
    "MbppEval/644": [
        "def reverse_Array_Upto_K(input, k):\n    reversed_list = []\n    \n    # Reverse the elements up to index k\n    for i in range(k-1, -1, -1):\n        reversed_list.append(input[i])\n    \n    # Append the remaining elements\n    for i in range(k, len(input)):\n        reversed_list.append(input[i])\n    \n    return reversed_list\n",
        "def reverse_Array_Upto_K(input, k):\n    left = 0\n    right = k - 1\n    \n    while left < right:\n        input[left], input[right] = input[right], input[left]\n        left += 1\n        right -= 1\n    \n    return input\n",
        "def reverse_Array_Upto_K(input_array, k):\n    reversed_array = []\n    for i in range(k):\n        reversed_array.append(input_array[k-i-1])\n    for i in range(k, len(input_array)):\n        reversed_array.append(input_array[i])\n    return reversed_array\n",
        "def reverse_Array_Upto_K(input, k):\n    reversed_part = []\n    for i in range(k):\n        reversed_part.append(input[k-i-1])\n    reversed_part.extend(input[k:])\n    return reversed_part\n",
        "def reverse_Array_Upto_K(input, k):\n    modified_list = input[:]\n    modified_list[:k] = reversed(modified_list[:k])\n    return modified_list\n"
    ],
    "MbppEval/720": [
        "def add_dict_to_tuple(test_tup, test_dict):\n    return test_tup + (test_dict,)\n",
        "def add_dict_to_tuple(test_tup, test_dict):\n    return test_tup + (test_dict,)\n",
        "def add_dict_to_tuple(test_tup, test_dict):\n    return test_tup + (test_dict,)\n",
        "def add_dict_to_tuple(test_tup, test_dict):\n    new_tup = (*test_tup, )\n    new_tup += (test_dict,)\n    return new_tup\n",
        "def add_dict_to_tuple(test_tup, test_dict):\n    result = list(test_tup)\n    for key, value in test_dict.items():\n        result.append(key)\n        result.append(value)\n    return tuple(result)\n"
    ],
    "MbppEval/721": [
        "def maxAverageOfPath(cost):\n    n = len(cost)\n    max_average = 0\n    \n    def generate_paths(i, j, path, total_cost):\n        nonlocal max_average\n        \n        if i == n-1 and j == n-1:\n            average_cost = total_cost / (len(path) + 1)\n            max_average = max(max_average, average_cost)\n            return\n        \n        if i < n-1:\n            generate_paths(i+1, j, path + [(i+1, j)], total_cost + cost[i+1][j])\n        \n        if j < n-1:\n            generate_paths(i, j+1, path + [(i, j+1)], total_cost + cost[i][j+1])\n    \n    generate_paths(0, 0, [(0, 0)], cost[0][0])\n    return max_average\n",
        "def maxAverageOfPath(cost):\n    n = len(cost)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Base case: the average for the top-left cell is the cost of that cell\n    dp[0][0] = cost[0][0]\n    \n    # Fill in the first row and first column\n    for i in range(1, n):\n        dp[i][0] = (dp[i-1][0] * i + cost[i][0]) / (i + 1)\n        dp[0][i] = (dp[0][i-1] * i + cost[0][i]) / (i + 1)\n    \n    # Fill in the rest of the matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            # The maximum average for the current cell is the maximum of\n            # the average of the path coming from the left and the average\n            # of the path coming from above\n            dp[i][j] = max((dp[i-1][j] * i + cost[i][j]) / (i + 1),\n                          (dp[i][j-1] * j + cost[i][j]) / (j + 1))\n    \n    # The maximum average is the value in the bottom-right cell\n    return dp[n-1][n-1]\n",
        "def maxAverageOfPath(cost):\n    n = len(cost)\n    dp = [[0] * n for _ in range(n)]\n    max_average = 0\n\n    # Initialize the top-left cell\n    dp[0][0] = cost[0][0]\n\n    # Compute the maximum average cost for each cell\n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n            elif i == 0:\n                dp[i][j] = (dp[i][j-1] + cost[i][j]) / (j + 1)\n            elif j == 0:\n                dp[i][j] = (dp[i-1][j] + cost[i][j]) / (i + 1)\n            else:\n                dp[i][j] = max((dp[i-1][j] + cost[i][j]) / (i + 1),\n                              (dp[i][j-1] + cost[i][j]) / (j + 1))\n            max_average = max(max_average, dp[i][j])\n\n    return max_average\n",
        "def maxAverageOfPath(cost):\n    n = len(cost)\n    total_cost = [[0] * n for _ in range(n)]\n    num_cells = [[0] * n for _ in range(n)]\n    \n    # Initialize the first row and first column\n    total_cost[0][0] = cost[0][0]\n    num_cells[0][0] = 1\n    for i in range(1, n):\n        total_cost[0][i] = total_cost[0][i-1] + cost[0][i]\n        num_cells[0][i] = num_cells[0][i-1] + 1\n        total_cost[i][0] = total_cost[i-1][0] + cost[i][0]\n        num_cells[i][0] = num_cells[i-1][0] + 1\n    \n    # Fill the rest of the matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            total_cost[i][j] = max(total_cost[i-1][j], total_cost[i][j-1]) + cost[i][j]\n            num_cells[i][j] = max(num_cells[i-1][j], num_cells[i][j-1]) + 1\n    \n    # Find the maximum average\n    max_average = 0\n    for i in range(n):\n        max_average = max(max_average, total_cost[n-1][i] / num_cells[n-1][i])\n    \n    return max_average\n",
        "def maxAverageOfPath(cost):\n    N = len(cost)\n    dp = [[0] * N for _ in range(N)]\n    \n    # Base cases\n    dp[0][0] = cost[0][0]\n    \n    # Compute the maximum average path\n    for i in range(N):\n        for j in range(N):\n            if i == 0 and j == 0:\n                continue\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + cost[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + cost[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    \n    return dp[N-1][N-1] / (2*N - 1)\n"
    ],
    "MbppEval/722": [
        "def filter_data(students, h, w):\n    filtered = {}\n    for name, (height, weight) in students.items():\n        if height >= h and weight >= w:\n            filtered[name] = (height, weight)\n    return filtered\n",
        "def filter_data(students, h, w):\n    filtered_students = {}\n    \n    for student, stats in students.items():\n        student_height, student_weight = stats\n        if student_height >= h and student_weight >= w:\n            filtered_students[student] = stats\n    \n    return filtered_students\n",
        "def filter_data(students, h, w):\n    filtered_students = {}\n    for student, (height, weight) in students.items():\n        if height >= h and weight >= w:\n            filtered_students[student] = (height, weight)\n    return filtered_students\n",
        "def filter_data(students, h, w):\n    filtered_students = {}\n\n    for student, stats in students.items():\n        student_height, student_weight = stats\n        if student_height >= h and student_weight >= w:\n            filtered_students[student] = stats\n\n    return filtered_students\n",
        "def filter_data(students, h, w):\n    return {student: (height, weight) for student, (height, weight) in students.items() if height >= h and weight >= w}\n"
    ],
    "MbppEval/723": [
        "from operator import eq\n\ndef count_same_pair(nums1, nums2):\n    count = 0\n    for i in range(len(nums1)):\n        if eq(nums1[i], nums2[i]):\n            count += 1\n    return count\n",
        "def count_same_pair(nums1, nums2):\n    count_dict = {}\n    for num in nums1:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    total_count = 0\n    for num in nums2:\n        if num in count_dict:\n            total_count += count_dict[num]\n            count_dict[num] -= 1\n    \n    return total_count\n",
        "from operator import eq\n\ndef count_same_pair(nums1, nums2):\n    if len(nums1) != len(nums2):\n        return 0\n\n    match_indices = {}\n    count = 0\n\n    for i in range(len(nums1)):\n        if eq(nums1[i], nums2[i]):\n            match_indices[i] = True\n            count += 1\n\n    return count\n",
        "from operator import eq\n\ndef count_same_pair(nums1, nums2):\n    if len(nums1) != len(nums2):\n        return 0\n\n    count = 0\n    for i in range(len(nums1)):\n        if eq(nums1[i], nums2[i]):\n            count += 1\n\n    return count\n",
        "from operator import eq\n\ndef count_same_pair(nums1, nums2):\n    if len(nums1) != len(nums2):\n        return 0\n    \n    count = 0\n    for i in range(len(nums1)):\n        if eq(nums1[i], nums2[i]):\n            count += 1\n    \n    return count\n"
    ],
    "MbppEval/724": [
        "def power_base_sum(base, power):\n    result = base ** power\n    total_sum = 0\n    for digit in str(result):\n        total_sum += int(digit)\n    return total_sum\n",
        "def power_base_sum(base, power):\n    result = base ** power\n    total_sum = 0\n    \n    while result > 0:\n        total_sum += result % 10\n        result //= 10\n    \n    return total_sum\n",
        "def power_base_sum(base, power):\n    result = base ** power\n    result_str = str(result)\n    sum_of_digits = 0\n    for digit in result_str:\n        sum_of_digits += int(digit)\n    return sum_of_digits\n",
        "def power_base_sum(base, power):\n    total_sum = 0\n    for _ in range(power):\n        base *= base\n        while base > 0:\n            total_sum += base % 10\n            base //= 10\n    return total_sum\n",
        "def power_base_sum(base, power):\n    result = base ** power\n    result_str = str(result)\n    digit_sum = 0\n    for digit in result_str:\n        digit_sum += int(digit)\n    return digit_sum\n"
    ],
    "MbppEval/725": [
        "import re\n\ndef extract_quotation(text1):\n    quotes = re.findall(r'\"(.*?)\"', text1)\n    return quotes\n",
        "import re\n\ndef extract_quotation(text1):\n    extracted_values = []\n    matches = re.findall(r'\"(.*?)\"', text1)\n    extracted_values.extend(matches)\n    return extracted_values\n",
        "import re\n\ndef extract_quotation(text1):\n    quoted_strings = re.findall(r'\"(.*?)\"', text1)\n    return quoted_strings\n",
        "import re\n\ndef extract_quotation(text1):\n    return re.findall(r'\"(.*?)\"', text1)\n",
        "import re\n\ndef extract_quotation(text1):\n    return re.findall(r'\"([^\"]*)\"', text1)\n"
    ],
    "MbppEval/726": [
        "def multiply_elements(test_tup):\n    result = ()\n    for i in range(len(test_tup) - 1):\n        result += (test_tup[i] * test_tup[i+1],)\n    return result\n",
        "def multiply_elements(test_tup):\n    result = ()\n    for i in range(len(test_tup) - 1):\n        result += (test_tup[i] * test_tup[i+1],)\n    return result\n",
        "def multiply_elements(test_tup):\n    output = ()\n    for i in range(len(test_tup) - 1):\n        output += (test_tup[i] * test_tup[i+1],)\n    return output\n",
        "def multiply_elements(test_tup):\n    result = []\n    for i in range(len(test_tup) - 1):\n        result.append(test_tup[i] * test_tup[i + 1])\n    return tuple(result)\n",
        "def multiply_elements(test_tup):\n    result = []\n    for i in range(len(test_tup) - 1):\n        result.append(test_tup[i] * test_tup[i+1])\n    return tuple(result)\n"
    ],
    "MbppEval/728": [
        "def sum_list(lst1, lst2):\n    if len(lst1) != len(lst2):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    result = []\n    for i in range(len(lst1)):\n        result.append(lst1[i] + lst2[i])\n    return result\n",
        "def sum_list(lst1, lst2):\n    if not lst1 or not lst2:\n        return []\n\n    max_length = max(len(lst1), len(lst2))\n    lst1 = lst1 + [0] * (max_length - len(lst1))\n    lst2 = lst2 + [0] * (max_length - len(lst2))\n\n    return [a + b for a, b in zip(lst1, lst2)]\n",
        "def sum_list(lst1, lst2):\n    result = []\n    for i in range(len(lst1)):\n        result.append(lst1[i] + lst2[i])\n    return result\n",
        "def sum_list(lst1, lst2):\n    result = []\n    for i in range(len(lst1)):\n        result.append(lst1[i] + lst2[i])\n    return result\n",
        "def sum_list(lst1, lst2):\n    if len(lst1) != len(lst2):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    result = []\n    for i in range(len(lst1)):\n        result.append(lst1[i] + lst2[i])\n    return result\n"
    ],
    "MbppEval/730": [
        "from itertools import groupby\n\ndef consecutive_duplicates(nums):\n    result = [next(group) for _, group in groupby(nums)]\n    return result\n",
        "from itertools import groupby\n\ndef consecutive_duplicates(nums):\n    result = []\n    for _, group in groupby(nums):\n        result.append(next(group))\n    return result\n",
        "from itertools import groupby\n\ndef consecutive_duplicates(nums):\n    return [k for k, _ in groupby(nums)]\n",
        "from itertools import groupby\n\ndef consecutive_duplicates(nums):\n    return [key for key, _ in groupby(nums)]\n",
        "from itertools import groupby\n\ndef consecutive_duplicates(nums):\n    return [k for k, _ in groupby(nums)]\n"
    ],
    "MbppEval/731": [
        "import math\n\ndef lateralsurface_cone(r, h):\n    \"\"\"\n    Write a function to find the lateral surface area of a cone given radius r and the height h.\n\n    Examples:\n    lateralsurface_cone(5, 12) == 204.20352248333654\n    lateralsurface_cone(10, 15) == 566.3586699569488\n    lateralsurface_cone(19, 17) == 1521.8090132193388\n    \"\"\"\n    lateral_surface_area = math.pi * r * math.sqrt(r**2 + h**2)\n    return lateral_surface_area\n",
        "import math\n\ndef lateralsurface_cone(r, h):\n    l = math.sqrt(r ** 2 + h ** 2)\n    lateral_surface_area = math.pi * r * l\n    return lateral_surface_area\n",
        "import math\n\ndef lateralsurface_cone(r, h):\n    l = math.sqrt(r**2 + h**2)\n    lateral_surface_area = math.pi * r * l\n    return lateral_surface_area\n",
        "import math\n\ndef lateralsurface_cone(r, h):\n    \"\"\"\n    Write a function to find the lateral surface area of a cone given radius r and the height h.\n\n    Examples:\n    lateralsurface_cone(5, 12) == 204.20352248333654\n    lateralsurface_cone(10, 15) == 566.3586699569488\n    lateralsurface_cone(19, 17) == 1521.8090132193388\n    \"\"\"\n    lateral_surface_area = math.pi * r * math.sqrt(r**2 + h**2)\n    return lateral_surface_area\n",
        "import math\n\ndef lateralsurface_cone(r, h):\n    \"\"\"\n    Write a function to find the lateral surface area of a cone given radius r and the height h.\n\n    Examples:\n    lateralsurface_cone(5, 12) == 204.20352248333654\n    lateralsurface_cone(10, 15) == 566.3586699569488\n    lateralsurface_cone(19, 17) == 1521.8090132193388\n    \"\"\"\n    lateral_surface_area = math.pi * r * math.sqrt(r ** 2 + h ** 2)\n    return lateral_surface_area\n"
    ],
    "MbppEval/732": [
        "import re\n\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)\n",
        "import re\n\ndef replace_specialchar(text):\n    return re.sub(r'[ ,\\.]', ':', text)\n",
        "import re\n\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)\n",
        "import re\n\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)\n",
        "import re\n\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)\n"
    ],
    "MbppEval/733": [
        "def find_first_occurrence(A, x):\n    left = 0\n    right = len(A) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if A[mid] == x:\n            if mid == 0 or A[mid - 1] != x:\n                return mid\n            else:\n                right = mid - 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n",
        "def find_first_occurrence(A, x):\n    left = 0\n    right = len(A) - 1\n    \n    while left <= right:\n        middle = (left + right) // 2\n        \n        if A[middle] == x:\n            if middle == 0 or A[middle-1] != x:\n                return middle\n            else:\n                right = middle - 1\n        elif A[middle] < x:\n            left = middle + 1\n        else:\n            right = middle - 1\n    \n    return -1\n",
        "def find_first_occurrence(A, x):\n    left = 0\n    right = len(A) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if A[mid] == x:\n            if mid == 0 or A[mid-1] != x:\n                return mid\n            else:\n                right = mid - 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n",
        "def find_first_occurrence(A, x):\n    left = 0\n    right = len(A) - 1\n    \n    while left <= right:\n        middle = (left + right) // 2\n        \n        if A[middle] == x:\n            if middle == 0 or A[middle-1] != x:\n                return middle\n            else:\n                right = middle - 1\n        elif A[middle] < x:\n            left = middle + 1\n        else:\n            right = middle - 1\n    \n    return -1\n",
        "def find_first_occurrence(A, x):\n    left = 0\n    right = len(A) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if A[mid] == x:\n            if mid == 0 or A[mid-1] != x:\n                return mid\n            else:\n                right = mid - 1\n        elif A[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n"
    ],
    "MbppEval/734": [
        "def sum_Of_Subarray_Prod(arr):\n    n = len(arr)\n    result = 0\n    running_product = 1\n    for i in range(n):\n        running_product *= arr[i]\n        result += running_product\n    return result\n",
        "def sum_Of_Subarray_Prod(arr):\n    n = len(arr)\n    dp = [[0] * n for _ in range(n)]\n    total_sum = 0\n\n    for i in range(n):\n        dp[i][i] = arr[i]\n        total_sum += dp[i][i]\n\n    for length in range(2, n+1):\n        for i in range(n-length+1):\n            j = i + length - 1\n            dp[i][j] = dp[i][j-1] * arr[j]\n            total_sum += dp[i][j]\n\n    return total_sum\n",
        "def sum_Of_Subarray_Prod(arr):\n    n = len(arr)\n    result = 0\n    \n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            result += product\n    \n    return result\n",
        "def sum_Of_Subarray_Prod(arr):\n    n = len(arr)\n    prefix_prod = [1] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix_prod[i] = prefix_prod[i - 1] * arr[i - 1]\n    \n    result = 0\n    for i in range(1, n + 1):\n        result += (i * (prefix_prod[i] - prefix_prod[i - 1])) * arr[i - 1]\n    \n    return result\n",
        "def sum_Of_Subarray_Prod(arr, n):\n    total_sum = 0\n    product = 1\n    \n    for i in range(n):\n        total_sum += arr[i] * product\n        product *= arr[i]\n    \n    return total_sum\n"
    ],
    "MbppEval/735": [
        "def set_middle_bits(n):\n    num_bits = n.bit_length()\n    mask = (1 << (num_bits - 1)) - (1 << 1)\n    result = n ^ mask\n    return result\n",
        "def set_middle_bits(n):\n    if n in (0, 1):\n        return n\n    num_bits = len(bin(n)) - 2\n    mask = (1 << num_bits) - 2\n    return n ^ mask\n",
        "def set_middle_bits(n):\n    binary_str = format(n, 'b')\n    mask = int('10' + '0' * (len(binary_str) - 2) + '1', 2)\n    result = n ^ mask\n    return result\n",
        "def set_middle_bits(n):\n    binary_str = bin(n)[2:]\n    first_bit = binary_str[0]\n    middle_bits = binary_str[1:-1]\n    last_bit = binary_str[-1]\n    \n    flipped_middle_bits = ''.join('1' if bit == '0' else '0' for bit in middle_bits)\n    \n    result = first_bit + flipped_middle_bits + last_bit\n    return int(result, 2)\n",
        "def set_middle_bits(n):\n    binary_str = bin(n)[2:]\n    middle_bits = binary_str[1:-1]\n    toggled_middle_bits = ''.join('1' if bit == '0' else '0' for bit in middle_bits)\n    new_binary_str = binary_str[0] + toggled_middle_bits + binary_str[-1]\n    return int(new_binary_str, 2)\n"
    ],
    "MbppEval/736": [
        "import bisect\n\ndef left_insertion(a, x):\n    return bisect.bisect_left(a, x)\n",
        "import bisect\n\ndef left_insertion(a, x):\n    return bisect.bisect_left(a, x)\n",
        "import bisect\n\ndef left_insertion(a, x):\n    return bisect.bisect_left(a, x)\n",
        "import bisect\n\ndef left_insertion(a, x):\n    return bisect.bisect_left(a, x)\n",
        "import bisect\n\ndef left_insertion(a, x):\n    return bisect.bisect_left(a, x)\n"
    ],
    "MbppEval/737": [
        "import re\n\nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\n\ndef check_str(string):\n    if re.match(regex, string):\n        return 'Valid'\n    else:\n        return 'Invalid'\n",
        "import re\n\nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\n\ndef check_str(string):\n    if re.match(regex, string):\n        return 'Valid'\n    else:\n        return 'Invalid'\n",
        "import re\n\nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\n\ndef check_str(string):\n    if re.match(regex, string):\n        return 'Valid'\n    else:\n        return 'Invalid'\n",
        "import re\n\nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\n\ndef check_str(string):\n    if re.match(regex, string):\n        return 'Valid'\n    else:\n        return 'Invalid'\n",
        "import re\n\nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\n\ndef check_str(string):\n    if re.match(regex, string):\n        return 'Valid'\n    else:\n        return 'Invalid'\n"
    ],
    "MbppEval/738": [
        "def geometric_sum(n):\n    total = 0\n    for i in range(n):\n        total += 1 / (2 ** i)\n    return total\n",
        "def geometric_sum(n):\n    total = 0\n    for i in range(n):\n        total += 1 / (2 ** i)\n    return total\n",
        "def geometric_sum(n):\n    return 2 - (0.5 ** (n - 1))\n",
        "def geometric_sum(n):\n    total = 0\n    for i in range(n-1):\n        total += 1 / (2 ** i)\n    return total\n",
        "def geometric_sum(n):\n    result = 0\n    for i in range(n):\n        result += 1 / (2 ** i)\n    return result\n"
    ],
    "MbppEval/739": [
        "import math\n\ndef find_Index(n):\n    index = 0\n    triangular_number = 1\n\n    while len(str(triangular_number)) < n:\n        index += 1\n        triangular_number += index + 1\n\n    return index\n",
        "import math\n\ndef find_Index(n):\n    index = 1\n    triangular_num = 1\n    while len(str(triangular_num)) < n:\n        index += 1\n        triangular_num = (index * (index + 1)) // 2\n    return index\n",
        "import math\n\ndef find_Index(n):\n    k = 1\n    while True:\n        triangular_number = k * (k + 1) // 2\n        if int(math.log10(triangular_number)) + 1 >= n:\n            return k\n        k += 1\n",
        "import math\n\ndef find_Index(n):\n    number = 1\n    index = 0\n    while len(str(number)) < n:\n        index += 1\n        number += index\n    return int((math.sqrt(8 * number + 1) - 1) / 2)\n",
        "import math\n\ndef find_Index(n):\n    i = 0\n    triangular_number = 0\n    \n    while len(str(triangular_number)) < n:\n        i += 1\n        triangular_number += i\n    \n    return i\n"
    ],
    "MbppEval/740": [
        "def tuple_to_dict(test_tup):\n    result = {}\n    for i in range(0, len(test_tup), 2):\n        result[test_tup[i]] = test_tup[i + 1]\n    return result\n",
        "def tuple_to_dict(test_tup):\n    result = {}\n    for i in range(0, len(test_tup), 2):\n        result[test_tup[i]] = test_tup[i+1]\n    return result\n",
        "def tuple_to_dict(test_tup):\n    result = {}\n    for i in range(0, len(test_tup), 2):\n        if i + 1 < len(test_tup):\n            key = test_tup[i]\n            value = test_tup[i+1]\n            result[key] = value\n    return result\n",
        "def tuple_to_dict(test_tup):\n    result = {}\n    for i in range(0, len(test_tup), 2):\n        key = test_tup[i]\n        value = test_tup[i+1]\n        result[key] = value\n    return result\n",
        "def tuple_to_dict(test_tup):\n    result = {}\n    for i in range(0, len(test_tup), 2):\n        key = test_tup[i]\n        value = test_tup[i + 1]\n        result[key] = value\n    return result\n"
    ],
    "MbppEval/741": [
        "def all_Characters_Same(s):\n    unique_chars = set()\n    for char in s:\n        unique_chars.add(char)\n    return len(unique_chars) == 1\n",
        "def all_Characters_Same(s):\n    \"\"\"\n    Write a python function to check whether all the characters are same or not.\n\n    Examples:\n    all_Characters_Same(\"python\") == False\n    all_Characters_Same(\"aaa\") == True\n    all_Characters_Same(\"data\") == False\n    \"\"\"\n    if not s:\n        return True\n    \n    first_char = s[0]\n    for char in s[1:]:\n        if char != first_char:\n            return False\n    \n    return True\n",
        "def all_Characters_Same(s):\n    unique_chars = set(s)\n    return len(unique_chars) == 1\n",
        "def all_Characters_Same(s):\n    if len(s) == 0:\n        return True\n    \n    prev_char = s[0]\n    for char in s[1:]:\n        if char != prev_char:\n            return False\n    \n    return True\n",
        "def all_Characters_Same(s):\n    unique_chars = set(s)\n    return len(unique_chars) == 1\n"
    ],
    "MbppEval/742": [
        "import math\n\ndef area_tetrahedron(side):\n    return (math.sqrt(3) * side**2) / 4\n",
        "import math\n\ndef area_tetrahedron(side):\n    return (math.sqrt(3) * side**2) / 4\n",
        "import math\n\ndef area_tetrahedron(side):\n    return math.sqrt(3) * side**2\n",
        "import math\n\ndef area_tetrahedron(side):\n    \"\"\"\n    Write a function to calculate the area of a tetrahedron.\n\n    Examples:\n    area_tetrahedron(3) == 15.588457268119894\n    area_tetrahedron(20) == 692.8203230275509\n    area_tetrahedron(10) == 173.20508075688772\n    \"\"\"\n    return (math.sqrt(3) * side ** 2)\n",
        "import math\n\ndef area_tetrahedron(side):\n    return math.sqrt(3) * (side ** 2)\n"
    ],
    "MbppEval/743": [
        "def rotate_right(lst, m, n):\n    \"\"\"\n    Rotate a list to the right by m items, where n is the length of the list.\n    \"\"\"\n    m = m % n\n    part1 = lst[-m:]\n    part2 = lst[:-m]\n    return part1 + part2\n",
        "def rotate_right(lst, m, n):\n    \"\"\"\n    Rotates a list to the right by m positions, n times.\n    \"\"\"\n    for _ in range(n):\n        last_m = lst[-m:]\n        rest = lst[:-m]\n        lst = last_m + rest\n    return lst\n",
        "def rotate_right(lst, m, n):\n    length = len(lst)\n    rotations = m * n % length\n    new_lst = lst[-rotations:] + lst[:-rotations]\n    return new_lst\n",
        "def rotate_right(lst, m):\n    \"\"\"\n    Rotates the list 'lst' to the right by 'm' positions.\n    \"\"\"\n    return lst[-m:] + lst[:-m]\n",
        "def rotate_right(lst, k, m):\n    n = len(lst)\n    for _ in range(m):\n        rotate_by = k % n\n        part1 = lst[-rotate_by:]\n        part2 = lst[:-rotate_by]\n        lst = part1 + part2\n    return lst\n"
    ],
    "MbppEval/744": [
        "def check_none(test_tup):\n    has_none = False\n    for element in test_tup:\n        if element is None:\n            has_none = True\n            break\n    return has_none\n",
        "def check_none(test_tup):\n    has_none = False\n    for element in test_tup:\n        if element is None:\n            has_none = True\n            break\n    return has_none\n",
        "def check_none(test_tup):\n    for element in test_tup:\n        if element is None:\n            return True\n    return False\n",
        "def check_none(test_tup):\n    for element in test_tup:\n        if element is None:\n            return True\n    return False\n",
        "def check_none(test_tup):\n    return any(x is None for x in test_tup)\n"
    ],
    "MbppEval/745": [
        "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum + 1):\n        is_divisible = True\n        for digit in str(num):\n            if digit == '0' or num % int(digit) != 0:\n                is_divisible = False\n                break\n        if is_divisible:\n            result.append(num)\n    return result\n",
        "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum+1):\n        is_divisible = True\n        for digit in str(num):\n            if digit == '0' or num % int(digit) != 0:\n                is_divisible = False\n                break\n        if is_divisible:\n            result.append(num)\n    return result\n",
        "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(digit) for digit in str(num)]\n        is_divisible = all(num % digit == 0 for digit in digits)\n        if is_divisible:\n            result.append(num)\n    return result\n",
        "def divisible_by_digits(startnum, endnum):\n    \"\"\"\n    Write a function to find numbers within a given range from startnum to endnum where every number is divisible by every digit it contains.\n    \"\"\"\n    result = []\n    for num in range(startnum, endnum + 1):\n        is_divisible = True\n        for digit in str(num):\n            if digit == '0' or num % int(digit) != 0:\n                is_divisible = False\n                break\n        if is_divisible:\n            result.append(num)\n    return result\n",
        "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum+1):\n        digits = [int(d) for d in str(num)]\n        if all(num % d == 0 for d in digits):\n            result.append(num)\n    return result\n"
    ],
    "MbppEval/746": [
        "import math\n\ndef sector_area(r, a):\n    \"\"\"\n    Write a function to find the area of a sector. The function takes the radius and angle as inputs. \n    The function should return None if the angle is larger than 360 degrees.\n\n    Examples:\n    sector_area(4, 45) == 6.285714285714286\n    sector_area(9, 45) == 31.82142857142857\n    sector_area(9, 360) == None\n    \"\"\"\n    if a > 360:\n        return None\n    radians = a * (math.pi / 180)\n    area = (r ** 2 * radians) / 2\n    return area\n",
        "import math\n\ndef sector_area(r, a):\n    \"\"\"\n    Write a function to find the area of a sector. The function takes the radius and angle as inputs. The function should return None if the angle is larger than 360 degrees.\n\n    Examples:\n    sector_area(4, 45) == 6.285714285714286\n    sector_area(9, 45) == 31.82142857142857\n    sector_area(9, 360) == None\n    \"\"\"\n    if a > 360:\n        return None\n    \n    area = (r ** 2 * a * math.pi) / 360\n    return area\n",
        "import math\n\ndef sector_area(r, a):\n    '''\n    Write a function to find area of a sector. The function takes the radius and angle as inputs. Function should return None if the angle is larger than 360 degrees.\n\n    Examples:\n    sector_area(4, 45) == 6.285714285714286\n    sector_area(9, 45) == 31.82142857142857\n    sector_area(9, 360) == None\n    '''\n    if a > 360:\n        return None\n    \n    theta = math.radians(a)\n    area = (r ** 2 * theta) / 2\n    return area\n",
        "import math\n\ndef sector_area(r, a):\n    if a > 360:\n        return None\n    area = (math.pi * r**2 * a) / 360\n    return area\n",
        "import math\n\ndef sector_area(r, a):\n    if a > 360:\n        return None\n    area = (r ** 2 * a * math.pi) / 360\n    return area\n"
    ],
    "MbppEval/747": [
        "def lcs_of_three(X, Y, Z):\n    m, n, o = len(X), len(Y), len(Z)\n    dp = [[[0] * (o+1) for _ in range(n+1)] for _ in range(m+1)]\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            for k in range(1, o+1):\n                if X[i-1] == Y[j-1] == Z[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])\n\n    return dp[m][n][o]\n",
        "def lcs_of_three(X, Y, Z):\n    m, n, o = len(X), len(Y), len(Z)\n    dp = [[[0] * (o+1) for _ in range(n+1)] for _ in range(m+1)]\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            for k in range(1, o+1):\n                if X[i-1] == Y[j-1] == Z[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])\n\n    return dp[m][n][o]\n",
        "def lcs_of_three(X, Y, Z):\n    m, n, o = len(X), len(Y), len(Z)\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                if X[i - 1] == Y[j - 1] == Z[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n\n    return dp[m][n][o]\n",
        "def lcs_of_three(X, Y, Z):\n    m, n, o = len(X), len(Y), len(Z)\n    dp = [[[0] * (o+1) for _ in range(n+1)] for _ in range(m+1)]\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            for k in range(1, o+1):\n                if X[i-1] == Y[j-1] == Z[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])\n\n    return dp[m][n][o]\n",
        "def lcs_of_three(X, Y, Z):\n    m, n, o = len(X), len(Y), len(Z)\n    dp = [[[0] * (o + 1) for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                if X[i - 1] == Y[j - 1] == Z[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n\n    return dp[m][n][o]\n"
    ],
    "MbppEval/748": [
        "import re\n\ndef capital_words_spaces(str1):\n    capital_words = re.findall(r'[A-Z][a-z]*', str1)\n    return ' '.join(capital_words)\n",
        "def capital_words_spaces(str1):\n    words = str1.split()\n    result = []\n    for word in words:\n        if word[0].isupper():\n            result.append(' ' + word)\n        else:\n            result.append(word)\n    return ''.join(result).strip()\n",
        "import re\n\ndef capital_words_spaces(str1):\n    result = \"\"\n    for i, char in enumerate(str1):\n        if i > 0 and char.isupper() and str1[i-1] != \" \":\n            result += \" \"\n        result += char\n    return result\n",
        "import re\n\ndef capital_words_spaces(str1):\n    words = re.findall('[A-Z][^A-Z]*', str1)\n    return ' '.join(words)\n",
        "import re\n\ndef capital_words_spaces(str1):\n    result = \"\"\n    prev_char_space = True # Assume the first character is preceded by a space\n    \n    for char in str1:\n        if char.isupper() and not prev_char_space:\n            result += \" \"\n        result += char\n        prev_char_space = char == \" \"\n    \n    return result\n"
    ],
    "MbppEval/749": [
        "def sort_numeric_strings(nums_str):\n    nums_int = [int(num) for num in nums_str]\n    nums_int.sort()\n    sorted_nums_str = [str(num) for num in nums_int]\n    return sorted_nums_str\n",
        "def sort_numeric_strings(nums_str):\n    nums_int = [int(num) for num in nums_str]\n    nums_int.sort()\n    sorted_nums_str = [str(num) for num in nums_int]\n    return sorted_nums_str\n",
        "def sort_numeric_strings(nums_str):\n    sorted_nums = []\n    for num_str in nums_str:\n        sorted_nums.append(int(num_str))\n    sorted_nums.sort()\n    return sorted_nums\n",
        "def sort_numeric_strings(nums_str):\n    if not isinstance(nums_str, list) or not all(isinstance(x, str) for x in nums_str):\n        raise TypeError(\"Input must be a list of strings\")\n    \n    nums_int = [int(x) for x in nums_str]\n    nums_int.sort()\n    nums_str_sorted = [str(x) for x in nums_int]\n    \n    return nums_str_sorted\n",
        "def sort_numeric_strings(nums_str):\n    nums = [int(num) for num in nums_str]\n    nums.sort()\n    return nums\n"
    ],
    "MbppEval/750": [
        "def add_tuple(test_list, test_tup):\n    return test_list + list(test_tup)\n",
        "def add_tuple(test_list, test_tup):\n    return test_list + list(test_tup)\n",
        "def add_tuple(test_list, test_tup):\n    return test_list + list(test_tup)\n",
        "def add_tuple(test_list, test_tup):\n    return test_list + list(test_tup)\n",
        "def add_tuple(test_list, test_tup):\n    return test_list + list(test_tup)\n"
    ],
    "MbppEval/751": [
        "def check_min_heap_helper(arr, i):\n    n = len(arr)\n    \n    if i >= n:\n        return True\n    \n    left_child = 2 * i + 1\n    right_child = 2 * i + 2\n    \n    if left_child < n and arr[i] > arr[left_child]:\n        return False\n    \n    if right_child < n and arr[i] > arr[right_child]:\n        return False\n    \n    return check_min_heap_helper(arr, left_child) and check_min_heap_helper(arr, right_child)\n",
        "def check_min_heap_helper(arr, i):\n    left_child_idx = 2 * i + 1\n    right_child_idx = 2 * i + 2\n\n    # Check if the left child exists and if the node at index i is greater than the left child\n    if left_child_idx < len(arr) and arr[i] > arr[left_child_idx]:\n        return False\n\n    # Check if the right child exists and if the node at index i is greater than the right child\n    if right_child_idx < len(arr) and arr[i] > arr[right_child_idx]:\n        return False\n\n    # Recursively check the left and right subtrees\n    if left_child_idx < len(arr):\n        if not check_min_heap_helper(arr, left_child_idx):\n            return False\n    if right_child_idx < len(arr):\n        if not check_min_heap_helper(arr, right_child_idx):\n            return False\n\n    # If all checks pass, the subtree rooted at index i is a min-heap\n    return True\n",
        "def check_min_heap_helper(arr, i):\n    left_child_idx = 2 * i + 1\n    right_child_idx = 2 * i + 2\n    \n    # Check if the current node is smaller than its left and right child nodes\n    if left_child_idx < len(arr) and arr[i] > arr[left_child_idx]:\n        return False\n    if right_child_idx < len(arr) and arr[i] > arr[right_child_idx]:\n        return False\n    \n    # Recursively check the left and right subtrees\n    if left_child_idx < len(arr):\n        if not check_min_heap_helper(arr, left_child_idx):\n            return False\n    if right_child_idx < len(arr):\n        if not check_min_heap_helper(arr, right_child_idx):\n            return False\n    \n    return True\n",
        "def check_min_heap_helper(arr, i):\n    left = 2 * i + 1\n    right = 2 * i + 2\n    \n    # Check if the current node is smaller than its left and right children\n    if left < len(arr) and arr[i] > arr[left]:\n        return False\n    if right < len(arr) and arr[i] > arr[right]:\n        return False\n    \n    # Recursively check the left and right subtrees\n    if left < len(arr):\n        if not check_min_heap_helper(arr, left):\n            return False\n    if right < len(arr):\n        if not check_min_heap_helper(arr, right):\n            return False\n    \n    return True\n",
        "def check_min_heap_helper(arr, i):\n    left_child_idx = 2 * i + 1\n    right_child_idx = 2 * i + 2\n    \n    # Check if the current node satisfies the min-heap property\n    if left_child_idx < len(arr) and arr[left_child_idx] < arr[i]:\n        return False\n    if right_child_idx < len(arr) and arr[right_child_idx] < arr[i]:\n        return False\n    \n    # Recursively check the left and right subtrees\n    if left_child_idx < len(arr):\n        if not check_min_heap_helper(arr, left_child_idx):\n            return False\n    if right_child_idx < len(arr):\n        if not check_min_heap_helper(arr, right_child_idx):\n            return False\n    \n    # If we reach this point, the min-heap property is satisfied\n    return True\n"
    ],
    "MbppEval/752": [
        "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return jacobsthal_num(n-1) + jacobsthal_num(n-2) + 2 * jacobsthal_num(n-2)\n",
        "def jacobsthal_num(n):\n    \"\"\"\n    Find the nth Jacobsthal number.\n    \n    Args:\n        n (int): The index of the Jacobsthal number to find.\n    \n    Returns:\n        int: The nth Jacobsthal number.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return jacobsthal_num(n-1) + 2 * jacobsthal_num(n-2)\n",
        "def jacobsthal_num(n):\n    \"\"\"\n    Find the nth Jacobsthal number.\n\n    Args:\n        n (int): The index of the Jacobsthal number to find.\n\n    Returns:\n        int: The nth Jacobsthal number.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return jacobsthal_num(n-1) + jacobsthal_num(n-2) + 1\n",
        "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        j0 = 0\n        j1 = 1\n        for i in range(2, n+1):\n            j2 = j1 + 2 * j0\n            j0 = j1\n            j1 = j2\n        return j1\n",
        "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return jacobsthal_num(n-1) + jacobsthal_num(n-2)\n"
    ],
    "MbppEval/753": [
        "def min_k(test_list, K):\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    return sorted_list[:K]\n",
        "def min_k(test_list, K):\n    return sorted(test_list, key=lambda x: x[1])[:K]\n",
        "def min_k(test_list, K):\n    \"\"\"\n    Write a function to find minimum k records from tuple list.\n    Examples:\n    min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]\n    min_k([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]\n    min_k([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]\n    \"\"\"\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    return sorted_list[:K]\n",
        "def min_k(test_list, K):\n    test_list.sort(key=lambda x: x[1])\n    return test_list[:K]\n",
        "def min_k(test_list, K):\n    test_list.sort(key=lambda x: x[1])\n    return test_list[:K]\n"
    ],
    "MbppEval/754": [
        "def extract_index_list(l1, l2, l3):\n    result = []\n    for x, y, z in zip(l1, l2, l3):\n        if x == y == z:\n            result.append(x)\n    return result\n",
        "def extract_index_list(l1, l2, l3):\n    if len(l1) != len(l2) or len(l2) != len(l3):\n        return []\n\n    common_list = []\n\n    for i in range(len(l1)):\n        if l1[i] == l2[i] == l3[i]:\n            common_list.append(i)\n\n    return common_list\n",
        "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    \n    for i in range(len(l1)):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements\n",
        "def extract_index_list(l1, l2, l3):\n    set1 = set(l1)\n    set2 = set(l2)\n    set3 = set(l3)\n    common_elements = list(set1 & set2 & set3)\n    return common_elements\n",
        "def extract_index_list(l1, l2, l3):\n    result = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    return result\n"
    ],
    "MbppEval/755": [
        "def second_smallest(numbers):\n    if not numbers:\n        return None\n    \n    smallest = None\n    second_smallest = None\n    \n    for num in numbers:\n        if smallest is None or num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif second_smallest is None or (num > smallest and num < second_smallest):\n            second_smallest = num\n    \n    return second_smallest if second_smallest is not None else None\n",
        "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None\n\n    smallest = numbers[0]\n    second_smallest = float('inf')\n\n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest:\n            second_smallest = num\n\n    return second_smallest\n",
        "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None\n    \n    smallest = float('inf')\n    second_smallest = float('inf')\n    \n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    \n    return second_smallest\n",
        "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None\n    \n    smallest = float('inf')\n    second_smallest = float('inf')\n    \n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    \n    if second_smallest == float('inf'):\n        return None\n    else:\n        return second_smallest\n",
        "def second_smallest(numbers):\n    if not numbers:\n        return None\n\n    smallest = numbers[0]\n    second_smallest = numbers[0]\n\n    for num in numbers[1:]:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num > smallest:\n            second_smallest = num\n\n    return second_smallest\n"
    ],
    "MbppEval/756": [
        "import re\n\ndef text_match_zero_one(text):\n    pattern = r'a(b+)'\n    match = re.search(pattern, text)\n    if match:\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_zero_one(text):\n    pattern = r'ab+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_zero_one(text):\n    pattern = r'ab+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_zero_one(text):\n    pattern = r'a(b+)'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_zero_one(text):\n    pattern = r'ab+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n"
    ],
    "MbppEval/757": [
        "def count_reverse_pairs(test_list):\n    unique_strings = set(test_list)\n    count = 0\n    for string in unique_strings:\n        reverse_string = string[::-1]\n        if reverse_string in unique_strings:\n            count += 1\n    \n    # Subtract the number of strings that are their own reverse\n    for string in unique_strings:\n        if string == string[::-1]:\n            count -= 1\n    \n    return str(count // 2)\n",
        "def count_reverse_pairs(test_list):\n    count = 0\n    for word in test_list:\n        reverse_word = word[::-1]\n        if reverse_word in test_list:\n            count += 1\n    return str(count // 2)\n",
        "def count_reverse_pairs(test_list):\n    reverse_dict = {}\n    count = 0\n    for s in test_list:\n        reverse_s = s[::-1]\n        if reverse_s in reverse_dict:\n            count += 1\n            reverse_dict[reverse_s] += 1\n        else:\n            reverse_dict[reverse_s] = 1\n    return str(count)\n",
        "def count_reverse_pairs(test_list):\n    count = 0\n    for item in test_list:\n        if item[::-1] in test_list:\n            count += 1\n    return str(count)\n",
        "def count_reverse_pairs(test_list):\n    \"\"\"\n    Write a function to count the pairs of reverse strings in the given string list.\n    Examples:\n    count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"]) == '2'\n    count_reverse_pairs([\"geeks\", \"best\", \"for\", \"skeeg\"]) == '1'\n    count_reverse_pairs([\"makes\", \"best\", \"sekam\", \"for\", \"rof\"]) == '2'\n    \"\"\"\n    reverse_dict = {}\n    count = 0\n\n    for word in test_list:\n        reverse_word = word[::-1]\n        if reverse_word in reverse_dict:\n            count += 1\n            reverse_dict[reverse_word] += 1\n        else:\n            reverse_dict[word] = 1\n\n    return str(count)\n"
    ],
    "MbppEval/758": [
        "def unique_sublists(list1):\n    count_dict = {}\n    for sublist in list1:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    return count_dict\n",
        "def unique_sublists(list1):\n    count_dict = {}\n    for sublist in list1:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    return count_dict\n",
        "def unique_sublists(list1):\n    sublist_counts = {}\n    for sublist in list1:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_counts:\n            sublist_counts[sublist_tuple] += 1\n        else:\n            sublist_counts[sublist_tuple] = 1\n    return sublist_counts\n",
        "def unique_sublists(list1):\n    sublists_count = {}\n    \n    for sublist in list1:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublists_count:\n            sublists_count[sublist_tuple] += 1\n        else:\n            sublists_count[sublist_tuple] = 1\n    \n    return sublists_count\n",
        "def unique_sublists(list1):\n    result = {}\n    for sublst in list1:\n        sublst = tuple(sublst)\n        if sublst in result:\n            result[sublst] += 1\n        else:\n            result[sublst] = 1\n    return result\n"
    ],
    "MbppEval/759": [
        "import re\n\ndef is_decimal(num):\n    \"\"\"\n    Check whether a given string is a decimal number with a precision of 2.\n\n    Examples:\n    is_decimal('123.11') == True\n    is_decimal('e666.86') == False\n    is_decimal('3.124587') == False\n    \"\"\"\n    if not isinstance(num, str):\n        return False\n\n    pattern = r'^[+-]?\\d+\\.\\d{2}$'\n    return bool(re.match(pattern, num))\n",
        "def is_decimal(num):\n    \"\"\"\n    Write a function to check whether a given string is a decimal number with a precision of 2.\n\n    Examples:\n    is_decimal('123.11') == True\n    is_decimal('e666.86') == False\n    is_decimal('3.124587') == False\n    \"\"\"\n    if '.' not in num:\n        return False\n\n    parts = num.split('.')\n\n    if not parts[0].isdigit():\n        return False\n\n    if len(parts[1]) != 2:\n        return False\n\n    return True\n",
        "import re\n\ndef is_decimal(num):\n    return bool(re.match(r'^\\d+\\.\\d{2}$', num))\n",
        "def is_decimal(num):\n    if not isinstance(num, str):\n        return False\n    if not num.replace('.', '').isdigit() or num.count('.') != 1:\n        return False\n    parts = num.split('.')\n    if len(parts[1]) != 2:\n        return False\n    return True\n",
        "def is_decimal(num):\n    \"\"\"\n    Write a function to check whether a given string is a decimal number with a precision of 2.\n\n    Examples:\n    is_decimal('123.11') == True\n    is_decimal('e666.86') == False\n    is_decimal('3.124587') == False\n    \"\"\"\n    if '.' in num and num.replace('.', '').isdigit():\n        decimal_part = num.split('.')[1]\n        if len(decimal_part) == 2:\n            return True\n    return False\n"
    ],
    "MbppEval/760": [
        "def unique_Element(arr):\n    if len(set(arr)) == 1:\n        return 'YES'\n    else:\n        return 'NO'\n",
        "def unique_Element(arr):\n    if not arr:\n        return 'YES'\n    \n    unique_elements = set(arr)\n    if len(unique_elements) == 1:\n        return 'YES'\n    else:\n        return 'NO'\n",
        "def unique_Element(arr):\n    unique_set = set(arr)\n    if len(unique_set) == 1:\n        return 'YES'\n    else:\n        return 'NO'\n",
        "def unique_Element(arr):\n    unique_count = 0\n    seen = set()\n    for num in arr:\n        if num not in seen:\n            unique_count += 1\n            seen.add(num)\n    return 'YES' if unique_count == 1 else 'NO'\n",
        "def unique_Element(arr):\n    unique_count = 0\n    seen = set()\n    for num in arr:\n        if num not in seen:\n            unique_count += 1\n            seen.add(num)\n    return 'YES' if unique_count == 1 else 'NO'\n"
    ],
    "MbppEval/762": [
        "def check_monthnumber_number(monthnum3):\n    thirty_day_months = [4, 6, 9, 11]\n    if monthnum3 in thirty_day_months:\n        return True\n    else:\n        return False\n",
        "def check_monthnumber_number(monthnum3):\n    thirty_day_months = [4, 6, 9, 11]\n    return monthnum3 in thirty_day_months\n",
        "def check_monthnumber_number(monthnum3):\n    months_with_30_days = [4, 6, 9, 11]\n    return monthnum3 in months_with_30_days\n",
        "def check_monthnumber_number(monthnum3):\n    thirty_day_months = [4, 6, 9, 11]\n    return monthnum3 in thirty_day_months\n",
        "def check_monthnumber_number(monthnum3):\n    if not isinstance(monthnum3, int) or monthnum3 < 1 or monthnum3 > 12:\n        return False\n    return monthnum3 in [4, 6, 9, 11]\n"
    ],
    "MbppEval/763": [
        "def find_min_diff(arr, n):\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        diff = abs(arr[i] - arr[i-1])\n        min_diff = min(min_diff, diff)\n    return min_diff\n",
        "def find_min_diff(arr, n):\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i-1])\n    return min_diff\n",
        "def find_min_diff(arr, n):\n    if n < 2:\n        return 0\n\n    # Initialize min_diff to a very large value\n    min_diff = float('inf')\n\n    # Sort the input array\n    arr.sort()\n\n    # Iterate through the sorted array, calculating the difference between adjacent elements\n    for i in range(1, n):\n        diff = abs(arr[i] - arr[i - 1])\n        if diff < min_diff:\n            min_diff = diff\n\n    return min_diff\n",
        "def find_min_diff(arr, n):\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        diff = abs(arr[i] - arr[i-1])\n        min_diff = min(min_diff, diff)\n    return min_diff\n",
        "def find_min_diff(arr, n):\n    # Sort the array in ascending order\n    arr.sort()\n    \n    # Initialize min_diff to a large value\n    min_diff = float('inf')\n    \n    # Iterate through the sorted array and calculate the difference\n    for i in range(1, n):\n        diff = abs(arr[i] - arr[i-1])\n        min_diff = min(min_diff, diff)\n    \n    return min_diff\n"
    ],
    "MbppEval/764": [
        "def number_ctr(str):\n    count = 0\n    for char in str:\n        if char.isdigit():\n            count += 1\n    return count\n",
        "def number_ctr(str):\n    count = 0\n    for char in str:\n        if char.isdigit():\n            count += 1\n    return count\n",
        "def number_ctr(str):\n    digit_count = 0\n    for char in str:\n        if char.isdigit():\n            digit_count += 1\n    return digit_count\n",
        "def number_ctr(str):\n    \"\"\"\n    Write a python function to count the number of digits in a given string.\n\n    Examples:\n    number_ctr('program2bedone') == 1\n    number_ctr('3wonders') == 1\n    number_ctr('123') == 3\n    \"\"\"\n    count = 0\n    for char in str:\n        if char.isdigit():\n            count += 1\n    return count\n",
        "def number_ctr(str):\n    count = 0\n    for char in str:\n        if char.isdigit():\n            count += 1\n    return count\n"
    ],
    "MbppEval/765": [
        "import math\n\ndef is_polite(n):\n    \"\"\"\n    Find the nth polite number.\n    \"\"\"\n    num = 1\n    while True:\n        if num % n == 0 and num % (n + 1) == 0:\n            return num\n        num += 1\n",
        "import math\n\ndef is_polite(n):\n    count = 0\n    i = 1\n    while count < n:\n        if is_power_of_2(i) or is_sum_of_distinct_powers_of_2(i):\n            count += 1\n        i += 1\n    return i - 1\n\ndef is_power_of_2(x):\n    return (x & (x - 1)) == 0\n\ndef is_sum_of_distinct_powers_of_2(x):\n    temp = x\n    while temp > 0:\n        if (temp & 1) == 1 and (temp & (temp - 1)) != 0:\n            return False\n        temp >>= 1\n    return True\n",
        "import math\n\ndef is_polite(n):\n    \"\"\"\n    Find the nth polite number.\n    \"\"\"\n    polite_numbers = [1]  # Start with the base case of 1\n    i = 1\n    while len(polite_numbers) < n:\n        # Add the next power of 2\n        polite_numbers.append(2 ** i)\n        \n        # Find all the possible sums of distinct powers of 2 less than or equal to the current power of 2\n        for j in range(i):\n            polite_numbers.append(2 ** j + 2 ** i)\n        \n        i += 1\n    \n    return polite_numbers[n-1]\n",
        "import math\n\ndef is_polite(n):\n    \"\"\"\n    Find the nth polite number.\n    \"\"\"\n    if n == 1:\n        return 1\n\n    left, right = 2, n * 2\n    while left <= right:\n        mid = (left + right) // 2\n        divisors = 0\n        for i in range(1, int(math.sqrt(mid)) + 1):\n            if mid % i == 0:\n                divisors += 1\n                if i != mid // i:\n                    divisors += 1\n        if divisors == n:\n            return mid\n        elif divisors < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n",
        "import math\n\ndef is_polite(n):\n    \"\"\"\n    Find the nth polite number.\n    \"\"\"\n    k = 1\n    while True:\n        # Solve the equation n = k * (2a + k - 1) / 2 for a\n        a = (n - k * (k - 1) // 2) / k\n        if a.is_integer() and a > 0:\n            return int(a + (k - 1) / 2)\n        k += 1\n"
    ],
    "MbppEval/766": [
        "def pair_wise(l1):\n    pairs = []\n    for i in range(len(l1) - 1):\n        pairs.append((l1[i], l1[i+1]))\n    return pairs\n",
        "def pair_wise(l1):\n    pairs = []\n    for i in range(len(l1) - 1):\n        pairs.append((l1[i], l1[i+1]))\n    return pairs\n",
        "def pair_wise(l1):\n    pairs = []\n    for i in range(len(l1) - 1):\n        pairs.append((l1[i], l1[i+1]))\n    return pairs\n",
        "def pair_wise(l1):\n    pairs = []\n    for i in range(len(l1) - 1):\n        pairs.append((l1[i], l1[i+1]))\n    return pairs\n",
        "def pair_wise(l1):\n    pairs = []\n    for i in range(len(l1) - 1):\n        pairs.append((l1[i], l1[i+1]))\n    return pairs\n"
    ],
    "MbppEval/767": [
        "def get_pairs_count(arr, target_sum):\n    count = 0\n    element_counts = {}\n\n    for num in arr:\n        if target_sum - num in element_counts:\n            count += element_counts[target_sum - num]\n        element_counts[num] = element_counts.get(num, 0) + 1\n\n    return count\n",
        "def get_pairs_count(arr, target_sum):\n    count = 0\n    seen = {}\n\n    for num in arr:\n        complement = target_sum - num\n        if complement in seen:\n            count += seen[complement]\n        seen[num] = seen.get(num, 0) + 1\n\n    return count\n",
        "def get_pairs_count(arr, target_sum):\n    arr.sort()\n    count = 0\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target_sum:\n            count += 1\n            left += 1\n            right -= 1\n            \n            # Skip over duplicates\n            while left < right and arr[left] == arr[left - 1]:\n                left += 1\n            while left < right and arr[right] == arr[right + 1]:\n                right -= 1\n        elif current_sum < target_sum:\n            left += 1\n        else:\n            right -= 1\n    \n    return count\n",
        "def get_pairs_count(arr, sum):\n    seen = set()\n    count = 0\n    for i in arr:\n        if sum - i in seen:\n            count += 1\n        seen.add(i)\n    return count\n",
        "def get_pairs_count(arr, sum):\n    num_count = {}\n    for num in arr:\n        num_count[num] = num_count.get(num, 0) + 1\n\n    count = 0\n    for a in num_count:\n        b = sum - a\n        if b in num_count:\n            count += num_count[a] * num_count[b]\n\n    return count // 2\n"
    ],
    "MbppEval/769": [
        "def Diff(li1, li2):\n    output = []\n    for item in li1:\n        if item not in li2:\n            output.append(item)\n    for item in li2:\n        if item not in li1:\n            output.append(item)\n    return output\n",
        "def Diff(li1, li2):\n    set1 = set(li1)\n    set2 = set(li2)\n    diff_set = set1.symmetric_difference(set2)\n    return list(diff_set)\n",
        "def Diff(li1, li2):\n    result = []\n    \n    # Iterate through the first list and add elements not in the second list\n    for item in li1:\n        if item not in li2:\n            result.append(item)\n    \n    # Iterate through the second list and add elements not in the first list\n    for item in li2:\n        if item not in li1:\n            result.append(item)\n    \n    return result\n",
        "def Diff(li1, li2):\n    set1 = set(li1)\n    set2 = set(li2)\n    result = list(set1 - set2)\n    return result\n",
        "def Diff(li1, li2):\n    diff = []\n    for item in li1:\n        if item not in li2:\n            diff.append(item)\n    for item in li2:\n        if item not in li1:\n            diff.append(item)\n    return diff\n"
    ],
    "MbppEval/770": [
        "def odd_num_sum(n):\n    sum = 0\n    for i in range(1, 2*n, 2):\n        sum += i ** 4\n    return sum\n",
        "def odd_num_sum(n):\n    sum = 0\n    for i in range(1, 2*n, 2):\n        sum += i**4\n    return sum\n",
        "def odd_num_sum(n):\n    total_sum = 0\n    for i in range(1, 2 * n, 2):\n        total_sum += i ** 4\n    return total_sum\n",
        "def odd_num_sum(n):\n    sum_of_fourth_power = 0\n    for i in range(1, n+1, 2):\n        sum_of_fourth_power += i ** 4\n    return sum_of_fourth_power\n",
        "def odd_num_sum(n):\n    total_sum = 0\n    for i in range(1, 2*n, 2):\n        total_sum += i**4\n    return total_sum\n"
    ],
    "MbppEval/771": [
        "from collections import deque\n\ndef check_expression(exp):\n    bracket_map = {\n        '{': '}',\n        '[': ']',\n        '(': ')'\n    }\n    stack = deque()\n\n    for char in exp:\n        if char in bracket_map:\n            stack.append(char)\n        elif char in bracket_map.values():\n            if not stack:\n                return False\n            top = stack.pop()\n            if bracket_map[top] != char:\n                return False\n\n    return not stack\n",
        "from collections import deque\n\ndef check_expression(exp):\n    \"\"\"\n    Write a function to check if the given expression is balanced or not.\n    \"\"\"\n    brackets = {\n        \"(\": \")\",\n        \"[\": \"]\",\n        \"{\": \"}\"\n    }\n    stack = deque()\n\n    for char in exp:\n        if char in brackets:\n            stack.append(char)\n        elif char in brackets.values():\n            if not stack or brackets[stack.pop()] != char:\n                return False\n\n    return len(stack) == 0\n",
        "from collections import deque\n\ndef check_expression(exp):\n    stack = deque()\n    opening_brackets = '{[('\n    closing_brackets = '}])'\n    bracket_pairs = {'}': '{', ']': '[', ')': '('}\n\n    for char in exp:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack:\n                return False\n            top_bracket = stack.pop()\n            if bracket_pairs[char] != top_bracket:\n                return False\n\n    return len(stack) == 0\n",
        "from collections import deque\n\ndef check_expression(exp):\n    stack = deque()\n    \n    for char in exp:\n        if char in ['{', '(', '[']:\n            stack.append(char)\n        elif char in ['}', ')', ']']:\n            if not stack:\n                return False\n            top = stack.pop()\n            if (char == '}' and top != '{' or \n                char == ')' and top != '(' or\n                char == ']' and top != '['):\n                return False\n    \n    return not stack\n",
        "from collections import deque\n\ndef check_expression(exp):\n    stack = deque()\n    bracket_map = {\n        '{': '}',\n        '(': ')',\n        '[': ']'\n    }\n    \n    for char in exp:\n        if char in bracket_map:\n            stack.append(char)\n        elif char in bracket_map.values():\n            if not stack or bracket_map[stack.pop()] != char:\n                return False\n    \n    return len(stack) == 0\n"
    ],
    "MbppEval/772": [
        "def remove_length(test_str, K):\n    words = test_str.split()\n    new_words = [word for word in words if len(word) != K]\n    return ' '.join(new_words)\n",
        "def remove_length(test_str, K):\n    words = test_str.split()\n    new_words = [word for word in words if len(word) != K]\n    return ' '.join(new_words)\n",
        "def remove_length(test_str, K):\n    words = test_str.split()\n    new_words = [word for word in words if len(word) != K]\n    return ' '.join(new_words)\n",
        "def remove_length(test_str, K):\n    words = test_str.split()\n    new_words = [word for word in words if len(word) != K]\n    return ' '.join(new_words)\n",
        "def remove_length(test_str, K):\n    words = test_str.split()\n    new_words = [word for word in words if len(word) != K]\n    return ' '.join(new_words)\n"
    ],
    "MbppEval/773": [
        "import re\n\ndef occurance_substring(text, pattern):\n    \"\"\"\n    Find the occurrence and position of the substrings within a string.\n    \n    Return a tuple containing the matched substring, start index, and end index.\n    Return None if there is no match.\n    \"\"\"\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return None\n",
        "import re\n\ndef occurance_substring(text, pattern):\n    \"\"\"\n    Write a function to find the occurrence and position of the substrings within a string. Return None if there is no match.\n\n    Examples:\n    occurance_substring('python programming, python language','python') == ('python', 0, 6)\n    occurance_substring('python programming,programming language','programming') == ('programming', 7, 18)\n    occurance_substring('python programming,programming language','language') == ('language', 31, 39)\n    \"\"\"\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return None\n",
        "import re\n\ndef occurance_substring(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return None\n",
        "import re\n\ndef occurance_substring(text, pattern):\n    match = re.search(pattern, text)\n    if not match:\n        return None\n    start = match.start()\n    end = match.end()\n    return (match.group(), start, end)\n",
        "import re\n\ndef occurance_substring(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return None\n"
    ],
    "MbppEval/775": [
        "def odd_position(nums):\n    result = True\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            result = False\n            break\n    return result\n",
        "def odd_position(nums):\n    is_odd_position = True\n    for i in range(len(nums)):\n        if i % 2 == 1 and nums[i] % 2 == 0:\n            is_odd_position = False\n            break\n    return is_odd_position\n",
        "def odd_position(nums):\n    result = True\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            result = False\n            break\n    return result\n",
        "def odd_position(nums):\n    result = True\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            result = False\n            break\n    return result\n",
        "def odd_position(nums):\n    is_odd_position = True\n    for i in range(len(nums)):\n        if i % 2 == 1 and nums[i] % 2 == 0:\n            is_odd_position = False\n            break\n    return is_odd_position\n"
    ],
    "MbppEval/776": [
        "def count_vowels(test_str):\n    count = 0\n    vowels = 'aeiou'\n\n    for i in range(len(test_str)):\n        if test_str[i].lower() in vowels:\n            if (i > 0 and test_str[i-1].lower() in vowels) or (i < len(test_str)-1 and test_str[i+1].lower() in vowels):\n                count += 1\n\n    return count\n",
        "def count_vowels(test_str):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    \n    for i in range(len(test_str)):\n        if test_str[i] in vowels:\n            if (i > 0 and test_str[i-1] in vowels) or (i < len(test_str)-1 and test_str[i+1] in vowels):\n                count += 1\n    \n    return count\n",
        "def count_vowels(test_str):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    \n    for i in range(len(test_str)):\n        if test_str[i] in vowels:\n            if (i > 0 and test_str[i-1] in vowels) or (i < len(test_str)-1 and test_str[i+1] in vowels):\n                count += 1\n    \n    return count\n",
        "def count_vowels(test_str):\n    vowels = set('aeiou')\n    char_list = list(test_str)\n    count = 0\n\n    for i in range(len(char_list)):\n        if i == 0 or i == len(char_list) - 1:\n            if char_list[i] in vowels:\n                count += 1\n        else:\n            if char_list[i-1] in vowels and char_list[i+1] in vowels:\n                count += 1\n\n    return count\n",
        "def count_vowels(test_str):\n    vowels = 'aeiou'\n    count = 0\n    \n    for i in range(1, len(test_str)-1):\n        if test_str[i] in vowels and test_str[i-1] in vowels and test_str[i+1] in vowels:\n            count += 1\n    \n    return count\n"
    ],
    "MbppEval/777": [
        "def find_sum(arr, k):\n    total = 0\n    unique_nums = set()\n    for num in arr:\n        if num not in unique_nums:\n            unique_nums.add(num)\n            total += num\n    return total\n",
        "def find_sum(arr):\n    unique_set = set(arr)\n    total_sum = sum(unique_set)\n    return total_sum\n",
        "def find_sum(arr):\n    total = 0\n    unique_elements = set()\n\n    for num in arr:\n        if num not in unique_elements:\n            unique_elements.add(num)\n            total += num\n\n    return total\n",
        "def find_sum(arr):\n    \"\"\"\n    Write a python function to find the sum of non-repeated elements in a given list.\n\n    Examples:\n    find_sum([1,2,3,1,1,4,5,6]) == 21\n    find_sum([1,10,9,4,2,10,10,45,4]) == 71\n    find_sum([12,10,9,45,2,10,10,45,10]) == 78\n    \"\"\"\n    unique_elements = set(arr)\n    return sum(unique_elements)\n",
        "def find_sum(arr):\n    sum_of_unique = 0\n    unique_elements = set()\n    \n    for num in arr:\n        if num not in unique_elements:\n            unique_elements.add(num)\n            sum_of_unique += num\n    \n    return sum_of_unique\n"
    ],
    "MbppEval/778": [
        "from itertools import groupby\n\ndef pack_consecutive_duplicates(list1):\n    return [list(group) for _, group in groupby(list1)]\n",
        "from itertools import groupby\n\ndef pack_consecutive_duplicates(list1):\n    result = []\n    for _, group in groupby(list1):\n        result.append(list(group))\n    return result\n",
        "from itertools import groupby\n\ndef pack_consecutive_duplicates(list1):\n    result = []\n    for _, group in groupby(list1):\n        result.append(list(group))\n    return result\n",
        "from itertools import groupby\n\ndef pack_consecutive_duplicates(list1):\n    result = []\n    for _, group in groupby(list1):\n        result.append(list(group))\n    return result\n",
        "from itertools import groupby\n\ndef pack_consecutive_duplicates(list1):\n    result = []\n    for _, group in groupby(list1):\n        result.append(list(group))\n    return result\n"
    ],
    "MbppEval/779": [
        "def unique_sublists(list1):\n    result = {}\n    for sublist in list1:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        else:\n            result[sublist_tuple] = 1\n    return result\n",
        "def unique_sublists(list1):\n    \"\"\"\n    Write a function to count the number of lists within a list. The function should return a dictionary, where every list is turned to a tuple, and the value of the tuple is the number of its occurrences.\n    \"\"\"\n    sublists_count = {}\n    for sublist in list1:\n        sublist_tuple = tuple(sublist)\n        sublists_count[sublist_tuple] = sublists_count.get(sublist_tuple, 0) + 1\n    return sublists_count\n",
        "def unique_sublists(list1):\n    result = {}\n    for sublist in list1:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        else:\n            result[sublist_tuple] = 1\n    return result\n",
        "def unique_sublists(list1):\n    sublist_counts = {}\n    for sublist in list1:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_counts:\n            sublist_counts[sublist_tuple] += 1\n        else:\n            sublist_counts[sublist_tuple] = 1\n    return sublist_counts\n",
        "def unique_sublists(list1):\n    result = {}\n    for sub_list in list1:\n        sub_list_tuple = tuple(sub_list)\n        if sub_list_tuple in result:\n            result[sub_list_tuple] += 1\n        else:\n            result[sub_list_tuple] = 1\n    return result\n"
    ],
    "MbppEval/780": [
        "from itertools import combinations \n\ndef find_combinations(test_list):\n    combinations_list = list(combinations(test_list, 2))\n    sums = [(a + b, c + d) for (a, b), (c, d) in combinations_list]\n    return sums\n",
        "from itertools import combinations\n\ndef find_combinations(test_list):\n    return [(a[0] + b[0], a[1] + b[1]) for a, b in combinations(test_list, 2)]\n",
        "def find_combinations(test_list):\n    combinations_list = []\n    for tup in test_list:\n        sum1 = tup[0]\n        sum2 = tup[1]\n        combinations_list.append((sum1, sum2))\n    return combinations_list\n",
        "from itertools import combinations\n\ndef find_combinations(test_list):\n    result = []\n    for a, b in combinations(test_list, 2):\n        result.append((a[0] + b[0], a[1] + b[1]))\n    return result\n",
        "from itertools import combinations\n\ndef find_combinations(test_list):\n    result = []\n    for a, b in combinations(test_list, 2):\n        result.append((a[0] + b[0], a[1] + b[1]))\n    return result\n"
    ],
    "MbppEval/781": [
        "import math\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            count += 1\n            if i * i == n:\n                count -= 1\n    if count % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n",
        "import math\n\ndef is_even_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of a number n is even.\n    \"\"\"\n    # Find the prime factorization of n\n    prime_factors = []\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            prime_factors.append(i)\n            n //= i\n        else:\n            i += 1\n    if n > 2:\n        prime_factors.append(n)\n\n    # Calculate the number of divisors\n    num_divisors = 1\n    for factor in prime_factors:\n        num_divisors *= (factor + 1)\n\n    # Determine if the number of divisors is even or odd\n    if num_divisors % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n",
        "import math\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    \n    if count % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n",
        "import math\n\ndef count_divisors(n):\n    divisors = []\n    for i in range(1, n+1):\n        if n % i == 0:\n            divisors.append(i)\n    \n    if len(divisors) % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n",
        "import math\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            count += 2\n    if math.sqrt(n).is_integer():\n        count -= 1\n    if count % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n"
    ],
    "MbppEval/782": [
        "def odd_length_sum(arr):\n    total_sum = 0\n    left = 0\n    right = 0\n\n    while right < len(arr):\n        if (right - left + 1) % 2 != 0:\n            total_sum += sum(arr[left:right+1])\n        right += 1\n\n        if (right - left + 1) % 2 == 0:\n            left += 1\n\n    return total_sum\n",
        "def odd_length_sum(arr):\n    total_sum = 0\n    prefix_sum = [0] * (len(arr) + 1)\n    \n    for i in range(1, len(arr) + 1):\n        prefix_sum[i] = prefix_sum[i-1] + arr[i-1]\n    \n    for i in range(1, len(arr) + 1):\n        odd_length_subarrays = (i + 1) // 2\n        total_sum += odd_length_subarrays * arr[i-1]\n    \n    return total_sum\n",
        "def odd_length_sum(arr):\n    total_sum = 0\n    current_sum = 0\n    current_length = 0\n    for num in arr:\n        current_sum += num\n        current_length += 1\n        if current_length % 2 == 1:\n            total_sum += current_sum\n        else:\n            current_sum = 0\n    return total_sum\n",
        "def odd_length_sum(arr):\n    total_sum = sum(arr)\n    odd_sum = sum(arr[i] ** 2 for i in range(len(arr)) if i % 2 != 0)\n    return total_sum + odd_sum\n",
        "def odd_length_sum(arr):\n    total_sum = 0\n    current_sum = 0\n    for num in arr:\n        current_sum += num\n        if len(str(current_sum)) % 2 != 0:\n            total_sum += current_sum\n    return total_sum\n"
    ],
    "MbppEval/783": [
        "import math\n\ndef rgb_to_hsv(r, g, b):\n    r, g, b = r/255.0, g/255.0, b/255.0\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx - mn\n    if mx == mn:\n        h = 0\n    elif mx == r:\n        h = (60 * ((g-b)/df)+360) % 360\n    elif mx == g:\n        h = (60 * ((b-r)/df)+120) % 360\n    elif mx == b:\n        h = (60 * ((r-g)/df)+240) % 360\n    if mx == 0:\n        s = 0\n    else:\n        s = (df/mx)*100\n    v = mx*100\n    return h, s, v\n",
        "def rgb_to_hsv(r, g, b):\n    \"\"\"\n    Convert RGB color to HSV color.\n\n    Args:\n        r (int): The red value in the range [0, 255].\n        g (int): The green value in the range [0, 255].\n        b (int): The blue value in the range [0, 255].\n\n    Returns:\n        tuple: The HSV values as a tuple (h, s, v), where:\n            h is the hue in the range [0, 360),\n            s is the saturation in the range [0, 100],\n            v is the value in the range [0, 100].\n    \"\"\"\n    # Normalize the RGB values to the range [0, 1]\n    r, g, b = r/255, g/255, b/255\n\n    # Calculate the maximum and minimum of the RGB values\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n\n    # Calculate the hue (H)\n    if mx == mn:\n        h = 0\n    elif mx == r:\n        h = (60 * ((g-b)/(mx-mn)) + 360) % 360\n    elif mx == g:\n        h = (60 * ((b-r)/(mx-mn)) + 120) % 360\n    elif mx == b:\n        h = (60 * ((r-g)/(mx-mn)) + 240) % 360\n\n    # Calculate the saturation (S)\n    if mx == 0:\n        s = 0\n    else:\n        s = (1 - mn/mx) * 100\n\n    # Calculate the value (V)\n    v = mx * 100\n\n    return h, s, v\n",
        "import math\n\ndef rgb_to_hsv(r, g, b):\n    r, g, b = r/255.0, g/255.0, b/255.0\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx - mn\n    if mx == 0:\n        s = 0\n    else:\n        s = (df/mx)*100\n    if df == 0:\n        h = 0\n    elif mx == r:\n        h = (60 * ((g-b)/df)+360)%360\n    elif mx == g:\n        h = (60 * ((b-r)/df)+120)%360\n    elif mx == b:\n        h = (60 * ((r-g)/df)+240)%360\n    v = mx*100\n    return h, s, v\n",
        "def rgb_to_hsv(r, g, b):\n    r, g, b = r/255.0, g/255.0, b/255.0\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx - mn\n    if mx == 0:\n        s = 0\n    else:\n        s = (df/mx)*100\n    if df == 0:\n        h = 0\n    elif mx == r:\n        h = (g - b)/df * 60 + 0\n    elif mx == g:\n        h = (b - r)/df * 60 + 120\n    elif mx == b:\n        h = (r - g)/df * 60 + 240\n    if h < 0:\n        h += 360\n    return h, s, mx*100\n",
        "import math\n\ndef rgb_to_hsv(r, g, b):\n    r, g, b = r/255.0, g/255.0, b/255.0\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx - mn\n    if mx == 0:\n        s = 0\n    else:\n        s = (df/mx)*100\n    if df == 0:\n        h = 0\n    elif mx == r:\n        h = (60 * ((g-b)/df)+360)%360\n    elif mx == g:\n        h = (60 * ((b-r)/df)+120)%360\n    elif mx == b:\n        h = (60 * ((r-g)/df)+240)%360\n    v = mx*100\n    return h, s, v\n"
    ],
    "MbppEval/784": [
        "def mul_even_odd(list1):\n    if not list1:\n        return 0\n    \n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        elif first_odd is None and num % 2 != 0:\n            first_odd = num\n        \n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None:\n        return first_odd or 0\n    elif first_odd is None:\n        return first_even or 0\n    else:\n        return first_even * first_odd\n",
        "def find_first_even_odd(list1):\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    return first_even, first_odd\n\ndef multiply_first_even_odd(even_num, odd_num):\n    if even_num is None or odd_num is None:\n        raise ValueError(\"Both even and odd numbers must be provided.\")\n    return even_num * odd_num\n\ndef mul_even_odd(list1):\n    first_even, first_odd = find_first_even_odd(list1)\n    return multiply_first_even_odd(first_even, first_odd)\n",
        "def mul_even_odd(list1):\n    first_even = None\n    first_odd = None\n    product = 1\n\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n\n    if first_even is not None and first_odd is not None:\n        product = first_even * first_odd\n\n    return product\n",
        "def mul_even_odd(list1):\n    if not list1:\n        return 0\n    \n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        \n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None or first_odd is None:\n        return 0\n    \n    return first_even * first_odd\n",
        "def mul_even_odd(list1):\n    even_num = None\n    odd_num = None\n\n    for num in list1:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        elif odd_num is None and num % 2 != 0:\n            odd_num = num\n\n        if even_num is not None and odd_num is not None:\n            return even_num * odd_num\n\n    return None\n"
    ],
    "MbppEval/785": [
        "def tuple_str_int(test_str):\n    \"\"\"\n    Write a function to convert tuple string to integer tuple.\n\n    Examples:\n    tuple_str_int(\"(7, 8, 9)\") == (7, 8, 9)\n    tuple_str_int(\"(1, 2, 3)\") == (1, 2, 3)\n    tuple_str_int(\"(4, 5, 6)\") == (4, 5, 6)\n    \"\"\"\n    if not test_str or not test_str.startswith(\"(\") or not test_str.endswith(\")\"):\n        raise ValueError(\"Invalid input string format\")\n\n    stripped_str = test_str.strip(\"()\")\n    elements = [int(elem.strip()) for elem in stripped_str.split(\",\")]\n    return tuple(elements)\n",
        "def tuple_str_int(test_str):\n    str_elements = test_str[1:-1]\n    elements = str_elements.split(\", \")\n    return tuple(int(elem) for elem in elements)\n",
        "def tuple_str_int(test_str):\n    return tuple(int(x) for x in test_str.strip(\"()\").split(\", \"))\n",
        "def tuple_str_int(test_str):\n    \"\"\"\n    Write a function to convert tuple string to integer tuple.\n\n    Examples:\n    tuple_str_int(\"(7, 8, 9)\") == (7, 8, 9)\n    tuple_str_int(\"(1, 2, 3)\") == (1, 2, 3)\n    tuple_str_int(\"(4, 5, 6)\") == (4, 5, 6)\n    \"\"\"\n    if not test_str.startswith(\"(\") or not test_str.endswith(\")\"):\n        raise ValueError(\"Input string must be a tuple in the format '(int, int, int)'\")\n\n    tuple_str = test_str[1:-1]\n    tuple_elements = tuple_str.split(\", \")\n    tuple_ints = [int(elem) for elem in tuple_elements]\n    result_tuple = tuple(tuple_ints)\n\n    return result_tuple\n",
        "def tuple_str_int(test_str):\n    \"\"\"\n    Write a function to convert tuple string to integer tuple.\n\n    Examples:\n    tuple_str_int(\"(7, 8, 9)\") == (7, 8, 9)\n    tuple_str_int(\"(1, 2, 3)\") == (1, 2, 3)\n    tuple_str_int(\"(4, 5, 6)\") == (4, 5, 6)\n    \"\"\"\n    tuple_str = test_str.strip(\"()\")\n    str_list = tuple_str.split(\", \")\n    int_list = [int(x) for x in str_list]\n    return tuple(int_list)\n"
    ],
    "MbppEval/786": [
        "import bisect\n\ndef right_insertion(a, x):\n    return bisect.bisect_right(a, x)\n",
        "import bisect\n\ndef right_insertion(a, x):\n    return bisect.bisect_right(a, x)\n",
        "import bisect\n\ndef right_insertion(a, x):\n    return bisect.bisect_right(a, x)\n",
        "import bisect\n\ndef right_insertion(a, x):\n    return bisect.bisect_right(a, x)\n",
        "import bisect\n\ndef right_insertion(a, x):\n    return bisect.bisect_right(a, x)\n"
    ],
    "MbppEval/787": [
        "import re\n\ndef text_match_three(text):\n    pattern = r'ab{3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_three(text):\n    pattern = r'a...b'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_three(text):\n    pattern = r'ab{3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_three(text):\n    pattern = r'a...b{3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_match_three(text):\n    pattern = r'ab{3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n"
    ],
    "MbppEval/788": [
        "def new_tuple(test_list, test_str):\n    return (*test_list, test_str)\n",
        "def new_tuple(test_list, test_str):\n    return (*test_list, test_str)\n",
        "def new_tuple(test_list, test_str):\n    return tuple(test_list + (test_str,))\n",
        "def new_tuple(test_list, test_str):\n    return tuple(test_list + [test_str])\n",
        "def new_tuple(test_list, test_str):\n    new_tup = ()\n    for item in test_list:\n        new_tup += (item,)\n    new_tup += (test_str,)\n    return new_tup\n"
    ],
    "MbppEval/790": [
        "def even_position(nums):\n    \"\"\"\n    Write a python function to check whether every even index contains even numbers of a given list.\n\n    Examples:\n    even_position([3,2,1]) == False\n    even_position([1,2,3]) == False\n    even_position([2,1,4]) == True\n    \"\"\"\n    result = True\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            result = False\n            break\n    return result\n",
        "def even_position(nums):\n    result = True\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            result = False\n            break\n    return result\n",
        "def even_position(nums):\n    is_even_pos = True\n    for i in range(len(nums)):\n        if i % 2 == 0 and nums[i] % 2 != 0:\n            is_even_pos = False\n            break\n    return is_even_pos\n",
        "def even_position(nums):\n    is_even_position = True\n    for i, num in enumerate(nums):\n        if i % 2 == 0 and num % 2 != 0:\n            is_even_position = False\n            break\n    return is_even_position\n",
        "def even_position(nums):\n    result = True\n    for i in range(len(nums)):\n        if i % 2 == 0 and nums[i] % 2 != 0:\n            result = False\n            break\n    return result\n"
    ],
    "MbppEval/791": [
        "def remove_nested(test_tup):\n    result = []\n    for item in test_tup:\n        if not isinstance(item, tuple):\n            result.append(item)\n    return tuple(result)\n",
        "def remove_nested(test_tup):\n    result = []\n    for item in test_tup:\n        if not isinstance(item, tuple):\n            result.append(item)\n    return tuple(result)\n",
        "def remove_nested(test_tup):\n    result = []\n    for item in test_tup:\n        if not isinstance(item, tuple):\n            result.append(item)\n    return tuple(result)\n",
        "def remove_nested(test_tup):\n    if not test_tup:\n        return ()\n    return tuple(x for x in test_tup if not isinstance(x, tuple))\n",
        "def remove_nested(test_tup):\n    result = []\n    for item in test_tup:\n        if not isinstance(item, tuple):\n            result.append(item)\n    return tuple(result)\n"
    ],
    "MbppEval/792": [
        "def count_list(input_list):\n    count = 0\n    for element in input_list:\n        if isinstance(element, list):\n            count += 1\n    return count\n",
        "def count_list(input_list):\n    \"\"\"\n    Write a python function to count the number of lists in a given number of lists.\n\n    Examples:\n    count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4\n    count_list([[1,2],[2,3],[4,5]]) == 3\n    count_list([[1,0],[2,0]]) == 2\n    \"\"\"\n    return sum(1 for element in input_list if isinstance(element, list))\n",
        "def count_list(input_list):\n    return sum(isinstance(element, list) for element in input_list)\n",
        "def count_list(input_list):\n    count = 0\n    for element in input_list:\n        if isinstance(element, list):\n            count += 1\n    return count\n",
        "def count_list(input_list):\n    count = 0\n    for element in input_list:\n        if isinstance(element, list):\n            count += 1\n    return count\n"
    ],
    "MbppEval/793": [
        "def last(arr, x, n):\n    left = 0\n    right = n - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == x:\n            while mid < n and arr[mid] == x:\n                mid += 1\n            return mid - 1\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n",
        "def last(arr, x):\n    last_index = -1\n    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == x:\n            last_index = i\n            break\n    return last_index\n",
        "def last(arr, x, n):\n    left = 0\n    right = n - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == x:\n            right = mid - 1\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    if left > right:\n        return -1\n    else:\n        return right + 1\n",
        "def last(arr, x, n):\n    left = 0\n    right = n - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n",
        "def last(arr, x, n):\n    left = 0\n    right = n - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == x:\n            left = mid + 1\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    if left == 0:\n        return -1\n    else:\n        return left - 1\n"
    ],
    "MbppEval/794": [
        "import re\n\ndef text_starta_endb(text):\n    pattern = r'^a.*b$'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
        "import re\n\ndef text_starta_endb(text):\n    pattern = r'^a.*b$'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
        "import re\n\ndef text_starta_endb(text):\n    pattern = r'a.*b$'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
        "import re\n\ndef text_starta_endb(text):\n    pattern = r'^a.*b$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
        "import re\n\ndef text_starta_endb(text):\n    pattern = r'a.*b$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n"
    ],
    "MbppEval/796": [
        "def return_sum(d):\n    total_sum = 0\n    for value in d.values():\n        total_sum += value\n    return total_sum\n",
        "def return_sum(dict_input):\n    total_sum = 0\n    for value in dict_input.values():\n        total_sum += value\n    return total_sum\n",
        "def return_sum(dictionary):\n    total = 0\n    for value in dictionary.values():\n        total += value\n    return total\n",
        "def return_sum(dict):\n    total = 0\n    for value in dict.values():\n        total += value\n    return total\n",
        "def return_sum(dict):\n    total_sum = 0\n    for value in dict.values():\n        total_sum += value\n    return total_sum\n"
    ],
    "MbppEval/797": [
        "def sum_odd(l, r):\n    total = 0\n    for num in range(l, r+1):\n        if num % 2 == 1:\n            total += num\n    return total\n",
        "def sum_odd(l, r):\n    sum = 0\n    for num in range(l, r + 1):\n        if num % 2 != 0:\n            sum += num\n    return sum\n",
        "def sum_odd(l, r):\n    sum = 0\n    for num in range(l, r+1):\n        if num % 2 != 0:\n            sum += num\n    return sum\n",
        "def sum_odd(l, r):\n    total = 0\n    for num in range(l, r+1):\n        if num % 2 != 0:\n            total += num\n    return total\n",
        "def sum_odd(l, r):\n    result = 0\n    for num in range(l, r+1):\n        if num % 2 != 0:\n            result += num\n    return result\n"
    ],
    "MbppEval/798": [
        "def _sum(arr):\n    total = 0\n    for num in arr:\n        total += num\n    return total\n",
        "def _sum(arr):\n    total = 0\n    for num in arr:\n        total += num\n    return total\n",
        "def _sum(arr):\n    total = 0\n    for num in arr:\n        total += num\n    return total\n",
        "def _sum(arr):\n    total = 0\n    for num in arr:\n        total += num\n    return total\n",
        "def _sum(arr):\n    total = 0\n    for num in arr:\n        total += num\n    return total\n"
    ],
    "MbppEval/799": [
        "def left_rotate(n, d):\n    \"\"\"\n    Rotate the bits of the 32-bit integer `n` to the left by `d` bits.\n    \"\"\"\n    return (n << d) | (n >> (32 - d))\n",
        "def left_rotate(n, d):\n    n &= 0xFFFFFFFF\n    return (n << d) | (n >> (32 - d))\n",
        "def left_rotate(n, d):\n    bin_n = format(n, '032b')\n    rotated_bits = bin_n[d:] + bin_n[:d]\n    return int(rotated_bits, 2)\n",
        "def left_rotate(n, d):\n    \"\"\"\n    Rotate the bits of a 32-bit number `n` to the left by `d` bits.\n\n    Args:\n        n (int): The number to be rotated.\n        d (int): The number of bits to rotate left.\n\n    Returns:\n        int: The rotated number.\n    \"\"\"\n    left_shift = d % 32\n    return ((n << left_shift) | (n >> (32 - left_shift))) & 0xFFFFFFFF\n",
        "def left_rotate(n, d):\n    d = d % 32\n    left_bits = n << d\n    right_bits = n >> (32 - d)\n    rotated_num = left_bits | right_bits\n    return rotated_num\n"
    ],
    "MbppEval/800": [
        "import re\n\ndef remove_all_spaces(text):\n    return re.sub(r'\\s+', '', text)\n",
        "import re\n\ndef remove_all_spaces(text):\n    return re.sub(r'\\s+', '', text)\n",
        "import re\n\ndef remove_all_spaces(text):\n    return re.sub(r'\\s+', '', text)\n",
        "import re\n\ndef remove_all_spaces(text):\n    return re.sub(r'\\s+', '', text)\n",
        "import re\n\ndef remove_all_spaces(text):\n    return re.sub(r'\\s+', '', text)\n"
    ],
    "MbppEval/801": [
        "def test_three_equal(x, y, z):\n    count = 0\n    if x == y == z:\n        count = 3\n    elif x == y or x == z or y == z:\n        count = 2\n    return count\n",
        "def test_three_equal(x, y, z):\n    unique_values = len(set([x, y, z]))\n    return 3 - unique_values\n",
        "def test_three_equal(x, y, z):\n    count = 0\n    \n    if x == y == z:\n        count = 3\n    elif x == y or y == z or x == z:\n        count = 2\n    else:\n        count = 0\n    \n    return count\n",
        "def test_three_equal(x, y, z):\n    count = 0\n    if x == y == z:\n        count = 3\n    elif x == y or y == z or x == z:\n        count = 2\n    return count\n",
        "def test_three_equal(x, y, z):\n    count = 0\n    if x == y == z:\n        count = 3\n    elif x == y or x == z or y == z:\n        count = 2\n    return count\n"
    ],
    "MbppEval/802": [
        "def count_rotation(arr):\n    n = len(arr)\n    min_element = min(arr)\n    return arr.index(min_element)\n",
        "def count_rotation(arr, n):\n    left = 0\n    right = n - 1\n\n    while left < right:\n        mid = (left + right) // 2\n\n        if arr[mid] > arr[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n",
        "def count_rotation(arr, n):\n    low = 0\n    high = n - 1\n    \n    while low < high:\n        mid = (low + high) // 2\n        \n        if arr[mid] > arr[high]:\n            low = mid + 1\n        else:\n            high = mid\n    \n    return high\n",
        "def count_rotation(arr):\n    min_element = arr[0]\n    min_index = 0\n\n    for i in range(len(arr)):\n        if arr[i] < min_element:\n            min_element = arr[i]\n            min_index = i\n\n    return min_index\n",
        "def count_rotation(arr, n):\n    left = 0\n    right = n - 1\n\n    while left < right:\n        mid = (left + right) // 2\n\n        if arr[mid] > arr[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n"
    ],
    "MbppEval/803": [
        "import math\n\ndef is_perfect_square(n):\n    \"\"\"\n    Write a function to check whether the given number is a perfect square or not.\n    Examples:\n    is_perfect_square(10) == False\n    is_perfect_square(36) == True\n    is_perfect_square(14) == False\n    \"\"\"\n    sqrt = math.sqrt(n)\n    return sqrt.is_integer()\n",
        "import math\n\ndef is_perfect_square(n):\n    \"\"\"\n    Check whether the given number is a perfect square or not.\n    \n    Args:\n        n (int): The number to be checked.\n    \n    Returns:\n        bool: True if the input number is a perfect square, False otherwise.\n    \"\"\"\n    sqrt = math.sqrt(n)\n    return sqrt.is_integer()\n",
        "def is_perfect_square(n):\n    sqrt = n ** 0.5\n    return sqrt.is_integer()\n",
        "import math\n\ndef is_perfect_square(n):\n    sqrt = math.sqrt(n)\n    return sqrt.is_integer()\n",
        "import math\n\ndef is_perfect_square(n):\n    sqrt = math.sqrt(n)\n    return sqrt.is_integer()\n"
    ],
    "MbppEval/804": [
        "def is_product_even(arr):\n    product = 1\n    for num in arr:\n        product *= num\n    return product % 2 == 0\n",
        "def is_product_even(arr):\n    product = 1\n    for num in arr:\n        product *= num\n    return product % 2 == 0\n",
        "def is_product_even(arr):\n    product = 1\n    for num in arr:\n        product *= num\n    return product % 2 == 0\n",
        "def is_product_even(arr, n):\n    product = 1\n    for num in arr:\n        product *= num\n    return product % 2 == 0\n",
        "def is_product_even(arr):\n    product = 1\n    for num in arr:\n        product *= num\n    return product % 2 == 0\n"
    ],
    "MbppEval/805": [
        "def max_sum_list(lists):\n    max_sum = 0\n    max_list = None\n    \n    for lst in lists:\n        curr_sum = sum(lst)\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n            max_list = lst\n    \n    return max_list\n",
        "def max_sum_list(lists):\n    max_sum = 0\n    max_list = []\n    \n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list\n",
        "def max_sum_list(lists):\n    max_sum = 0\n    max_list = None\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list\n",
        "def max_sum_list(lists):\n    max_sum = 0\n    max_list = None\n    \n    for l in lists:\n        curr_sum = sum(l)\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n            max_list = l\n    \n    return max_list\n",
        "def max_sum_list(lists):\n    max_sum = 0\n    max_list = None\n    \n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list\n"
    ],
    "MbppEval/806": [
        "def max_run_uppercase(test_str):\n    max_run = 0\n    current_run = 0\n    \n    for char in test_str:\n        if char.isupper():\n            current_run += 1\n        else:\n            max_run = max(max_run, current_run)\n            current_run = 0\n    \n    max_run = max(max_run, current_run)\n    \n    return max_run\n",
        "def max_run_uppercase(test_str):\n    max_run = 0\n    current_run = 0\n\n    for char in test_str:\n        if char.isupper():\n            current_run += 1\n        else:\n            current_run = 0\n\n        if current_run > max_run:\n            max_run = current_run\n\n    return max_run\n",
        "def max_run_uppercase(test_str):\n    max_run = 0\n    current_run = 0\n    for char in test_str:\n        if char.isupper():\n            current_run += 1\n        else:\n            current_run = 0\n        max_run = max(max_run, current_run)\n    return max_run\n",
        "def max_run_uppercase(test_str):\n    max_run = 0\n    current_run = 0\n    \n    for char in test_str:\n        if char.isupper():\n            current_run += 1\n        else:\n            current_run = 0\n        \n        if current_run > max_run:\n            max_run = current_run\n    \n    return max_run\n",
        "def max_run_uppercase(test_str):\n    max_run = 0\n    current_run = 0\n    \n    for char in test_str:\n        if char.isupper():\n            current_run += 1\n        else:\n            current_run = 0\n        \n        max_run = max(max_run, current_run)\n    \n    return max_run\n"
    ],
    "MbppEval/807": [
        "def first_odd(nums):\n    first_odd_num = None\n    for num in nums:\n        if num % 2 != 0:\n            first_odd_num = num\n            break\n    return first_odd_num\n",
        "def first_odd(nums):\n    first_odd_num = None\n    for num in nums:\n        if num % 2 != 0:\n            first_odd_num = num\n            break\n    return first_odd_num\n",
        "def first_odd(nums):\n    first_odd_num = None\n    for num in nums:\n        if num % 2 != 0:\n            first_odd_num = num\n            break\n    return first_odd_num\n",
        "def first_odd(nums):\n    if not nums:\n        return None\n    \n    for num in nums:\n        if num % 2 != 0:\n            return num\n    \n    return None\n",
        "def first_odd(nums):\n    first_odd_num = None\n    \n    for num in nums:\n        if num % 2 != 0:\n            first_odd_num = num\n            break\n    \n    return first_odd_num\n"
    ],
    "MbppEval/808": [
        "def check_K(test_tup, K):\n    for element in test_tup:\n        if element == K:\n            return True\n    return False\n",
        "def check_K(test_tup, K):\n    contains_K = False\n    for element in test_tup:\n        if element == K:\n            contains_K = True\n            break\n    return contains_K\n",
        "def check_K(test_tup, K):\n    contains_K = False\n    for element in test_tup:\n        if element == K:\n            contains_K = True\n            break\n    return contains_K\n",
        "def check_K(test_tup, K):\n    contains_K = False\n    for elem in test_tup:\n        if elem == K:\n            contains_K = True\n            break\n    return contains_K\n",
        "def check_K(test_tup, K):\n    found = False\n    for elem in test_tup:\n        if elem == K:\n            found = True\n            break\n    return found\n"
    ],
    "MbppEval/809": [
        "def check_smaller(test_tup1, test_tup2):\n    for i in range(len(test_tup1)):\n        if test_tup2[i] >= test_tup1[i]:\n            return False\n    return True\n",
        "def check_smaller(test_tup1, test_tup2):\n    result = True\n    for i in range(len(test_tup1)):\n        if test_tup2[i] >= test_tup1[i]:\n            result = False\n            break\n    return result\n",
        "def check_smaller(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        return False\n    for i in range(len(test_tup1)):\n        if test_tup2[i] >= test_tup1[i]:\n            return False\n    return True\n",
        "def check_smaller(test_tup1, test_tup2):\n    is_smaller = True\n    for i in range(len(test_tup1)):\n        if test_tup2[i] >= test_tup1[i]:\n            is_smaller = False\n            break\n    return is_smaller\n",
        "def check_smaller(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        return False\n    \n    for i in range(len(test_tup1)):\n        if test_tup2[i] >= test_tup1[i]:\n            return False\n    \n    return True\n"
    ]
}
{
    "MbppEval/80": "def tetrahedral_number(n): \n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    tetrahedral_num = n * (n + 1) * (n + 2) / 6\n    return float(tetrahedral_num)\n",
    "MbppEval/79": "def word_len(s):\n    if len(s) % 2 == 0:\n        return False\n    else:\n        return True\n",
    "MbppEval/82": "import math\n\ndef volume_sphere(r):\n    volume = (4/3) * math.pi * r**3\n    return volume\n",
    "MbppEval/93": "def power(a, b):\n    result = 1\n    for _ in range(b):\n        result *= a\n    return result\n",
    "MbppEval/89": "def closest_num(N):\n    closest_smaller = N - 1\n    return closest_smaller\n",
    "MbppEval/103": "import math\n\ndef binomial_coefficient(n, k):\n    return math.comb(n, k)\n",
    "MbppEval/71": "    return nums\n",
    "MbppEval/118": "def string_to_list(string):\n    return string.split()\n",
    "MbppEval/99": "def decimal_to_binary(n: int) -> str:\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    binary_str = bin(n)[2:]\n    return binary_str\n",
    "MbppEval/132": "def tup_string(tup1):\n    result = ''\n    \n    for elem in tup1:\n        result += elem\n    \n    return result\n",
    "MbppEval/17": "def square_perimeter(a):\n    perimeter = 4 * a\n    return perimeter\n",
    "MbppEval/106": "def add_lists(test_list, test_tup):\n    new_tuple = test_tup + tuple(test_list)\n    return new_tuple\n",
    "MbppEval/85": "import math\n\ndef surfacearea_sphere(r):\n    surface_area = 4 * math.pi * r**2\n    return surface_area\n",
    "MbppEval/59": "def is_octagonal(n): \n    return n * (3*n - 2)\n",
    "MbppEval/58": "def opposite_signs(x, y): \n    if x * y < 0:\n        return True\n    else:\n        return False\n",
    "MbppEval/64": "def subject_marks(subjectmarks):\n    return sorted(subjectmarks, key=lambda x: x[1])\n",
    "MbppEval/162": "def sum_series(n):\n    total_sum = 0\n    \n    for i in range(n // 2 + 1):\n        total_sum += n - 2*i\n        \n    return total_sum\n",
    "MbppEval/135": "def hexagonal_num(n): \n    hexagonal_number = n * (2 * n - 1)\n    return hexagonal_number\n",
    "MbppEval/166": "def find_even_pair(A): \n    count = 0\n    for i in range(len(A)):\n        for j in range(i+1, len(A)):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n",
    "MbppEval/163": "from math import tan, pi\n\ndef area_polygon(s, l):\n    apothem = s / (2 * tan(pi / l))\n    area = (l * s * apothem) / 2\n    return area\n",
    "MbppEval/101": "def kth_element(arr, k):\n    if k > 0 and k <= len(arr):\n        return arr[k - 1]\n    else:\n        return \"Invalid k value\"\n",
    "MbppEval/167": "def next_power_of_2(n):\n    if n == 0:\n        return 1\n    \n    power = 1\n    \n    while power < n:\n        power *= 2\n        \n    return power\n",
    "MbppEval/127": "def multiply_int(x, y):\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise ValueError(\"Inputs must be integers\")\n    result = x * y\n    return result\n",
    "MbppEval/139": "import math\n\ndef circle_circumference(r):\n    return 2 * math.pi * r\n\n# Testing the function with examples\nprint(circle_circumference(10))  # 62.830000000000005\nprint(circle_circumference(5))   # 31.41592653589793\nprint(circle_circumference(4))   # 25.132741228718345\n",
    "MbppEval/7": "import re\n\ndef find_char_long(text):\n    words = re.findall(r'\\b\\w+\\b', text)\n    filtered_words = [word for word in words if len(word) >= 4]\n    return filtered_words\n",
    "MbppEval/171": "import math\ndef perimeter_pentagon(a):\n    perimeter = 5 * a\n    return perimeter\n\n# Test the function with examples\nprint(perimeter_pentagon(5))  # Expected output: 25\nprint(perimeter_pentagon(10))  # Expected output: 50\nprint(perimeter_pentagon(15))  # Expected output: 75\n",
    "MbppEval/222": "def check_type(test_tuple):\n    first_type = type(test_tuple[0])\n    for elem in test_tuple[1:]:\n        if type(elem) != first_type:\n            return False\n    return True\n",
    "MbppEval/124": "import cmath\n\ndef angle_complex(a, b):\n    return cmath.phase(complex(a, b))\n",
    "MbppEval/170": "def sum_range_list(list1, m, n):\n    sum_within_range = 0\n    for i in range(len(list1)):\n        if m <= i <= n:\n            sum_within_range += list1[i]\n    return sum_within_range\n",
    "MbppEval/224": "def count_Set_Bits(n): \n    binary_n = bin(n)[2:]  # Get binary representation removing '0b' prefix\n    \n    count = 0\n    for bit in binary_n:\n        if bit == '1':\n            count += 1\n    \n    return count\n",
    "MbppEval/57": "def find_Max_Num(arr):\n    # Step 1: Ensure the input is a list of digits\n    if not all(isinstance(num, int) and num >= 0 for num in arr):\n        return \"Please provide a list of non-negative integers\"\n\n    # Step 2: Define a custom sorting function to order digits for maximum number\n    def custom_sort(x, y):\n        return int(str(y) + str(x)) - int(str(x) + str(y))\n\n    # Step 3: Sort the list based on the custom sort function\n    arr.sort(key=custom_sort)\n\n    return int(\"\".join(map(str, arr)))\n\n# Test the function with some example inputs\nprint(find_Max_Num([1, 2, 3]))  # Expected output: 321\n",
    "MbppEval/20": "def is_woodall(x):\n    if x < 1:\n        return False\n      \n    woodall_num = x * 2**x - 1\n    \n    return woodall_num == x\n",
    "MbppEval/72": "def dif_Square(n):\n    for a in range(1, n):\n        for b in range(1, a):\n            if a**2 - b**2 == n:\n                return True\n    return False\n",
    "MbppEval/105": "def count(lst):\n    count_true = 0\n    \n    for element in lst:\n        if element == True:\n            count_true += 1\n    \n    return count_true\n",
    "MbppEval/113": "def check_integer(text):\n    if not text:\n        return False\n    return text.isdigit()\n",
    "MbppEval/234": "def volume_cube(l):\n    volume = l ** 3\n    return volume\n",
    "MbppEval/102": "return ''.join(capitalized_words)\n",
    "MbppEval/233": "import math\n\ndef lateralsurface_cylinder(r, h):\n    return 2 * math.pi * r * h\n\nprint(lateralsurface_cylinder(10, 5))  # Expected output: 314.1592653589793\nprint(lateralsurface_cylinder(4, 5))   # Expected output: 125.66370614359172\nprint(lateralsurface_cylinder(4, 10))  # Expected output: 251.32741228718345\n",
    "MbppEval/138": "def is_Sum_Of_Powers_Of_Two(n): \n    if n <= 0:\n        return False\n    \n    power = 1\n    while power <= n:\n        power *= 2\n        \n    remaining = n\n    while remaining > 0:\n        if power <= remaining:\n            remaining -= power\n        else:\n            return False\n        power /= 2\n    \n    return True\n",
    "MbppEval/56": "def check(num):\n    reversed_num = int(str(num)[::-1])\n    calculated_num = reversed_num * 2 - 1\n    return num == calculated_num\n\n# Testing the check function\nprint(check(70))  # Output should be False\nprint(check(23))  # Output should be False\nprint(check(73))  # Output should be True\n",
    "MbppEval/240": "def replace_list(list1, list2):\n    new_list = list1[:-1] + list2 \n    return new_list\n",
    "MbppEval/143": "def find_lists(Input): \n    count = 0\n    for elem in Input:\n        if isinstance(elem, list):\n            count += 1\n    return count\n",
    "MbppEval/229": "def re_arrange_array(arr, n):\n    negatives = []\n    positives = []\n    \n    for num in arr[:n]:\n        if num < 0:\n            negatives.append(num)\n        else:\n            positives.append(num)\n    \n    return negatives + positives\n",
    "MbppEval/63": "def max_difference(test_list):\n    max_diff = 0\n    \n    for pair in test_list:\n        diff = abs(pair[0] - pair[1])\n        \n        if diff > max_diff:\n            max_diff = diff\n            \n    return max_diff\n",
    "MbppEval/3": "import math\n\ndef is_not_prime(n):\n    if n <= 1:\n        return True\n    \n    if n == 2:\n        return False\n    \n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return True\n\n    return False\n",
    "MbppEval/242": "def count_charac(str1):\n    count = 0\n    for char in str1:\n        count += 1\n    return count\n",
    "MbppEval/246": "def babylonian_squareroot(number):\n    guess = 1  # Updated initial guess to 1 for a better starting point\n\n    # Step 1: Babylonian method for computing square roots\n    while abs(guess**2 - number) > 1e-10:\n        guess = (guess + number / guess) / 2  # Step 2: Update guess using Babylonian formula\n\n    return guess\n",
    "MbppEval/68": "def is_Monotonic(A):\n    increasing = decreasing = True\n    \n    for i in range(len(A) - 1):\n        if A[i] > A[i + 1]:\n            increasing = False\n        if A[i] < A[i + 1]:\n            decreasing = False\n    \n    return increasing or decreasing\n",
    "MbppEval/248": "def harmonic_sum(n):\n    sum = 0\n    for i in range(1, n):\n        sum += 1 / i\n    return sum\n",
    "MbppEval/66": "def pos_count(list):\n    count = 0\n    for num in list:\n        if num > 0:\n            count += 1\n    return count\n",
    "MbppEval/251": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result\n",
    "MbppEval/65": "def recursive_list_sum(data_list):\n    total_sum = 0\n    \n    if not data_list:\n        return total_sum\n    \n    for elem in data_list:\n        if isinstance(elem, list):\n            total_sum += recursive_list_sum(elem)\n        else:\n            total_sum += elem\n            \n    return total_sum\n",
    "MbppEval/4": "import heapq as hq\n\ndef heap_queue_largest(nums, n):\n    heap = []\n    hq.heapify(heap)\n    \n    for num in nums:\n        hq.heappush(heap, num)\n        if len(heap) > n:\n            hq.heappop(heap)\n    \n    return [-hq.heappop(heap) for _ in range(n)][::-1]\n",
    "MbppEval/90": "def len_log(list1):\n    max_len = 0\n    \n    for word in list1:\n        word_len = len(word)\n        \n        if word_len > max_len:\n            max_len = word_len\n\n    return max_len\n",
    "MbppEval/16": "import re\n\ndef text_lowercase_underscore(text):\n    return 'Found a match!' if re.search(r'[a-z]+_[a-z]+', text) else 'Not matched!'\n",
    "MbppEval/257": "def swap_numbers(a, b):\n    return (b, a)\n",
    "MbppEval/172": "def count_occurance(s):\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count\n",
    "MbppEval/86": "def centered_hexagonal_number(n):\n    return 3 * n**2 - 3 * n + 1\n",
    "MbppEval/262": "def split_two_parts(list1, L):\n    first_part = list1[:L]\n    second_part = list1[L:]\n    return (first_part, second_part)\n",
    "MbppEval/265": "def list_split(S, step):\n    result = []\n    for i in range(step):\n        result.append(S[i::step])\n    return result\n",
    "MbppEval/264": "def dog_age(h_age):\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 2 * 10.5 + (h_age - 2) * 4\n",
    "MbppEval/62": "# Step 0: Define the function\ndef smallest_num(xs):\n    # Step 1: Initialize a variable to store the smallest number\n    smallest = xs[0]\n\n    # Step 2: Iterate over the elements of the list starting from the second element\n    for num in xs[1:]:\n        # Step 3: Compare each element with the current smallest number\n        if num < smallest:\n            # Step 4: Update the smallest number if the current element is smaller\n            smallest = num\n            \n    # Step 5: Return the smallest number\n    return smallest\n",
    "MbppEval/266": "def lateralsurface_cube(l):\n    lateral_surface_area = 4 * l**2\n    return lateral_surface_area\n",
    "MbppEval/260": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef generate_newman_shanks_williams_primes():\n    primes = [2, 7]\n    n = 1\n    while True:\n        candidate = 15 * (2 ** n) - 7\n        if is_prime(candidate):\n            primes.append(candidate)\n        candidate = 15 * (2 ** n) + 7\n        if is_prime(candidate):\n            primes.append(candidate)\n        if len(primes) > 100:\n            break\n        n += 1\n    return primes\n\ndef newman_prime(n):\n    ns_w_primes = generate_newman_shanks_williams_primes()\n    return ns_w_primes[n - 1]\n",
    "MbppEval/237": "from collections import Counter\n\ndef check_occurrences(test_list):\n    occurrences_dict = {}\n\n    for tup in test_list:\n        if tup in occurrences_dict:\n            occurrences_dict[tup] += 1\n        else:\n            occurrences_dict[tup] = 1\n\n    return occurrences_dict\n",
    "MbppEval/269": "def ascii_value(k):\n    if len(k) == 1:  # Check if input is a single character\n        return ord(k)\n    else:\n        return \"Input must be a single character\"\n",
    "MbppEval/268": "def find_star_num(n):\n    if n <= 0:\n        return \"Invalid input. n should be a positive integer.\"\n    \n    star_num = 6 * n**2 - 9 * n + 3\n    return star_num\n",
    "MbppEval/272": "def rear_extract(test_list):\n    rear_elements = []\n    \n    for tpl in test_list:\n        rear_elements.append(tpl[-1])\n    \n    return rear_elements\n",
    "MbppEval/273": "def substract_elements(test_tup1, test_tup2):\n    result = []\n    for i in range(len(test_tup1)):\n        result.append(test_tup1[i] - test_tup2[i])\n    return tuple(result)\n",
    "MbppEval/261": "def division_elements(test_tup1, test_tup2):\n    result = []\n    for i in range(min(len(test_tup1), len(test_tup2))):\n        result.append(int(test_tup1[i] / test_tup2[i]))\n    \n    return tuple(result)\n",
    "MbppEval/97": "def frequency_lists(list1):\n    freq_dict = {}\n    for sublist in list1:\n        for item in sublist:\n            if item in freq_dict:\n                freq_dict[item] += 1\n            else:\n                freq_dict[item] = 1\n    \n    return freq_dict\n",
    "MbppEval/276": "import math\n\ndef volume_cylinder(r, h):\n    volume = math.pi * r**2 * h\n    return volume\n",
    "MbppEval/14": "def find_Volume(l, b, h):\n    '''\n    Write a python function to find the volume of a triangular prism.\n\n    Examples:\n    find_Volume(10,8,6) == 240\n    find_Volume(3,2,2) == 6\n    find_Volume(1,2,1) == 1\n    '''\n\n    base_area = 0.5 * b * h\n\n    volume = base_area * l\n\n    return volume\n",
    "MbppEval/111": "def common_in_nested_lists(nestedlist):\n    common_elements = set()\n    \n    set_list = [set(lst) for lst in nestedlist]\n    \n    reference_set = set_list[0]\n    \n    for s in set_list[1:]:\n        common_elements.update(reference_set.intersection(s))\n    \n    return sorted(list(common_elements))\n",
    "MbppEval/279": "def is_num_decagonal(n): \n    return n * (3 * n - 1) * n // 2\n",
    "MbppEval/282": "def sub_list(nums1, nums2):\n    result = []\n    for num1, num2 in zip(nums1, nums2):\n        result.append(num1 - num2)\n    return result\n",
    "MbppEval/280": "def sequential_search(dlist, item):\n    found = False\n    index = -1\n    \n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            found = True\n            index = i\n\n    return (found, index)\n",
    "MbppEval/126": "def sum(a, b):\n    def find_factors(num):\n        factors = []\n        for i in range(1, num+1):\n            if num % i == 0:\n                factors.append(i)\n        return factors\n\n    factors_a = find_factors(a)\n    factors_b = find_factors(b)\n\n    common_factors = set(factors_a).intersection(factors_b)\n\n    return sum(common_factors)\n\nsum(10, 15)\n",
    "MbppEval/6": "def differ_At_One_Bit_Pos(x, y):\n    # Step 0: Get the binary representation of the input numbers\n    binary_x = bin(x)[2:]\n    binary_y = bin(y)[2:]\n    \n    # Step 1: Perform XOR operation\n    xor_result = x ^ y\n    \n    # Step 2: Check if the result is a power of two\n    return xor_result & (xor_result - 1) == 0\n\n# Testing the function\nprint(differ_At_One_Bit_Pos(13, 9))  # Output: True\nprint(differ_At_One_Bit_Pos(15, 8))  # Output: False\nprint(differ_At_One_Bit_Pos(2, 4))   # Output: False\n",
    "MbppEval/168": "# Step 0: Define the function frequency with parameters a and x\ndef frequency(a, x):\n    # Step 1: Initialize a variable count to keep track of the number of occurrences of x in the list a\n    count = 0\n    \n    # Step 2: Iterate over each element in the list a\n    for element in a:\n        # Step 3: Check if the element is equal to x\n        if element == x:\n            # Step 4: Increment the count if the element is equal to x\n            count += 1\n    \n    # Return the final count\n    return count\n",
    "MbppEval/83": "def get_Char(strr):\n    total_ascii = 0\n    \n    for char in strr:\n        total_ascii += ord(char)\n    \n    total_ascii %= 26\n    \n    return chr(ord('a') + total_ascii)\n",
    "MbppEval/284": "def check_element(list, element):\n    for item in list:\n        if item != element:\n            return False\n    return True\n",
    "MbppEval/75": "def find_tuples(test_list, K):\n    result = []\n    \n    for tup in test_list:\n        all_divisible = True\n        for num in tup:\n            if num % K != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tup)\n    \n    return str(result)\n",
    "MbppEval/145": "def max_Abs_Diff(arr): \n    max_diff = None\n    min_val = None\n    \n    for num in arr:\n        if min_val is None or num < min_val:\n            min_val = num\n            max_diff = None\n        diff = abs(num - min_val)\n        if max_diff is None or diff > max_diff:\n            max_diff = diff\n    \n    return max_diff\n",
    "MbppEval/285": "import re\n\ndef text_match_two_three(text):\n    pattern = 'ab{2,3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    return 'Not matched!'\n",
    "MbppEval/292": "def find(n, m):\n    result = n // m\n    return result\n",
    "MbppEval/291": "def count_no_of_ways(n, k):\n    if n == 1:\n        return k\n    if n == 2:\n        return k*k\n",
    "MbppEval/293": "import math\n\ndef otherside_rightangle(w, h):\n    return math.sqrt(w**2 + h**2)\n",
    "MbppEval/230": "def replace_blank(str1, char):\n    words = str1.split(' ')\n    new_str = char.join(words)\n    return new_str\n",
    "MbppEval/98": "def multiply_num(numbers):\n    result = 1\n    for num in numbers:\n        result *= num\n    \n    result /= len(numbers)\n    \n    return result\n",
    "MbppEval/295": "def sum_div(number):\n    divisors_sum = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            divisors_sum += i\n    return divisors_sum\n",
    "MbppEval/133": "def sum_negativenum(nums):\n    total = 0\n    for num in nums:\n        if num < 0:\n            total += num\n\n    return total\n",
    "MbppEval/287": "def square_Sum(n):\n    sum_squares = 0\n    for i in range(1, n+1):\n        even_num = 2 * i\n        sum_squares += even_num ** 2\n    return sum_squares\n",
    "MbppEval/119": "def search(arr):\n    if not arr:\n        return None\n\n    for i in range(0, len(arr), 2):\n        if i + 1 < len(arr) and arr[i] != arr[i + 1]:\n            return arr[i]\n\n    return arr[-1]\n",
    "MbppEval/244": "import math\n\ndef next_Perfect_Square(N):\n    root_N_squared = math.ceil(math.sqrt(N))  # Step 2\n    next_square = root_N_squared ** 2  # Step 3\n    return next_square\n",
    "MbppEval/271": "def even_Power_Sum(n):\n    sum = 0\n    count = 0\n    number = 2\n\n    while count < n:\n        sum += number ** 5\n        number += 2\n        count += 1\n\n    return sum\n",
    "MbppEval/253": "def count_integer(list1):\n    int_count = 0\n\n    for element in list1:\n        if isinstance(element, int):\n            int_count += 1\n\n    return int_count\n",
    "MbppEval/88": "def freq_count(list1):\n    freq_dict = {}\n    \n    for element in list1:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n\n    return freq_dict\n",
    "MbppEval/308": "def large_product(nums1, nums2, N):\n    products = []\n    \n    # Step 1: Calculate all possible products\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    \n    # Step 2: Sort the list of products in descending order\n    products.sort(reverse=True)\n    \n    # Step 3: Return the first N elements as the largest products\n    return products[:N]\n",
    "MbppEval/161": "def remove_elements(list1, list2):\n    result = []\n    for elem in list1:\n        if elem not in list2:\n            result.append(elem)\n    return result\n",
    "MbppEval/309": "def maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b\n",
    "MbppEval/108": "import heapq\n\ndef merge_sorted_list(num1, num2, num3):\n    # Step 0: Combine all three lists into a single list\n    combined_list = num1 + num2 + num3\n    \n    # Step 1: Use heapq.merge() to merge the lists while keeping them sorted\n    sorted_list = list(heapq.merge(*combined_list))\n    \n    return sorted_list\n",
    "MbppEval/312": "import math\ndef volume_cone(r, h):\n    return (1/3) * math.pi * r**2 * h\n",
    "MbppEval/311": "def set_left_most_unset_bit(n):\n    if n == 0:\n        return 1\n    \n    position = 0\n    while (n >> position) & 1:\n        position += 1\n        \n    return n | (1 << position)\n",
    "MbppEval/388": "def highest_Power_of_2(n): \n    power_of_2 = 1\n\n    while power_of_2 * 2 <= n:\n        power_of_2 *= 2\n\n    return power_of_2\n",
    "MbppEval/307": "from copy import deepcopy\n\ndef colon_tuplex(tuplex, m, n):\n    new_tuplex = deepcopy(tuplex)\n    \n    if m < 0 or m >= len(new_tuplex):\n        return \"Invalid index\"\n    \n    new_tuplex_list = list(new_tuplex)\n    new_tuplex_list[m] = n\n    updated_tuplex = tuple(new_tuplex_list)\n    \n    return updated_tuplex\n",
    "MbppEval/84": "def sequence(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    \n    seq = [0, 1, 1]\n\n    for k in range(3, n+1):\n        seq.append(seq[seq[k-1]] + seq[k - seq[k-1]])\n    \n    return seq[n]\n",
    "MbppEval/389": "def find_lucas(n):\n    if not isinstance(n, int) or n < 0:\n        return \"Invalid input. Please enter a non-negative integer.\"\n    \n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    lucas_prev = 2\n    lucas_cur = 1\n    \n    for i in range(2, n + 1):\n        lucas_next = lucas_prev + lucas_cur\n        lucas_prev, lucas_cur = lucas_cur, lucas_next\n    \n    return lucas_cur\n",
    "MbppEval/87": "import collections as ct\n\ndef merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {}\n    \n    dicts = [dict1, dict2, dict3]\n    \n    for d in dicts:\n        for key, value in d.items():\n            merged_dict[key] = value\n    \n    return merged_dict\n",
    "MbppEval/393": "def max_length_list(input_list):\n    max_length = 0\n    max_list = []\n\n    for lst in input_list:\n        if len(lst) > max_length:\n            max_length = len(lst)\n            max_list = lst\n\n    return (max_length, max_list)\n",
    "MbppEval/390": "def add_string(list_, string):\n    formatted_list = []  # Step 0: Initialize an empty list to store the formatted strings\n\n    # Step 1: Iterate over all elements in the list and format them\n    for element in list_:\n        formatted_element = string.format(element)\n        formatted_list.append(formatted_element)\n\n    return formatted_list  # Step 3: Return the new list containing the formatted strings\n",
    "MbppEval/398": "def sum_of_digits(nums):\n    total_sum = 0\n    for num in nums:\n        if isinstance(num, int):\n            for digit in str(abs(num)):\n                total_sum += int(digit)\n    return total_sum\n",
    "MbppEval/394": "def check_distinct(test_tup):\n    distinct_set = set(test_tup)\n    return len(test_tup) == len(distinct_set)\n",
    "MbppEval/286": "def max_sub_array_sum_repeated(a, n, k): \n    repeated_arr = repeat_array(a, k)\n    \n    max_sum = float('-inf')\n    for i in range(n * k):\n        curr_sum = 0\n        for j in range(i, n * k):\n            curr_sum += repeated_arr[j]\n            max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n",
    "MbppEval/396": "import re\n\nregex = r'^[a-z]$|^([a-z]).*\\1$'\n\ndef check_char(string):\n    if re.match(regex, string):\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n\n# Test cases\nprint(check_char(\"abba\"))\nprint(check_char(\"a\"))\nprint(check_char(\"abcd\"))\n",
    "MbppEval/392": "def get_max_sum(n):\n    if n <= 2:\n        return n\n\n    max_sum = max(n, get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5))\n\n    return max_sum\n",
    "MbppEval/404": "def minimum(a, b):\n    if a < b:\n        return a\n    else:\n        return b\n",
    "MbppEval/19": "def test_duplicate(arraynums):\n    unique_set = set(arraynums)\n    \n    if len(unique_set) == len(arraynums):\n        return False\n    else:\n        return True\n",
    "MbppEval/405": "def check_tuplex(tuplex, tuple1):\n    if tuple1 in tuplex:\n        return True\n    else:\n        return False\n",
    "MbppEval/406": "def find_Parity(x):\n    if x % 2 == 0:\n        return \"Even Parity\"\n    else:\n        return \"Odd Parity\"\n",
    "MbppEval/117": "def list_to_float(test_list):\n    for sublist in test_list:\n        for i, element in enumerate(sublist):\n            try:\n                sublist[i] = float(element)\n            except ValueError:\n                pass\n\n    return test_list\n",
    "MbppEval/400": "def extract_freq(test_list):\n    unique_tuples = set()\n    \n    for tuple_item in test_list:\n        unique_tuples.add(tuple_item)\n    \n    return len(unique_tuples)\n",
    "MbppEval/104": "def sort_sublists(input_list):\n    sorted_list = []\n    for sublist in input_list:\n        sorted_sublist = sorted(sublist)\n        sorted_list.append(sorted_sublist)\n    return sorted_list\n",
    "MbppEval/412": "def remove_odd(l):\n    result = [num for num in l if num % 2 == 0]\n    return result\n",
    "MbppEval/409": "def min_product_tuple(list1):\n    min_product = float('inf')\n    \n    for tuple_pair in list1:\n        product = tuple_pair[0] * tuple_pair[1]\n        \n        if product < min_product:\n            min_product = product\n    \n    return min_product\n",
    "MbppEval/294": "def max_val(listval):\n    max_value = None\n    for item in listval:\n        if isinstance(item, (int, float)):\n            if max_value is None or item > max_value:\n                max_value = item\n    return max_value\n",
    "MbppEval/414": "def overlapping(list1, list2):\n    for value in list1:\n        if value in list2:\n            return True\n    return False\n",
    "MbppEval/69": "def is_sublist(l, s):\n    for i in range(len(l)):\n        if l[i:i+len(s)] == s:\n            return True\n\n    return False\n",
    "MbppEval/125": "def find_length(string):\n    max_diff = 0\n    count_0 = 0\n    count_1 = 0\n    \n    for char in string:\n        if char == '0':\n            count_0 += 1\n        elif char == '1':\n            count_1 += 1\n        \n        diff = count_0 - count_1\n        max_diff = max(max_diff, diff)\n    \n    return max_diff\n",
    "MbppEval/411": "import re\n\ndef snake_to_camel(word):\n    words = word.split('_')\n    camel_words = [words[0].capitalize()] + [word.capitalize() for word in words[1:]]\n    return ''.join(camel_words)\n",
    "MbppEval/274": "import math\n\ndef even_binomial_Coeff_Sum(n):\n    total = 0\n\n    for i in range(0, n+1, 2):\n        binomial_coefficient = math.comb(n, i)\n        total += binomial_coefficient\n\n    return total\n",
    "MbppEval/421": "def concatenate_tuple(test_tup):\n    result = ''\n    for i, elem in enumerate(test_tup):\n        if i == 0:\n            result += str(elem)\n        else:\n            result += '-' + str(elem)\n    return result\n",
    "MbppEval/420": "def cube_Sum(n): \n    even_sum = 2 * n * (n + 1)\n    cube_sum = even_sum ** 3\n    return cube_sum\n",
    "MbppEval/109": "def odd_Equivalent(s, n):\n    count_ones = s.count('1')\n    odd_count = 0  # Initialize count of odd numbers\n\n    for _ in range(n):\n        count_ones_rotation = s.count('1')\n        if count_ones_rotation % 2 != 0:\n            odd_count += 1\n        s = s[-1] + s[:-1]  # Rotate the string\n        \n    return odd_count\n",
    "MbppEval/8": "def square_nums(nums):\n    squared_values = []\n    \n    for num in nums:\n        squared_values.append(num ** 2)\n    \n    return squared_values\n",
    "MbppEval/290": "def max_length(list1):\n    max_len_list = []\n    max_length = 0\n    for sub_list in list1:\n        if len(sub_list) > max_length:\n            max_length = len(sub_list)\n            max_len_list = sub_list\n    return (max_length, max_len_list)\n",
    "MbppEval/232": "import heapq\n\ndef larg_nnum(list1, n):\n    return heapq.nlargest(n, list1)\n",
    "MbppEval/422": "def find_Average_Of_Cube(n):\n    sum_cubes = 0\n\n    for i in range(1, n + 1):\n        cube_i = i**3\n        sum_cubes += cube_i\n    \n    average_cube = sum_cubes / n\n    return average_cube\n",
    "MbppEval/427": "import re\n\ndef change_date_format(dt):\n    date_pattern = re.compile(r'(\\d{4})-(\\d{2})-(\\d{2})')\n    match = date_pattern.match(dt)\n    \n    if match:\n        year, month, day = match.groups()\n        new_date = f'{day}-{month}-{year}'\n        return new_date\n\nprint(change_date_format(\"2026-01-02\"))\nprint(change_date_format(\"2020-11-13\"))\nprint(change_date_format(\"2021-04-26\"))\n",
    "MbppEval/426": "def filter_oddnumbers(nums):\n    odd_numbers = []\n    \n    for num in nums:\n        if num % 2 != 0:\n            odd_numbers.append(num)\n    \n    return odd_numbers\n",
    "MbppEval/428": "def shell_sort(my_list):\n    n = len(my_list)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = temp\n        gap = gap // 2 if gap > 1 else 1\n\n    return my_list\n",
    "MbppEval/430": "def parabola_directrix(a, b, c): \n    return -a / (4 * b)\n",
    "MbppEval/431": "def common_element(list1, list2):\n    for item in list1:\n        if item in list2:\n            return True\n    return False\n",
    "MbppEval/432": "def median_trapezium(base1, base2, height):\n    area = (base1 + base2) * height / 2\n    median = (base1 + base2) / 2\n    return median\n",
    "MbppEval/140": "def extract_singly(test_list):\n    flattened_numbers = []\n    \n    for sublist in test_list:\n        for num in sublist:\n            flattened_numbers.append(num)\n    \n    return list(set(flattened_numbers))\n",
    "MbppEval/238": "def number_of_substrings(str):\n    count = 0\n    for i in range(len(str)):\n        start = i\n        for j in range(i, len(str)):\n            end = j\n            count += end - start + 1\n    return count\n",
    "MbppEval/433": "def check_greater(arr, number):\n    for element in arr:\n        if element >= number:\n            return 'No, entered number is less than those in the array'\n    return 'Yes, the entered number is greater than those in the array'\n",
    "MbppEval/434": "import re\n\ndef text_match_one(text):\n    pattern = re.compile(r'a+b+')\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
    "MbppEval/435": "def last_Digit(n):\n    num_str = str(n)\n    last_digit = int(num_str[-1])\n    \n    return last_digit\n",
    "MbppEval/429": "def and_tuples(test_tup1, test_tup2):\n    result_list = []\n    \n    for elem1, elem2 in zip(test_tup1, test_tup2):\n        result_list.append(elem1 & elem2)\n    \n    return tuple(result_list)\n",
    "MbppEval/437": "def remove_odd(str1):\n    even_chars = \"\"\n    \n    for i in range(len(str1)):\n        if i % 2 == 0:\n            even_chars += str1[i]\n    \n    return even_chars\n",
    "MbppEval/436": "def neg_nos(list1):\n    negative_numbers = []\n    for num in list1:\n        if num < 0:\n            negative_numbers.append(num)\n    return negative_numbers\n",
    "MbppEval/439": "def multiple_to_single(L):\n    result = \"\"\n    \n    for num in L:\n        result += str(num)\n\n    final_result = int(result)\n    \n    return final_result\n",
    "MbppEval/440": "import re\n\ndef find_adverb_position(text):\n    adverb_regex = r'\\b\\w+ly\\b'\n    adverb_match = re.search(adverb_regex, text)\n    \n    if adverb_match:\n        adverb = adverb_match.group()\n        start_pos = adverb_match.start()\n        end_pos = adverb_match.end()\n        \n        return start_pos, end_pos, adverb\n    return None\n",
    "MbppEval/441": "def surfacearea_cube(l):\n    return 6 * (l ** 2)\n",
    "MbppEval/425": "    return count\n",
    "MbppEval/443": "def largest_neg(list1): \n    largest_negative = None\n    \n    for num in list1:\n        if num < 0:\n            if largest_negative is None or num < largest_negative:\n                largest_negative = num\n    \n    return largest_negative\n",
    "MbppEval/249": "def intersection_array(array_nums1, array_nums2):\n    set_nums1 = set(array_nums1)\n    set_nums2 = set(array_nums2)\n    \n    intersection_set = set_nums1.intersection(set_nums2)\n    \n    intersection_list = list(intersection_set)\n    \n    return intersection_list\n",
    "MbppEval/444": "def trim_tuple(test_list, K):\n    result = []\n    \n    for tup in test_list:\n        trimmed_tuple = tup[K:]\n        result.append(trimmed_tuple)\n    \n    return str(result)\n",
    "MbppEval/448": "def cal_sum(n):\n    def perrin_number(n):\n        if n == 0:\n            return 3\n        if n == 1:\n            return 0\n        if n == 2:\n            return 2\n\n        return perrin_number(n-2) + perrin_number(n-3)\n    \n    perrin_numbers = [perrin_number(i) for i in range(n)]\n    \n    return sum(perrin_numbers)\n",
    "MbppEval/447": "def cube_nums(nums):\n    cubes = []\n\n    for num in nums:\n        cube = num ** 3\n        cubes.append(cube)\n\n    return cubes\n",
    "MbppEval/442": "from array import array\ndef positive_count(nums):\n    total_positive = 0\n    \n    for num in nums:\n        if num > 0:\n            total_positive += 1\n    \n    ratio = total_positive / len(nums)\n    \n    return round(ratio, 2)\n",
    "MbppEval/451": "import re\n\ndef remove_whitespaces(text1):\n    return re.sub(r'\\s+', '', text1)\n",
    "MbppEval/454": "import re\n\ndef text_match_wordz(text):\n    match = re.search(r'\\w*z\\w*', text)\n    return 'Found a match!' if match else 'Not matched!'\n",
    "MbppEval/452": "def loss_amount(actual_cost, sale_amount):\n    difference = actual_cost - sale_amount\n    if difference > 0:\n        return difference\n    else:\n        return 0\n",
    "MbppEval/456": "def reverse_string_list(stringlist):\n    return [string[::-1] for string in stringlist]\n",
    "MbppEval/453": "return sum_factors\n",
    "MbppEval/457": "def Find_Min(lst):\n    min_sublist = lst[0]\n\n    for sublist in lst[1:]:\n        if len(sublist) < len(min_sublist):\n            min_sublist = sublist\n    \n    return min_sublist\n",
    "MbppEval/458": "def rectangle_area(l, b):\n    area = l * b\n    return area\n",
    "MbppEval/459": "import re\n\ndef remove_uppercase(str1):\n    uppercase_substrings = re.findall('[A-Z]+', str1)\n    result = str1\n\n    for substr in uppercase_substrings:\n        result = result.replace(substr, \"\")\n\n    return result\n",
    "MbppEval/460": "def Extract(lst): \n    first_elements = []\n    for sub_list in lst:\n        first_element = sub_list[0]\n        first_elements.append(first_element)\n    return first_elements\n",
    "MbppEval/461": "def upper_ctr(str):\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count\n",
    "MbppEval/281": "def all_unique(test_list):\n    unique_set = set()\n    \n    for elem in test_list:\n        if elem in unique_set:\n            return False\n        unique_set.add(elem)\n    \n    return True\n",
    "MbppEval/464": "def check_value(dict, n):\n    return all(value == n for value in dict.values())\n",
    "MbppEval/445": "def index_multiplication(test_tup1, test_tup2):\n    result_tup = tuple(x * y for x, y in zip(test_tup1, test_tup2))\n    return result_tup\n",
    "MbppEval/463": "def max_subarray_product(arr):\n    if not arr:\n        return 0\n    \n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n    \n    for i in range(1, len(arr)):\n        temp_max = max(arr[i], max_product * arr[i], min_product * arr[i])\n        min_product = min(arr[i], max_product * arr[i], min_product * arr[i])\n        \n        max_product = temp_max\n        \n        result = max(result, max_product)\n    \n    return result\n",
    "MbppEval/465": "def drop_empty(dict1):\n    result_dict = {}\n    for key, value in dict1.items():\n        if value is not None:\n            result_dict[key] = value\n    return result_dict\n",
    "MbppEval/471": "    return product_mod_n\n",
    "MbppEval/470": "def add_pairwise(test_tup):\n    result = []\n    for i in range(len(test_tup) - 1):\n        pair_sum = test_tup[i] + test_tup[i + 1]\n        result.append(pair_sum)\n    return tuple(result)\n",
    "MbppEval/468": "def max_product(arr):\n    max_product = 1\n    arr.sort()\n\n    for num in arr:\n        max_product *= num\n\n    return max_product\n",
    "MbppEval/472": "def check_Consecutive(l): \n    consecutive = True\n    \n    sorted_list = sorted(l)\n    \n    consecutive = True\n    \n    for i in range(len(sorted_list) - 1):\n        if sorted_list[i] != sorted_list[i+1] - 1:\n            consecutive = False\n            break\n    \n    return consecutive\n",
    "MbppEval/259": "def maximize_elements(test_tup1, test_tup2):\n    max_values = []\n    \n    for tup1, tup2 in zip(test_tup1, test_tup2):\n        max_values.append((max(tup1[0], tup2[0]), max(tup1[1], tup2[1])))\n    \n    return tuple(max_values)\n",
    "MbppEval/477": "def is_lower(string):\n    lower_case_string = string.lower()\n    return lower_case_string\n",
    "MbppEval/77": "def sum_of_digits_at_odd_even_places(n):\n    even_sum = 0\n    odd_sum = 0\n\n    while n > 0:\n        digit = n % 10\n        even_sum += digit\n        n //= 10\n\n        if n == 0:\n            break\n\n        digit = n % 10\n        odd_sum += digit\n        n //= 10\n\n    return abs(even_sum - odd_sum)\n\ndef absolute_difference_of_digits_at_odd_even_places(n):\n    even_sum, odd_sum = sum_of_digits_at_odd_even_places(n)\n    return abs(even_sum - odd_sum)\n\ndef is_Diff(n):\n    diff = absolute_difference_of_digits_at_odd_even_places(n)\n    return diff % 11 == 0\n\n# Test the is_Diff function\nprint(is_Diff(12345))   # Output should be False\nprint(is_Diff(1212112)) # Output should be True\nprint(is_Diff(1212))    # Output should be False\n",
    "MbppEval/479": "def first_Digit(n):\n    return int(str(n)[0])\n",
    "MbppEval/475": "from collections import Counter\n\ndef sort_counter(dict1):\n    sorted_dict = sorted(dict1.items(), key=lambda x: x[1], reverse=True)\n    return sorted_dict\n",
    "MbppEval/165": "def count_char_position(str1): \n    count = 0\n    str1 = str1.lower()\n\n    for i in range(len(str1)):\n        if ord(str1[i]) - ord('a') == i:\n            count += 1\n    \n    return count\n",
    "MbppEval/473": "def tuple_intersection(test_list1, test_list2):\n    set1 = set(test_list1)\n    set2 = set(test_list2)\n    \n    unique_set1 = set(t for t in set1)\n    unique_set2 = set(t for t in set2)\n    \n    intersection = unique_set1.intersection(unique_set2)\n    \n    return intersection\n",
    "MbppEval/555": "def difference(n):\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_numbers = n * (n + 1) // 2\n    diff = sum_cubes - sum_numbers\n    return diff\n",
    "MbppEval/478": "import re\n\ndef remove_lowercase(str1):\n    uppercase_chars = []\n    \n    for char in str1:\n        if char.isupper():\n            uppercase_chars.append(char)\n    \n    final_str = ''.join(uppercase_chars)\n    return final_str\n",
    "MbppEval/558": "def digit_distance_nums(n1, n2):\n    num1_str = str(n1)\n    num2_str = str(n2)\n    \n    total_distance = 0\n    \n    for digit1, digit2 in zip(num1_str, num2_str):\n        distance = abs(int(digit1) - int(digit2))\n        total_distance += distance\n    \n    return total_distance\n",
    "MbppEval/554": "def Split(numbers):\n    odd_numbers = []\n    \n    for num in numbers:\n        if num % 2 != 0:\n            odd_numbers.append(num)\n            \n    return odd_numbers\n",
    "MbppEval/446": "from collections import Counter\n\ndef count_Occurrence(tup, lst):\n    counts = Counter(tup)\n    count = 0\n    for elem in lst:\n        count += counts[elem]\n    return count\n",
    "MbppEval/563": "import re\ndef extract_values(text):\n    return re.findall(r'\"(.*?)\"', text)\n",
    "MbppEval/559": "def max_sub_array_sum(a, size):\n    max_curr = max_global = a[0]\n    \n    for i in range(1, size):\n        max_curr = max(a[i], max_curr + a[i])\n        max_global = max(max_global, max_curr)\n        \n    return max_global\n",
    "MbppEval/120": "def max_product_tuple(list1):\n    max_product = 0\n    for tup in list1:\n        product = abs(tup[0]) * abs(tup[1])\n        if product > max_product:\n            max_product = product\n    return max_product\n",
    "MbppEval/565": "def split(word):\n    characters = []  # Step 0: Create an empty list to store the characters\n    \n    for char in word:  # Step 1: Iterate through each character in the input string\n        characters.append(char)  # Step 2: Append each character to the list\n        \n    return characters  # Return the list containing characters\n",
    "MbppEval/564": "def count_Pairs(arr, n): \n    count = 0\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    \n    return count\n",
    "MbppEval/450": "def extract_string(strings, l):\n    extracted_strings = []\n    for string in strings:\n        if len(string) >= l:\n            extracted_strings.append(string)\n    return extracted_strings\n",
    "MbppEval/566": "    return sum_digits\n",
    "MbppEval/310": "def string_to_tuple(str1):\n    return tuple(str1)\n",
    "MbppEval/567": "def issort_list(list1):\n    if len(list1) <= 1:\n        return True\n    \n    for i in range(1, len(list1)):\n        current_num = list1[i]\n        previous_num = list1[i - 1]\n        \n        if current_num < previous_num:\n            return False\n\n    return True\n",
    "MbppEval/557": "def toggle_string(string):\n    result = \"\"  # Step 1: Create an empty string to store the result\n    \n    for char in string:  # Step 2: Iterate through each character in the input string\n        if char.isupper():  # Step 3: Check if the character is uppercase\n            result += char.lower()  # Step 4: Convert uppercase character to lowercase and append to result\n        else:\n            result += char.upper()  # Step 5: Convert lowercase character to uppercase and append to result\n    \n    return result  # Step 6: Return the result string\n",
    "MbppEval/568": "def empty_list(length):\n    result = [{} for _ in range(length)]\n    return result\n",
    "MbppEval/474": "def replace_char(str1, ch, newch):\n    new_str = \"\"\n    \n    for char in str1:\n        if char == ch:\n            new_str += newch\n        else:\n            new_str += char\n    \n    return new_str\n\nprint(replace_char(\"polygon\", 'y', 'l'))\n",
    "MbppEval/572": "def two_unique_nums(nums):\n    num_count = {}\n    for num in nums:\n        num_count[num] = num_count.get(num, 0) + 1\n    \n    unique_nums = [num for num, count in num_count.items() if count == 1]\n    \n    return unique_nums\n",
    "MbppEval/573": "def unique_product(list_data):\n    unique_numbers = set()\n    \n    for num in list_data:\n        if num not in unique_numbers:\n            unique_numbers.add(num)\n    \n    product = 1\n    for unique_num in unique_numbers:\n        product *= unique_num\n    \n    return product\n",
    "MbppEval/577": "def last_digit_factorial(n):\n    result = 1\n    \n    for i in range(1, n+1):\n        result = (result * i) % 10\n        \n    return result\n",
    "MbppEval/578": "def interleave_lists(list1, list2, list3):\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        return \"All lists must be of the same length!\"\n\n    result = []\n    \n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result\n",
    "MbppEval/574": "import math\n\ndef surfacearea_cylinder(r, h):\n    lateral_surface_area = 2 * math.pi * r * h  # Calculate lateral surface area\n    base_area = 2 * math.pi * r**2  # Calculate area of the two bases\n\n    total_surface_area = lateral_surface_area + base_area  # Calculate total surface area\n    \n    return total_surface_area\n",
    "MbppEval/582": "def my_dict(dict1):\n    return not bool(dict1)\n",
    "MbppEval/255": "from itertools import combinations_with_replacement\n\ndef combinations_colors(l, n):\n    return [combo for combo in combinations_with_replacement(l, n)]\n",
    "MbppEval/579": "def find_dissimilar(test_tup1, test_tup2):\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    diff_elements = set1.symmetric_difference(set2)\n    return tuple(diff_elements)\n",
    "MbppEval/585": "def expensive_items(items, n):\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    return sorted_items[:n]\n",
    "MbppEval/584": "import re\n\ndef find_adverbs(text):\n    adverbs = re.findall(r'\\b\\w+ly\\b', text)\n    first_adverb = None\n    for adverb in adverbs:\n        if is_adverb(adverb):\n            first_adverb = adverb\n            break\n    return first_adverb\n\ndef is_adverb(word):\n    return True if word in adverbs_list else False\n\nadverbs_list = ['really', 'probably', 'quickly', 'fairly', 'especially', 'easily']\n\n# Test cases\nprint(find_adverbs(\"Clearly, he has no excuse for such behavior.\"))\nprint(find_adverbs(\"Please handle the situation carefuly\"))\nprint(find_adverbs(\"Complete the task quickly\"))\n",
    "MbppEval/586": "def split_Arr(l, n, k):\n    first_part = l[n:]\n    second_part = l[:n]\n    result = first_part + second_part\n    return result\n",
    "MbppEval/587": "def list_tuple(listx):\n    return tuple(listx)\n",
    "MbppEval/581": "import math\n\ndef surface_Area(b, s):\n    base_area = b**2\n    lateral_area = b * math.sqrt((b**2)/4 + s**2)\n    total_area = base_area + 2 * lateral_area\n    return total_area\n",
    "MbppEval/590": "import cmath\n\ndef polar_rect(r, theta):\n    x = r * cmath.cos(theta)\n    y = r * cmath.sin(theta)\n    return (abs(complex(x, y)), cmath.phase(complex(x, y)))\n",
    "MbppEval/588": "def big_diff(nums):\n    max_val = max(nums)\n    min_val = min(nums)\n    diff = max_val - min_val\n    return diff\n",
    "MbppEval/591": "def swap_List(newList):\n    if len(newList) <= 1:\n        return newList\n\n    newList[0], newList[-1] = newList[-1], newList[0]\n\n    return newList\n",
    "MbppEval/252": "import cmath\n\ndef convert(number):\n    if not isinstance(number, complex):\n        number = complex(number, 0)\n    \n    polar_coords = cmath.polar(number)\n    return polar_coords\n",
    "MbppEval/593": "import re\n\ndef removezero_ip(ip):\n    ip_components = ip.split('.')\n    modified_components = [re.sub(r'^0+', '', component) for component in ip_components]\n    modified_ip = '.'.join(modified_components)\n    return modified_ip\n\n# Test the function with the examples given\nprint(removezero_ip(\"216.08.094.196\"))\nprint(removezero_ip(\"12.01.024\"))\nprint(removezero_ip(\"216.08.094.0196\"))\n",
    "MbppEval/592": "from scipy.special import comb\n\ndef sum_Of_product(n):\n    coefficients = [comb(n, k) for k in range(n + 1)]\n    products = [coefficients[i] * coefficients[i + 1] for i in range(len(coefficients) - 1)]\n    total_sum = sum(products)\n    return total_sum\n",
    "MbppEval/594": "def diff_even_odd(list1):\n    even_num = None\n    odd_num = None\n    \n    for num in list1:\n        if num % 2 == 0 and even_num is None:\n            even_num = num\n        elif num % 2 != 0 and odd_num is None:\n            odd_num = num\n            \n    if even_num is not None and odd_num is not None:\n        return abs(even_num - odd_num)\n    \n    return None\n",
    "MbppEval/438": "def count_bidirectional(test_list):\n    count_dict = {}\n    \n    for pair in test_list:\n        sorted_pair = tuple(sorted(pair))\n        count_dict[sorted_pair] = count_dict.get(sorted_pair, 0) + 1\n\n    bidirectional_count = 0\n    for count in count_dict.values():\n        if count >= 2:\n            bidirectional_count += 1\n            \n    return str(bidirectional_count)\n",
    "MbppEval/583": "def catalan_number(num):\n    '''\n    Write a function which returns nth catalan number.\n    \n    :param num: a non-negative integer\n    :return: the nth Catalan number\n    '''\n    if num < 0:\n        return None\n\n    catalan = [1]  # Base case\n\n    if num == 0:\n        return catalan[0]\n\n    # Calculate Catalan numbers up to 'num'\n    for i in range(1, num+1):\n        catalan.append(sum(catalan[j] * catalan[i - j - 1] for j in range(i)))\n\n    return catalan[num]\n\n# Testing the function with some examples\nprint(catalan_number(10))  # Output should be 16796\nprint(catalan_number(9))   # Output should be 4862\nprint(catalan_number(7))   # Output should be 429\n",
    "MbppEval/595": "if swap_count > 1:\n    return \"Not Possible\"\n",
    "MbppEval/128": "def long_words(n, text):\n    words = text.split()\n    long_words_list = []\n    \n    for word in words:\n        if len(word) > n:\n            long_words_list.append(word)\n    \n    return long_words_list\n",
    "MbppEval/599": "def sum_average(number):\n    sum_n = (number * (number + 1)) / 2\n    average = sum_n / number\n    return sum_n, average\n",
    "MbppEval/597": "def find_kth(arr1, arr2, k):\n    if k < 1 or k > len(arr1) + len(arr2) or len(arr1) == 0 or len(arr2) == 0:\n        return None\n\n    if len(arr1) > len(arr2):\n        return find_kth(arr2, arr1, k)\n\n    if len(arr1) == 1:\n        return arr2[k - 1]\n\n    if k == 1:\n        return min(arr1[0], arr2[0])\n\n    i = min(len(arr1), k // 2)\n    j = k - i\n\n    if arr1[i - 1] < arr2[j - 1]:\n        return find_kth(arr1[i:], arr2, j)\n    else:\n        return find_kth(arr1, arr2[j:], i)\n",
    "MbppEval/602": "def first_repeated_char(str1):\n    seen_chars = set()\n\n    for char in str1:\n        if char in seen_chars:\n            return char\n        seen_chars.add(char)\n\n    return \"None\"\n",
    "MbppEval/603": "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef get_ludic(n):\n    ludic_numbers = []\n    \n    for num in range(1, n + 1):\n        if is_prime(num) or all(num % ludic == 0 for ludic in ludic_numbers):\n            ludic_numbers.append(num)\n\n    return ludic_numbers\n",
    "MbppEval/598": "def armstrong_number(number):\n    num_digits = len(str(number))\n    armstrong_sum = 0\n    \n    for digit_str in str(number):\n        digit = int(digit_str)\n        \n        digit_power = digit ** num_digits\n        armstrong_sum += digit_power\n        \n    return armstrong_sum == number\n",
    "MbppEval/600": "def is_Even(n):\n    return n % 2 == 0\n",
    "MbppEval/606": "import math\n\ndef radian_degree(degree):\n    return degree * (math.pi / 180)\n",
    "MbppEval/608": "def bell_Number(n):\n    bell_numbers = [0] * (n + 1)\n    bell_numbers[0] = bell_numbers[1] = 1\n    \n    for i in range(2, n + 1):\n        bell_numbers[i] = 0\n        for j in range(i):\n            bell_numbers[i] += bell_numbers[j] * bell_numbers[i - j - 1]\n    \n    return bell_numbers[n]\n",
    "MbppEval/604": "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string\n",
    "MbppEval/605": "import math\n\ndef prime_num(num):\n    if num < 2:\n        return False\n    \n    if num == 2:\n        return True\n    \n    for i in range(2, math.isqrt(num) + 1):\n        if num % i == 0:\n            return False\n    \n    return True\n",
    "MbppEval/395": "def first_non_repeating_character(str1):\n    freq = {}  \n    \n    for char in str1:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n\n    for char in str1:  \n        if freq[char] == 1:\n            return char\n\n    return None  \n",
    "MbppEval/612": "def merge(lst):\n    first_elements = []\n    second_elements = []\n    \n    for sub_list in lst:\n        first_elements.append(sub_list[0])\n        second_elements.append(sub_list[1])\n    \n    return [first_elements, second_elements]\n",
    "MbppEval/614": "def cummulative_sum(test_list):\n    total = 0\n    for tpl in test_list:\n        tuple_sum = sum(tpl)\n        total += tuple_sum\n    return total\n",
    "MbppEval/610": "def remove_kth_element(list1, k):\n    if not list1:\n        return []\n    \n    if k < 0 or k >= len(list1):\n        return list1\n    \n    list1.pop(k)\n    return list1\n",
    "MbppEval/617": "def min_Jumps(steps, d): \n    distance = abs(d)\n    jumps = distance / steps\n    return jumps\n",
    "MbppEval/615": "def average_tuple(nums):\n    averages = []\n    \n    for tpl in nums:\n        avg = sum(tpl) / len(tpl)\n        averages.append(avg)\n    \n    return averages\n",
    "MbppEval/618": "def div_list(nums1, nums2):\n    result = []\n    \n    for num1, num2 in zip(nums1, nums2):\n        result.append(num1 / num2)\n    \n    return result\n",
    "MbppEval/616": "def tuple_modulo(test_tup1, test_tup2):\n    result = []\n    \n    for elem1, elem2 in zip(test_tup1, test_tup2):\n        result.append(elem1 % elem2)\n    \n    return tuple(result)\n",
    "MbppEval/620": "from itertools import combinations\n\ndef largest_subset(a, k):\n    max_subset_size = 0\n    \n    # Loop through all possible subset sizes\n    for size in range(1, len(a) + 1):\n        # Generate all combinations of current size\n        for subset in combinations(a, size):\n            # Check if all pairs in the subset are divisible by k\n            if all(x % k == 0 and y % k == 0 for x, y in combinations(subset, 2)):\n                max_subset_size = max(max_subset_size, size)\n    \n    return max_subset_size\n",
    "MbppEval/115": "def empty_dit(list1):\n    result = True\n    if all(isinstance(item, dict) for item in list1):\n        for item in list1:\n            if isinstance(item, dict) and item:\n                result = False\n                break\n    return result\n",
    "MbppEval/624": "def is_upper(string):\n    return string.upper()\n",
    "MbppEval/622": "def get_median(arr1, arr2, n):\n    combined_arr = arr1 + arr2\n    combined_arr.sort()\n    mid = n // 2\n    if n % 2 == 0:\n        median = (combined_arr[mid - 1] + combined_arr[mid]) / 2\n    else:\n        median = combined_arr[mid]\n    return median\n",
    "MbppEval/626": "import math\n\ndef largest_inscribed_triangle_area(r):\n    return (math.sqrt(3) / 4) * r ** 2\n",
    "MbppEval/625": "def swap_List(newList): \n    if not newList:\n        return []\n\n    newList[0], newList[-1] = newList[-1], newList[0]\n    \n    return newList\n",
    "MbppEval/627": "def find_First_Missing(array, start=0, end=None):\n    if end is None:\n        end = len(array)\n    \n    for i in range(start, end):\n        if array[i] != i + start:\n            return i + start\n    \n    return end\n",
    "MbppEval/628": "def replace_spaces(string):\n    result = ''\n    \n    for char in string:\n        if char == ' ':\n            result += '%20'\n        else:\n            result += char\n    \n    return result\n",
    "MbppEval/623": "def nth_nums(nums, n):\n    result = []\n    for num in nums:\n        result.append(num ** n)\n    return result\n",
    "MbppEval/607": "import re\n\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        matching_substring = match.group(0)\n        start_index = match.start()\n        end_index = match.end() - 1\n        return matching_substring, start_index, end_index\n    else:\n        return None\n",
    "MbppEval/270": "def sum_even_and_even_index(arr):\n    sum_even_at_even_index = 0\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0 and index % 2 == 0:\n            sum_even_at_even_index += value\n\n    return sum_even_at_even_index\n",
    "MbppEval/619": "def move_num(test_str):\n    non_numeric_chars = \"\"\n    numeric_chars = \"\"\n    \n    for char in test_str:\n        if char.isnumeric():\n            numeric_chars += char\n        else:\n            non_numeric_chars += char\n    \n    return non_numeric_chars + numeric_chars\n",
    "MbppEval/637": "def noprofit_noloss(actual_cost, sale_amount):\n    return actual_cost == sale_amount\n",
    "MbppEval/638": "import math\n\ndef wind_chill(v, t):\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wind_chill_index)\n",
    "MbppEval/635": "import heapq as hq\n\ndef heap_sort(iterable):\n    sorted_list = []\n    \n    # Step 1: Create a min heap\n    heap = list(iterable)\n    hq.heapify(heap)\n    \n    # Step 2: Extract elements from the heap and append to the sorted list\n    while heap:\n        sorted_list.append(hq.heappop(heap))\n    \n    return sorted_list\n",
    "MbppEval/641": "def is_nonagonal(n):\n    return n * (7*n - 5) // 2\n",
    "MbppEval/639": "def sample_nam(sample_names):\n    total_length = 0\n    \n    for name in sample_names:\n        if name[0].isupper():\n            total_length += len(name)\n\n    return total_length\n",
    "MbppEval/633": "def pair_xor_Sum(arr, n):\n    result = 0\n    xor_sum = 0\n\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += arr[i] ^ arr[j]\n\n    result = xor_sum\n\n    return result\n",
    "MbppEval/596": "import sys\n\ndef tuple_size(tuple_list):\n    size_in_bytes = sys.getsizeof(tuple_list)\n    return size_in_bytes\n",
    "MbppEval/640": "import re\n\ndef remove_parenthesis(items):\n    pattern = r\"\\(.*?\\)\"\n    modified_items = re.sub(pattern, \"\", items[0])\n    return modified_items\n\n# Test cases\nprint(remove_parenthesis([\"python (chrome)\"]))  # \"python\"\nprint(remove_parenthesis([\"string(.abc)\"]))     # \"string\"\nprint(remove_parenthesis([\"alpha(num)\"]))        # \"alpha\"\n",
    "MbppEval/644": "def reverse_Array_Upto_K(input, k): \n    arr_copy = input.copy()\n    arr_copy[:k] = arr_copy[:k][::-1]\n    return arr_copy\n",
    "MbppEval/643": "import re\n\ndef text_match_wordz_middle(text):\n    pattern = r'\\b\\w*z\\w*\\b'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
    "MbppEval/91": "def find_substring(str1, sub_str):\n    for string in str1:\n        if sub_str in string:\n            return True\n    return False\n",
    "MbppEval/722": "return filtered_students\n",
    "MbppEval/116": "def tuple_to_int(nums):\n    # Step 1: Take the input tuple of positive integers\n    num_str = ''.join(map(str, nums))\n    \n    # Step 2: Initialize an empty string to store the concatenated integers\n    int_val = ''\n    \n    # Step 3: Iterate over each element in the tuple\n    for num in nums:\n        int_val += str(num)\n    \n    return int_val\n",
    "MbppEval/720": "def add_dict_to_tuple(test_tup, test_dict):\n    test_list = list(test_tup)\n    test_list.append(test_dict)\n    updated_tuple = tuple(test_list)\n    return updated_tuple\n",
    "MbppEval/724": "def power_base_sum(base, power):\n    result = base ** power\n    digit_sum = 0\n    for digit in str(result):\n        digit_sum += int(digit)\n    return digit_sum\n",
    "MbppEval/721": "def maxAverageOfPath(cost):\n    if not cost or not cost[0]:\n        return 0\n    \n    n = len(cost)\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    \n    return dp[n-1][n-1] / (2 * n - 1)\n",
    "MbppEval/732": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)\n",
    "MbppEval/725": "import re\n\ndef extract_quotation(text1):\n    return re.findall(r'\"(.*?)\"', text1)\n",
    "MbppEval/730": "from itertools import groupby\n\ndef remove_consecutive_duplicates(nums):\n    return [x for x, _ in groupby(nums)]\n\ndef consecutive_duplicates(nums):\n    return remove_consecutive_duplicates(nums)\n",
    "MbppEval/726": "def multiply_elements(test_tup):\n    result = []\n    for i in range(len(test_tup) - 1):\n        result.append(test_tup[i] * test_tup[i + 1])\n    return tuple(result)\n",
    "MbppEval/731": "import math\n\ndef lateralsurface_cone(r, h):\n    slant_height = math.sqrt(r**2 + h**2)\n    lateral_surface_area = math.pi * r * slant_height\n    \n    return lateral_surface_area\n",
    "MbppEval/415": "def max_Product(arr): \n    if len(arr) < 2:\n        return \"Array should have at least two elements\"\n    \n    # Initialize variables to track four elements\n    min1, min2 = min(arr[0], arr[1]), max(arr[0], arr[1])\n    max1, max2 = max(arr[0], arr[1]), min(arr[0], arr[1])\n    \n    # Iterate over the array starting from the third element\n    for i in range(2, len(arr)):\n        if arr[i] < min1:\n            min2 = min1\n            min1 = arr[i]\n        elif arr[i] < min2:\n            min2 = arr[i]\n\n        if arr[i] > max1:\n            max2 = max1\n            max1 = arr[i]\n        elif arr[i] > max2:\n            max2 = arr[i]\n    \n    # Calculate the products of (min1, min2) and (max1, max2)\n    product1 = min1 * min2\n    product2 = max1 * max2\n    \n    return (min1, min2) if product1 > product2 else (max1, max2)\n\n# Test the function\nprint(max_Product([1, 2, 3, 4, 7, 0, 8, 4]))\nprint(max_Product([0, -1, -2, -4, 5, 0, -6]))\nprint(max_Product([1, 2, 3]))\n",
    "MbppEval/734": "def sum_Of_Subarray_Prod(arr):\n    result = 0\n    total_sum = sum(arr)\n    \n    for num in arr:\n        result += num * (total_sum - num)\n    \n    return result\n",
    "MbppEval/728": "def sum_list(lst1, lst2):\n    return [a + b for a, b in zip(lst1, lst2)]\n",
    "MbppEval/738": "def geometric_sum(n):\n    sum = 0\n    for i in range(n-1):\n        sum += 1 / 2**i\n    return sum\n",
    "MbppEval/739": "import math\n\ndef find_Index(n):\n    def triangular_number(index):\n        return index * (index + 1) // 2\n\n    index = 1\n    while True:\n        current_triangular_number = triangular_number(index)\n        if math.floor(math.log10(current_triangular_number) + 1) == n:\n            return index\n        index += 1\n",
    "MbppEval/735": "def set_middle_bits(n):\n    binary_str = bin(n)[2:]\n    \n    # Keep the first and last bits as they are\n    first_bit = binary_str[0]\n    last_bit = binary_str[-1]\n    \n    # Toggle all the bits in between the first and last bits\n    middle_bits = ''.join(['1' if bit == '0' else '0' for bit in binary_str[1:-1]])\n    \n    new_binary_str = first_bit + middle_bits + last_bit\n    \n    return int(new_binary_str, 2)\n",
    "MbppEval/736": "import bisect\n\ndef left_insert_list(a, x):\n    return bisect.bisect_left(a, x)\n",
    "MbppEval/589": "import math\n\ndef perfect_squares(a, b):\n    squares = []\n    for num in range(a, b + 1):\n        if math.sqrt(num).is_integer():\n            squares.append(num)\n    return squares\n",
    "MbppEval/742": "import math\n\ndef area_tetrahedron(side):\n    # Calculate the area of the tetrahedron using the formula: A = sqrt(3) * side^2\n    area = math.sqrt(3) * side**2\n    return area\n",
    "MbppEval/744": "def check_none(test_tup):\n    for item in test_tup:\n        if item is None:\n            return True\n    return False\n",
    "MbppEval/746": "import math\ndef sector_area(r, a):\n    if a > 360:\n        return None\n    area = (a / 360) * math.pi * r ** 2\n    return area\n",
    "MbppEval/740": "    return result_dict\n",
    "MbppEval/747": "def lcs_of_three(X, Y, Z): \n    dp = [[[0 for _ in range(len(Z) + 1)] for _ in range(len(Y) + 1)] for _ in range(len(X) + 1)]\n    \n    for i in range(1, len(X) + 1):\n        for j in range(1, len(Y) + 1):\n            for k in range(1, len(Z) + 1):\n                if X[i - 1] == Y[j - 1] == Z[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n                    \n    return dp[-1][-1][-1]\n",
    "MbppEval/749": "def sort_numeric_strings(nums_str):\n    nums_int = [int(num) for num in nums_str]\n    sorted_nums = sorted(nums_int)\n    return sorted_nums\n",
    "MbppEval/611": "def max_of_nth(test_list, N):\n    max_value = None\n    \n    for row in test_list:\n        value = row[N-1]\n        if max_value is None or value > max_value:\n            max_value = value\n            \n    return max_value\n",
    "MbppEval/748": "def capital_words_spaces(str1):\n    result = \"\"  # Step 0: Initialize an empty string to store the result\n\n    for i, char in enumerate(str1):\n        if i > 0 and char.isupper():  # Step 1: Check if the character is in uppercase\n            result += \" \"  # Step 2: Add space before capital letter\n        result += char  # Step 3: Append the character to the result string\n        \n    return result  # Step 4: Return the modified string\n",
    "MbppEval/741": "def all_Characters_Same(s):\n    if len(s) <= 1:\n        return True\n    \n    first_char = s[0]\n    for char in s[1:]:\n        if char != first_char:\n            return False\n    \n    return True\n",
    "MbppEval/753": "def min_k(test_list, K):\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    return sorted_list[:K]\n",
    "MbppEval/750": "def add_tuple(test_list, test_tup):\n    test_tup_as_list = list(test_tup)\n    test_list.extend(test_tup_as_list)\n    return test_list\n",
    "MbppEval/752": "def jacobsthal_num(n):\n    if not isinstance(n, int) or n < 0:\n        return \"Invalid input. Please provide a non-negative integer.\"\n    \n    # Base cases for n = 0 and n = 1\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Recursive function to calculate the nth Jacobsthal number\n    def jacobsthal_recursive(n):\n        return jacobsthal_recursive(n-1) + 2 * jacobsthal_recursive(n-2)\n    \n    return jacobsthal_recursive(n)\n",
    "MbppEval/67": "import math\n\ndef bell_triangle(n):\n    triangle = [[1]]\n    for row in range(1, n):\n        prev_row = triangle[row - 1]\n        new_row = [prev_row[0]]\n        for i in range(1, row + 1):\n            new_row.append(new_row[-1] + prev_row[i])\n        triangle.append(new_row)\n    return triangle\n\ndef bell_number(n):\n    bell_numbers = bell_triangle(n)[-1]\n    return bell_numbers[-1]\n",
    "MbppEval/630": "def adjac(ele, sub = []): \n    adj_coords = []  # Step 0: Create an empty list to store the adjacent coordinates\n    \n    # Step 1: Loop through the range of -1 to 2 to get the adjacent row offsets\n    for i in range(-1, 2):\n        # Step 2: Loop through the range of -1 to 2 to get the adjacent column offsets\n        for j in range(-1, 2):\n            # Step 3: Add the coordinates to the list\n            adj_coords.append([ele[0] + i, ele[1] + j])\n    \n    # Step 4: Return the list of adjacent coordinates\n    return adj_coords\n",
    "MbppEval/756": "import re\n\ndef text_match_zero_one(text):\n    pattern = 'ab+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
    "MbppEval/755": "def second_smallest(numbers):\n    '''Return the second smallest number in a list.'''\n    unique_numbers = list(set(numbers))\n    if len(unique_numbers) < 2:\n        return None\n    \n    sorted_numbers = sorted(unique_numbers)\n    \n    return sorted_numbers[1]\n",
    "MbppEval/757": "def count_reverse_pairs(test_list):\n    count = 0\n\n    for i in range(len(test_list)):\n        for j in range(i+1, len(test_list)):\n            if test_list[i][::-1] == test_list[j]:\n                count += 1\n\n    return str(count)\n",
    "MbppEval/12": "def sort_matrix(M):\n    def row_sum(row):\n        return sum(row)\n\n    def calculate_row_sums(matrix):\n        row_sums = []\n        for row in matrix:\n            row_sums.append(row_sum(row))\n        return row_sums\n\n    def create_row_sum_tuples(matrix):\n        row_sums = calculate_row_sums(matrix)\n        row_sum_tuples = [(index, row_sum) for index, row_sum in enumerate(row_sums)]\n        return row_sum_tuples\n\n    row_sum_tuples = create_row_sum_tuples(M)\n    sorted_row_sum_tuples = sorted(row_sum_tuples, key=lambda x: x[1])\n    sorted_matrix = [M[row[0]] for row in sorted_row_sum_tuples]\n    return sorted_matrix\n",
    "MbppEval/737": "import re \n\nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\n\ndef check_str(string): \n    if re.match(regex, string):\n        return 'Valid'\n    else:\n        return 'Invalid'\n",
    "MbppEval/760": "def unique_Element(arr):\n    unique_set = set(arr)\n    \n    if len(unique_set) == 1:\n        return 'YES'\n    else:\n        return 'NO'\n",
    "MbppEval/763": "def find_min_diff(arr, n):\n    min_diff = float('inf')\n    arr.sort()\n    for i in range(n - 1):\n        diff = abs(arr[i] - arr[i + 1])\n        min_diff = min(min_diff, diff)\n    return min_diff\n",
    "MbppEval/762": "def check_monthnumber_number(monthnum3):\n    if 1 <= monthnum3 <= 12:\n        if monthnum3 in [4, 6, 9, 11]:\n            return True\n        else:\n            return False\n    else:\n        return False\n",
    "MbppEval/223": "def is_majority(arr, n, x):\n    if n == 0:\n        return False\n\n    start = 0\n    end = n - 1\n\n    # Binary search to find the first occurrence\n    while start <= end:\n        mid = start + (end - start) // 2\n        if (mid == 0 or arr[mid - 1] < x) and arr[mid] == x:\n            first_occurrence = mid\n            break\n        elif arr[mid] < x:\n            start = mid + 1\n        else:\n            end = mid - 1\n    \n    # Binary search to find the last occurrence\n    start = 0\n    end = n - 1\n    while start <= end:\n        mid = start + (end - start) // 2\n        if (mid == n-1 or arr[mid + 1] > x) and arr[mid] == x:\n            last_occurrence = mid\n            break\n        elif arr[mid] > x:\n            end = mid - 1\n        else:\n            start = mid + 1\n    \n    count = last_occurrence - first_occurrence + 1\n    return count > n/2\n",
    "MbppEval/770": "def odd_num_sum(n):\n    sum = 0\n    odd_number = 1\n\n    for i in range(n):\n        sum += odd_number ** 4\n        odd_number += 2  # Move to the next odd number\n\n    return sum\n",
    "MbppEval/765": "import math\n\ndef prime_factors(n):\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n    if n > 2:\n        factors.append(n)\n    return set(factors)\n\ndef is_polite(n):\n    count = 0\n    num = 1\n    while count < n:\n        if len(prime_factors(num)) % 2 == 0:\n            count += 1\n        num += 1\n    return num\n\n# Test the function with sample inputs\nprint(is_polite(7))  # Output should be 11\nprint(is_polite(4))  # Output should be 7\nprint(is_polite(9))  # Output should be 13\n",
    "MbppEval/766": "def pair_wise(l1):\n    pairs = []\n    \n    for i in range(len(l1) - 1):\n        pair = (l1[i], l1[i + 1])\n        pairs.append(pair)\n    \n    return pairs\n",
    "MbppEval/759": "from decimal import Decimal\n\ndef is_decimal(num):\n    if not isinstance(num, str):\n        return False\n    \n    if '.' not in num:\n        return False\n    \n    try:\n        decimal_part = num.split('.')[1]\n        if len(decimal_part) != 2 or not decimal_part.isdigit():\n            return False\n    except IndexError:\n        return False\n    \n    try:\n        decimal_num = Decimal(num)\n        return True\n    except:\n        return False\n",
    "MbppEval/773": "def occurance_substring(text, pattern):\n    start = None\n    for match in re.finditer(pattern, text):\n        start = match.start()\n        end = match.end()\n        return (pattern, start, end)\n    return None\n",
    "MbppEval/769": "def Diff(li1, li2):\n    diff_list = []\n    \n    # Step 1: Iterate over the elements in the first list\n    for ele in li1:\n        # Step 2: Check if the element is present in the second list\n        if ele not in li2:\n            diff_list.append(ele)\n    \n    # Step 3: Append elements only present in the second list\n    for ele in li2:\n        if ele not in li1:\n            diff_list.append(ele)\n    \n    # Step 4: Return the list containing the difference between the two lists\n    return diff_list\n",
    "MbppEval/772": "def remove_length(test_str, K):\n    words = test_str.split()\n    filtered_words = [word for word in words if len(word) != K]\n    return ' '.join(filtered_words)\n",
    "MbppEval/775": "def odd_position(nums):\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True\n",
    "MbppEval/580": "def even_ele(test_tuple, even_fnc): \n    def even_fnc(num):\n        return num % 2 == 0\n        \n    result = ()\n    for item in test_tuple:\n        if isinstance(item, tuple):\n            result += (even_ele(item, even_fnc),)\n        elif isinstance(item, int) and even_fnc(item):\n            result += (item,)\n\n    return result\n",
    "MbppEval/299": "from collections import defaultdict\n\ndef max_aggregate(stdata):\n    aggregate_scores = defaultdict(int)\n    \n    for student, score in stdata:\n        if student in aggregate_scores:\n            aggregate_scores[student] += score\n        else:\n            aggregate_scores[student] = score\n    \n    max_student = max(aggregate_scores, key=aggregate_scores.get)\n    \n    return (max_student, aggregate_scores[max_student])\n",
    "MbppEval/781": "import math\n\ndef count_divisors(n):\n    divisors = [i for i in range(1, n+1) if n % i == 0]\n    count = len(divisors)\n    \n    if count % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n",
    "MbppEval/776": "def count_vowels(test_str):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    \n    for i in range(1, len(test_str)-1):\n        if test_str[i-1] in vowels or test_str[i+1] in vowels:\n            count += 1\n    \n    return count\n",
    "MbppEval/632": "def move_zero(num_list):\n    non_zero_list = []\n    zero_count = 0\n    for num in num_list:\n        if num != 0:\n            non_zero_list.append(num)\n        else:\n            zero_count += 1\n\n    non_zero_list.extend([0] * zero_count)\n\n    return non_zero_list\n",
    "MbppEval/764": "def number_ctr(s):\n    digit_count = 0  # Step 2: Initialize a counter variable to store the number of digits found in the string\n\n    # Step 3: Iterate through each character in the input string\n    for char in s:\n        # Step 4: Check if the character is a digit\n        if char.isdigit():\n            # Step 5: If the character is a digit, increment the counter variable\n            digit_count += 1\n\n    return digit_count  # Step 6: Return the final count of digits found in the string\n",
    "MbppEval/779": "def unique_sublists(list1):\n    unique_counts = {}\n    \n    for sublist in list1:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in unique_counts:\n            unique_counts[sublist_tuple] += 1\n        else:\n            unique_counts[sublist_tuple] = 1\n    \n    return unique_counts\n",
    "MbppEval/786": "import bisect\n\ndef right_insertion(a, x):\n    if not a:\n        return 0\n    return bisect.bisect_right(a, x)\n\nprint(right_insertion([1,2,4,5],6))\nprint(right_insertion([1,2,4,5],3))\nprint(right_insertion([1,2,4,5],7))\n",
    "MbppEval/777": "def find_sum(arr): \n    count_dict = {}\n    \n    # Step 1: Update the count of each element in the dictionary\n    for elem in arr:\n        if elem in count_dict:\n            count_dict[elem] += 1\n        else:\n            count_dict[elem] = 1\n    \n    non_repeated_sum = 0\n    # Step 2: Sum up the values for keys with a count of 1\n    for key, value in count_dict.items():\n        if value == 1:\n            non_repeated_sum += key * value  # Sum up the values, not the keys\n    \n    return non_repeated_sum\n",
    "MbppEval/780": "from itertools import combinations \n\ndef find_combinations(test_list):\n    \"\"\"\n    Write a function to find the combinations of sums with tuples in the given tuple list. \n    \"\"\"\n    combination_sums = []  # Step 1: Initialize an empty list to store the combination sums\n    \n    for comb in combinations(test_list, 2):  # Step 2: Iterate over all combinations of 2 tuples\n        sum_tuple = tuple(sum(val) for val in zip(*comb))  # Calculate the sum of corresponding elements\n        combination_sums.append(sum_tuple)  # Step 4: Append the sum to the list of combination sums\n    \n    return combination_sums  # Return the list of combination sums\n",
    "MbppEval/784": "def mul_even_odd(list1):\n    product_even = 1\n    product_odd = 1\n    even_found = False\n    odd_found = False\n\n    for num in list1:\n        if num % 2 == 0 and not even_found:  # Check for even number\n            product_even *= num\n            even_found = True\n        elif num % 2 != 0 and not odd_found:  # Check for odd number\n            product_odd *= num\n            odd_found = True\n\n        if even_found and odd_found:  # Break the loop once both first even and odd numbers are found\n            break\n\n    return product_even * product_odd\n",
    "MbppEval/787": "import re\n\ndef text_match_three(text):\n    match = re.search(r'ab{3}', text)\n    if match:\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
    "MbppEval/788": "def new_tuple(test_list, test_str):\n    new_tuple = tuple(test_list + [test_str])\n    return new_tuple\n",
    "MbppEval/778": "from itertools import groupby\n\ndef pack_consecutive_duplicates(list1):\n    result = []\n    count = 0\n    prev_element = None\n\n    for element, group in groupby(list1):\n        element_count = len(list(group))\n        \n        if element != prev_element:\n            if count > 1:\n                result.append([prev_element] * count)\n            count = 0\n        \n        count += element_count\n        prev_element = element\n    \n    if count > 0:\n        result.append([prev_element] * count)\n\n    return result\n",
    "MbppEval/790": "def even_position(nums):\n    for index, value in enumerate(nums):\n        if index % 2 == 0:\n            if value % 2 != 0:\n                return False\n    return True\n",
    "MbppEval/785": "def tuple_str_int(test_str):\n    if test_str.startswith(\"(\") and test_str.endswith(\")\"):\n        test_str = test_str[1:-1]\n        str_list = test_str.split(\", \")\n        int_list = [int(item) for item in str_list]\n        int_tuple = tuple(int_list)\n        return int_tuple\n    return None\n",
    "MbppEval/783": "def rgb_to_hsv(r, g, b):\n    r /= 255.0\n    g /= 255.0\n    b /= 255.0\n    \n    max_value = max(r, g, b)\n    min_value = min(r, g, b)\n    diff = max_value - min_value\n    \n    v = max_value * 100\n    \n    if max_value == 0:\n        s = 0\n    else:\n        s = (diff / max_value) * 100\n    \n    if max_value == min_value:\n        h = 0\n    else:\n        if max_value == r:\n            h = 60 * ((g - b) / diff)\n        elif max_value == g:\n            h = 60 * (2 + ((b - r) / diff))\n        else:\n            h = 60 * (4 + ((r - g) / diff))\n            \n        if h < 0:\n            h += 360\n    \n    return (h, s, v)\n",
    "MbppEval/791": "def remove_nested(test_tup):\n    non_nested_elements = []\n    \n    for elem in test_tup:\n        if not isinstance(elem, tuple):\n            non_nested_elements.append(elem)\n    \n    return tuple(non_nested_elements)\n",
    "MbppEval/782": "def odd_length_sum(arr):\n    result = 0\n    \n    for i in range(len(arr)):  \n        for j in range(i, len(arr)):  \n            subarray_sum = sum(arr[i:j+1]) \n            if (j - i + 1) % 2 != 0:  \n                result += subarray_sum  \n    \n    return result  \n",
    "MbppEval/792": "def count_list(input_list): \n    count = 0\n    for element in input_list:\n        if isinstance(element, list):\n            count += 1\n    return count\n",
    "MbppEval/793": "def last(arr, element, length):\n    for i in range(length-1, -1, -1):\n        if arr[i] == element:\n            return i\n    return -1\n",
    "MbppEval/796": "def return_sum(dict):\n    total_sum = 0\n    for key, value in dict.items():\n        total_sum += value\n    return total_sum\n",
    "MbppEval/800": "import re\n\ndef remove_all_spaces(text):\n    return re.sub(r'\\s+', '', text)\n",
    "MbppEval/799": "def left_rotate(n, d):\n    binary_n = bin(n)[2:]\n    binary_n = binary_n.zfill(32)\n    rotated_binary = binary_n[d:] + binary_n[:d]\n    rotated_num = int(rotated_binary, 2)\n    return rotated_num\n",
    "MbppEval/797": "def sum_odd(l, r): \n    sum_odd_numbers = 0\n    for num in range(l, r + 1):\n        if num % 2 != 0:\n            sum_odd_numbers += num\n    return sum_odd_numbers\n",
    "MbppEval/798": "def _sum(arr):\n    total_sum = 0\n    \n    for num in arr:\n        total_sum += num\n        \n    return total_sum\n",
    "MbppEval/803": "import math\n\ndef is_perfect_square(n):\n    if n < 0:\n        return False\n    \n    root = math.sqrt(n)\n    return root.is_integer()\n\n# Test cases\nprint(is_perfect_square(10))  # Output: False\nprint(is_perfect_square(36))  # Output: True\nprint(is_perfect_square(14))  # Output: False\n",
    "MbppEval/802": "def count_rotation(arr):\n    if not arr:\n        return 0\n    else:\n        min_index = arr.index(min(arr))\n        return min_index\n",
    "MbppEval/804": "def is_product_even(arr):\n    product = 1\n    for num in arr:\n        product *= num\n\n    return product % 2 == 0\n",
    "MbppEval/801": "def test_three_equal(x, y, z):\n    count = 0\n    \n    if x == y == z:\n        count += 3\n\n    if x == y or y == z or x == z:\n        count += 2\n\n    return count\n",
    "MbppEval/807": "def first_odd(nums):\n    for num in nums:\n        if num % 2 != 0:\n            return num\n    return None\n",
    "MbppEval/743": "def rotate_right(lst, m):\n    '''\n    Write a function to rotate a given list by specified number of items to the right direction. \n    Examples:\n    rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],3,4) == [8, 9, 10, 1, 2, 3, 4, 5, 6]\n    rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],2,2) == [9, 10, 1, 2, 3, 4, 5, 6, 7, 8]\n    rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],5,2) == [6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8]\n    '''\n    # Ensure that m is a non-negative integer\n    if not isinstance(m, int) or m < 0:\n        raise ValueError(\"Rotation value 'm' must be a non-negative integer.\")\n        \n    # Calculate the effective number of rotations\n    n = len(lst)\n    m = m % n\n    \n    # Split the list into right and left portions\n    right_part = lst[-m:]\n    left_part = lst[:-m]\n    \n    # Concatenate the right part with the left part\n    rotated_lst = right_part + left_part\n    \n    # Return the rotated list\n    return rotated_lst\n",
    "MbppEval/808": "def check_K(test_tup, K):\n    return K in test_tup\n\n# Testing the function with the given examples\nprint(check_K((10, 4, 5, 6, 8), 6))  # Expected output: True\nprint(check_K((1, 2, 3, 4, 5, 6), 7))  # Expected output: False\nprint(check_K((7, 8, 9, 44, 11, 12), 11))  # Expected output: True\n",
    "MbppEval/560": "def union_elements(test_tup1, test_tup2):\n    combined_tuple = (*test_tup1, *test_tup2)\n    unique_set = set(combined_tuple)\n    sorted_tuple = tuple(sorted(unique_set))\n    return sorted_tuple\n",
    "MbppEval/794": "import re\n\ndef text_starta_endb(text):\n    pattern = r'a.*b$'\n    match = re.search(pattern, text)\n    if match:\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
    "MbppEval/805": "def max_sum_list(lists):\n    max_list = []\n    max_sum = float('-inf')\n    \n    for lst in lists:\n        sum_lst = sum(lst)\n        \n        if sum_lst > max_sum:\n            max_sum = sum_lst\n            max_list = lst\n    \n    return max_list\n",
    "MbppEval/806": "def max_run_uppercase(test_str):\n    max_run = 0\n    current_run = 0\n\n    for char in test_str:\n        if char.isupper():\n            current_run += 1\n        else:\n            max_run = max(max_run, current_run)\n            current_run = 0\n\n    max_run = max(max_run, current_run)\n    \n    return max_run\n",
    "MbppEval/227": "def min_of_three(a, b, c): \n    '''\n    Write a function to find the minimum of three numbers.\n    Uses the built-in min() function to find the minimum value.\n    '''\n    return min(a, b, c)\n",
    "MbppEval/809": "def check_smaller(test_tup1, test_tup2):\n    if len(test_tup1) == len(test_tup2):\n        smaller_flag = True\n        for i in range(len(test_tup1)):\n            if test_tup2[i] >= test_tup1[i]:\n                smaller_flag = False\n                break\n        return smaller_flag\n    else:\n        return False\n",
    "MbppEval/767": "def get_pairs_count(arr, target_sum):\n    pairs_count = 0\n    num_count = {}\n    \n    for num in arr:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n\n    for num in arr:\n        difference = target_sum - num\n        if difference in num_count:\n            pairs_count += num_count[difference]\n        \n        num_count[num] -= 1\n\n    return pairs_count\n",
    "MbppEval/94": "from operator import itemgetter\n\ndef index_minimum(test_list):\n    min_value = float('inf')\n    result = ''\n    \n    if not test_list:\n        return None\n    \n    for name, value in test_list:\n        if value < min_value:\n            min_value = value\n            result = name\n\n    return result\n",
    "MbppEval/305": "def start_withp(words):\n    p_words = []\n    for sentence in words:\n        individual_words = sentence.split()\n        for word in individual_words:\n            if word.lower().startswith('p'):\n                p_words.append(word)\n    \n    if len(p_words) < 2:\n        return tuple(p_words)\n    else:\n        return tuple(p_words[:2])\n\n# Test the function with provided examples\nprint(start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"]))\nprint(start_withp([\"Python Programming\",\"Java Programming\"]))\nprint(start_withp([\"Pqrst Pqr\",\"qrstuv\"]))\n",
    "MbppEval/562": "def Find_Max_Length(lst):\n    max_length = 0\n\n    # Step 1: Define a function named Find_Max_Length that takes a list lst as input\n    # Step 2: Initialize a variable named max_length with 0, to store the maximum length found so far\n    # Step 3: Iterate over each sublist in the input list lst\n\n    for sublist in lst:\n        # Step 4: For each sublist, find its length and compare it with the current max_length\n        sublist_length = len(sublist)\n        if sublist_length > max_length:\n            max_length = sublist_length\n\n    # Step 6: Return the final value of max_length after iterating through all sublists\n    return max_length\n",
    "MbppEval/631": "def replace_spaces(text):\n    result = ''\n    \n    for char in text:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n            \n    return result\n",
    "MbppEval/576": "def is_Sub_Array(A, B):\n    if len(B) == 0 or len(B) > len(A):\n        return False\n\n    for i in range(len(A)):\n        if A[i] == B[0]:\n            sublist_match = True\n            for j in range(1, len(B)):\n                if i + j >= len(A) or A[i + j] != B[j]:\n                    sublist_match = False\n                    break\n            if sublist_match:\n                return True\n\n    return False\n",
    "MbppEval/476": "def big_sum(nums):\n    max_val = max(nums)\n    min_val = min(nums)\n    return max_val + min_val\n",
    "MbppEval/304": "def rotate_array(arr, rotations):\n    n = len(arr)\n    rotations %= n\n    arr[:] = arr[rotations:] + arr[:rotations]\n\ndef extract_subarray(arr, start, end):\n    return arr[start:end+1]\n\ndef find_element(arr, ranges, rotations, index):\n    rotate_array(arr, rotations)\n    \n    for start, end in ranges:\n        subarray = extract_subarray(arr, start, end)\n        if index < len(subarray):\n            return subarray[index]\n    \n    return None\n",
    "MbppEval/160": "def find_solution(a, b, n):\n    '''\n    Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\n\n    Examples:\n    solution(2, 3, 7) == ('x = ', 2, ', y = ', 1)\n    solution(4, 2, 7) == 'No solution'\n    solution(1, 13, 17) == ('x = ', 4, ', y = ', 1)\n    '''\n\n    if a == 0 and b == 0:\n        return \"Infinite solutions\"\n    \n    if a != 0 and b != 0:\n        def extended_gcd(a, b):\n            if a == 0:\n                return b, 0, 1\n            else:\n                g, y, x = extended_gcd(b % a, a)\n                return g, x - (b // a) * y, y\n        \n        gcd, x, y = extended_gcd(a, b)\n        \n        if n % gcd == 0:\n            x *= n // gcd\n            y *= n // gcd\n            return ('x = ', x, ', y = ', y)\n        else:\n            return 'No solution'\n",
    "MbppEval/629": "def Split(lst):\n    '''\n    Write a python function to find even numbers from a list of numbers.\n    '''\n    even_numbers = []\n    \n    for num in lst:\n        if num % 2 == 0:\n            even_numbers.append(num)\n    \n    return even_numbers\n",
    "MbppEval/413": "def extract_nth_element(list1, n):\n    if n < 0:\n        return \"Invalid index. Index should be >= 0.\"\n    \n    result = []\n    for tuple_element in list1:\n        result.append(tuple_element[n])\n    \n    return result\n",
    "MbppEval/745": "def divisible_by_digits(startnum, endnum):\n    result = []\n    \n    def is_divisible_by_digits(number):\n        digits = [int(d) for d in str(number) if int(d) != 0]\n        return all(number % digit == 0 for digit in digits)\n    \n    for num in range(startnum, endnum+1):\n        if is_divisible_by_digits(num):\n            result.append(num)\n    \n    return result\n",
    "MbppEval/74": "def is_samepatterns(colors, patterns):\n    if len(colors) != len(patterns):\n        return False\n    \n    color_map = {}\n    pattern_map = {}\n    \n    for i, (color, pattern) in enumerate(zip(colors, patterns)):\n        if color not in color_map:\n            color_map[color] = pattern\n        if pattern not in pattern_map:\n            pattern_map[pattern] = color\n        \n        if color_map[color] != pattern or pattern_map[pattern] != color:\n            return False\n    \n    return True\n",
    "MbppEval/754": "def extract_index_list(l1, l2, l3):\n    zipped_lists = zip(l1, l2, l3)\n    min_length = min(len(l1), len(l2), len(l3))\n\n    common_elements = []\n\n    for elements in zipped_lists:\n        if all(x == elements[0] for x in elements):\n            common_elements.append(elements[0])\n\n    return common_elements\n",
    "MbppEval/569": "def sort_sublists(list1):\n    sorted_list = []\n    for sublist in list1:\n        sorted_sublist = sorted(sublist)\n        sorted_list.append(sorted_sublist)\n\n    return sorted_list\n",
    "MbppEval/407": "def rearrange_bigger(n):\n    digits = [int(d) for d in str(n)]\n    \n    for i in range(len(digits) - 1, 0, -1):\n        if digits[i - 1] < digits[i]:\n            pivot = i - 1\n            break\n    else:\n        return False\n    \n    for i in range(len(digits) - 1, pivot, -1):\n        if digits[i] > digits[pivot]:\n            swap_index = i\n            break\n            \n    digits[pivot], digits[swap_index] = digits[swap_index], digits[pivot]\n    digits[pivot+1:] = sorted(digits[pivot+1:])\n    \n    result = int(''.join(map(str, digits)))\n    \n    return result\n",
    "MbppEval/283": "def validate(n):\n    n_str = str(n)\n    digit_freq = {}\n    for digit in n_str:\n        if digit in digit_freq:\n            digit_freq[digit] += 1\n        else:\n            digit_freq[digit] = 1\n\n    for digit, freq in digit_freq.items():\n        if freq > int(digit):\n            return False\n    return True\n",
    "MbppEval/751": "def check_min_heap_helper(arr, i):\n    if i >= len(arr):\n        return True\n\n    left_child = 2*i + 1\n\n    if left_child < len(arr) and arr[left_child] < arr[i]:\n        return False\n\n    right_child = 2*i + 2\n\n    if right_child < len(arr) and arr[right_child] < arr[i]:\n        return False\n\n    return check_min_heap_helper(arr, left_child) and check_min_heap_helper(arr, right_child)\n",
    "MbppEval/397": "def median_numbers(a, b, c):\n    sorted_numbers = [a, b, c]\n    sorted_numbers.sort()\n\n    middle_index = len(sorted_numbers) // 2\n    median = sorted_numbers[middle_index]\n\n    if a == b or b == c or a == c:\n        median = (a + b + c) - max(a, b, c) - min(a, b, c)\n\n    return median\n",
    "MbppEval/771": "from collections import deque\n\ndef check_expression(exp):\n    parentheses_map = {'(': ')', '[': ']', '{': '}'}\n    stack = deque()\n    \n    for char in exp:\n        if char in parentheses_map.keys():\n            stack.append(char)\n        \n        if char in parentheses_map.values():\n            if not stack or parentheses_map[stack.pop()] != char:\n                return False\n    \n    return len(stack) == 0\n\n# Testing the function with an example expression\nprint(check_expression(\"{()}[{}]\"))  # Expected output: True\n",
    "MbppEval/141": "def pancake_sort(nums):\n    if not nums:\n        return nums\n\n    n = len(nums)\n    for i in range(n - 1, 0, -1):\n        max_idx = nums.index(max(nums[:i + 1]))  # Find the index of the maximum element in the current subarray\n        \n        # Reverse the subarray up to the index of the maximum element\n        nums = nums[:max_idx + 1][::-1] + nums[max_idx + 1:]\n        \n        # Reverse the entire subarray to move the maximum element to its correct sorted position\n        nums = nums[:i][::-1] + nums[i:]\n\n    return nums\n\n# Test the function\nprint(pancake_sort([15, 79, 25, 38, 69]))  # Expected output: [15, 25, 38, 69, 79]\n",
    "MbppEval/723": "from operator import eq\n\ndef count_same_pair(nums1, nums2):\n    count = 0\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Input lists must be of the same length\")\n    \n    for i in range(len(nums1)):\n        if eq(nums1[i], nums2[i]):\n            count += 1\n    \n    return count\n",
    "MbppEval/70": "def find_equal_tuple(Input, n):\n    length = len(Input[0])\n    for tup in Input[1:]:\n        if len(tup) != n:\n            return 'All tuples do not have same length'\n    return 'All tuples have same length'\n",
    "MbppEval/758": "def unique_sublists(list1):\n    unique_lists_count = {}\n    \n    for sublist in list1:\n        tuple_sublist = tuple(sublist)\n        \n        if tuple_sublist in unique_lists_count:\n            unique_lists_count[tuple_sublist] += 1\n        else:\n            unique_lists_count[tuple_sublist] = 1\n    \n    return unique_lists_count\n",
    "MbppEval/131": "def reverse_vowels(str1):\n    vowels = \"aeiouAEIOU\"\n    vowel_list = [char for char in str1 if char in vowels]\n    reversed_vowels = vowel_list[::-1]\n    \n    new_str = \"\"\n    vowel_index = 0\n    \n    for char in str1:\n        if char in vowels:\n            new_str += reversed_vowels[vowel_index]\n            vowel_index += 1\n        else:\n            new_str += char\n    \n    return new_str\n",
    "MbppEval/96": "def divisor(n):\n    count = 0\n    \n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    \n    return count\n",
    "MbppEval/11": "def remove_Occ(s, ch):\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        return \"Character not found in the string\"\n    \n    if first_occurrence != -1:\n        s = s[:first_occurrence] + s[first_occurrence + 1:]\n        \n    last_occurrence = s.rfind(ch)\n    if last_occurrence != first_occurrence:\n        s = s[:last_occurrence] + s[last_occurrence + 1:]\n        \n    return s\n",
    "MbppEval/235": "def even_bit_set_number(n: int) -> int:\n    binary_n = bin(n)[2:]\n\n    # Create a mask with only even bits set to 1\n    mask = int(''.join(['1' if i % 2 == 0 else '0' for i in range(len(binary_n))]), 2)\n\n    # Perform a bitwise OR operation between the given number and the mask\n    result = n | mask\n\n    return result\n",
    "MbppEval/277": "def dict_filter(dict, n):\n    filtered_dict = {}\n\n    for key, value in dict.items():\n        if value >= n:\n            filtered_dict[key] = value\n\n    return filtered_dict\n",
    "MbppEval/417": "return grouped_tuples\n",
    "MbppEval/137": "from array import array\n\ndef zero_count(nums):\n    zero_count = 0\n    non_zero_count = 0\n\n    for num in nums:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n\n    return zero_count, non_zero_count\n\ndef calculate_ratio(zero_count, non_zero_count):\n    if zero_count == 0:\n        return 0.00\n\n    ratio = zero_count / non_zero_count\n    return round(ratio, 2)\n\ndef zero_count_ratio(nums):\n    if not nums or all(num == 0 for num in nums):\n        return 0.00\n\n    zeros, non_zeros = zero_count(nums)\n    return calculate_ratio(zeros, non_zeros)\n",
    "MbppEval/410": "def min_val(listval):\n    min_value = None\n    for val in listval:\n        if isinstance(val, (int, float)) or (isinstance(val, str) and val.replace('.', '', 1).isdigit()):\n            if min_value is None or val < min_value:\n                min_value = val\n    return min_value\n",
    "MbppEval/556": "def find_Odd_Pair(A, N):\n    count = 0\n    \n    for i in range(N):\n        for j in range(i+1, N):\n            xor_val = A[i] ^ A[j]\n            if xor_val % 2 == 1:\n                count += 1\n                \n    return count\n",
    "MbppEval/9": "def find_Rotations(s):\n    for i in range(1, len(s)):\n        rotated = s[i:] + s[:i]\n        if s == rotated:\n            return i\n    return -1\n",
    "MbppEval/250": "def count_X(tup, x):\n    count = 0\n    \n    for item in tup:\n        if item == x:\n            count += 1\n    return count\n",
    "MbppEval/424": "def extract_rear(test_tuple):\n    rear_chars = []\n    \n    for string in test_tuple:\n        rear_chars.append(string[-1])\n    \n    return rear_chars\n",
    "MbppEval/2": "def similar_elements(test_tup1, test_tup2):\n    set1 = set(test_tup1)\n    set2 = set(test_tup2)\n    \n    shared_elements = set1.intersection(set2)\n    \n    return tuple(shared_elements)\n",
    "MbppEval/399": "def bitwise_xor(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must be of the same length for bitwise XOR operation.\")\n    \n    return tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n",
    "MbppEval/401": "def add_nested_tuples(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must be of the same length.\")\n    \n    result = ()\n    \n    for tup1, tup2 in zip(test_tup1, test_tup2):\n        nested_sum = tuple(x + y for x, y in zip(tup1, tup2))\n        result += (nested_sum,)\n    \n    return result\n",
    "MbppEval/226": "def odd_values_string(input_str):\n    odd_chars = \"\"\n    \n    for index, char in enumerate(input_str):\n        if index % 2 != 0:\n            odd_chars += char\n            \n    return odd_chars\n",
    "MbppEval/130": "from collections import defaultdict\n\ndef max_occurrences(nums):\n    frequency_dict = defaultdict(int)\n    \n    for num in nums:\n        frequency_dict[num] += 1\n    \n    max_item = max(frequency_dict, key=frequency_dict.get)\n    max_freq = frequency_dict[max_item]\n    \n    return max_item, max_freq\n",
    "MbppEval/306": "def max_sum_increasing_subseq(a, n, index, k):\n    max_sum = 0\n    for i in range(index, n):\n        current_sum = a[index]  # Consider the ith element as the starting point\n        for j in range(index+1, i+1):\n            if a[j] > a[index]:\n                current_sum += a[j]\n                index = j\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n",
    "MbppEval/92": "def is_undulating(n):\n    if not isinstance(n, str):\n        return False\n    \n    if len(n) < 3:\n        return False\n\n    for i in range(len(n) - 2):\n        if n[i] == n[i + 1] and n[i + 1] != n[i + 2]:\n            continue\n        elif n[i] != n[i + 1] and n[i + 1] == n[i + 2]:\n            continue\n        else:\n            return False\n\n    return True\n",
    "MbppEval/300": "def count_binary_seq(n): \n    count = 0\n    binary_seq = []\n    for i in range(2**(2*n)):\n        seq = bin(i)[2:].zfill(2*n)\n        binary_seq.append(seq)\n\n    for seq in binary_seq:\n        sum_first_half = sum(int(bit) for bit in seq[:n])\n        sum_second_half = sum(int(bit) for bit in seq[n:])\n        if sum_first_half == sum_second_half:\n            count += 1\n\n    return count\n",
    "MbppEval/297": "def flatten_list(list1):\n    flattened_list = []\n\n    for element in list1:\n        if isinstance(element, list):\n            flattened_list.extend(flatten_list(element))\n        else:\n            flattened_list.append(element)\n\n    return flattened_list\n",
    "MbppEval/129": "def magic_square_test(my_matrix):\n    # Check if the matrix is a square matrix\n    if len(my_matrix) != len(my_matrix[0]):\n        return False\n\n    # Calculate the sum of the main diagonal elements\n    main_diagonal_sum = sum(my_matrix[i][i] for i in range(len(my_matrix)))\n\n    # Check the sums of rows, columns, and diagonals\n    for row in my_matrix:\n        if sum(row) != main_diagonal_sum:\n            return False\n\n    for col in zip(*my_matrix):\n        if sum(col) != main_diagonal_sum:\n            return False\n\n    if sum(my_matrix[i][i] for i in range(len(my_matrix))) != main_diagonal_sum:\n        return False\n\n    if sum(my_matrix[i][len(my_matrix) - 1 - i] for i in range(len(my_matrix))) != main_diagonal_sum:\n        return False\n\n    return True\n",
    "MbppEval/301": "def dict_depth(d):\n    depth = 0\n\n    if not d:\n        return depth\n\n    max_child_depth = 0\n    for value in d.values():\n        if isinstance(value, dict):\n            max_child_depth = max(max_child_depth, dict_depth(value))\n\n    return 1 + max_child_depth\n",
    "MbppEval/455": "def check_monthnumb_number(monthnum2):\n    month_days = {\n        1: False,  # January has 31 days\n        2: False,  # February does not have 31 days\n        3: True,   # March has 31 days\n        4: False,  # April does not have 31 days\n        5: True,   # May has 31 days\n        6: False,  # June does not have 31 days\n        7: True,   # July has 31 days\n        8: True,   # August has 31 days\n        9: False,  # September does not have 31 days\n        10: True,  # October has 31 days\n        11: False, # November does not have 31 days\n        12: True   # December has 31 days\n    }\n    \n    if monthnum2 in month_days:\n        return month_days[monthnum2]\n    else:\n        return False\n",
    "MbppEval/278": "def count_first_elements(test_tup):\n    count = 0\n    \n    for element in test_tup:\n        if element == test_tup:\n            break\n        count += 1\n    \n    return count\n",
    "MbppEval/256": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n\n    return count\n",
    "MbppEval/267": "def square_Sum(n):\n    odd_number = 1\n    sum_squares = 0\n    \n    for _ in range(n):\n        square = odd_number ** 2\n        sum_squares += square\n        odd_number += 2\n    \n    return sum_squares\n",
    "MbppEval/418": "def Find_Max(lst):\n    max_element = []\n    \n    for item in lst:\n        if len(item) > len(max_element):\n            max_element = item\n    \n    return max_element\n",
    "MbppEval/123": "def sum_proper_divisors(n):\n    divisors_sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            divisors_sum += i\n    return divisors_sum\n\ndef amicable_numbers_sum(limit):\n    amicable_sum = 0\n    for num in range(1, limit+1):\n        sum_div = sum_proper_divisors(num)\n        if sum_div != num and sum_proper_divisors(sum_div) == num:\n            amicable_sum += num\n    return amicable_sum\n",
    "MbppEval/408": "import heapq\n\ndef combine_pairs(nums1, nums2):\n    pairs = []\n    for num1 in nums1:\n        for num2 in nums2:\n            pairs.append((num1, num2))\n    \n    return pairs\n\ndef k_smallest_pairs(nums1, nums2, k):\n    pairs = combine_pairs(nums1, nums2)\n    \n    if not pairs:\n        return []\n    \n    heap = []\n    for pair in pairs:\n        heapq.heappush(heap, (pair[0] + pair[1], pair))\n    \n    smallest_pairs = []\n    for _ in range(min(k, len(heap))):\n        smallest_pairs.append(heapq.heappop(heap)[1])\n    \n    return smallest_pairs\n",
    "MbppEval/164": "import math\n\ndef div_sum(n, m):\n    def find_divisors(num):\n        divisors = []\n        for i in range(1, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                if num // i != i:\n                    divisors.append(num // i)\n        return divisors\n\n    divisors_n = find_divisors(n)\n    divisors_m = find_divisors(m)\n\n    div_sum_n = sum(divisors_n)\n    div_sum_m = sum(divisors_m)\n\n    return div_sum_n == div_sum_m\n",
    "MbppEval/142": "def count_samepair(list1, list2, list3):\n    count = 0\n    \n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    \n    return count\n",
    "MbppEval/247": "def lps(str): \n    if len(str) <= 1:\n        return len(str)\n    \n    n = len(str)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for sublen in range(2, n+1):\n        for i in range(n - sublen + 1):\n            j = i + sublen - 1\n            if str[i] == str[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n\n    return dp[0][n-1]\n",
    "MbppEval/228": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    mask = ((1 << (r - l + 1)) - 1) << l\n    masked_bits = n & mask\n\n    return masked_bits == 0\n",
    "MbppEval/462": "import itertools\n\ndef combinations_list(list1):\n    all_combinations = []  # Step 1\n    \n    for i in range(len(list1)+1):  # Step 2\n        for subset in itertools.combinations(list1, i):  # Step 3\n            all_combinations.append(list(subset))  # Append combination to the list\n\n    return all_combinations  # Step 4\n",
    "MbppEval/61": "from collections import defaultdict\n\ndef count_Substrings(s):\n    substr_count = 0\n\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            digit_sum = sum(int(d) for d in substring)\n            \n            if digit_sum == len(substring):\n                substr_count += 1\n    \n    return substr_count\n",
    "MbppEval/95": "def Find_Min_Length(lst):\n    min_length = float('inf')\n    \n    for sub_list in lst:\n        length = len(sub_list)\n        if length < min_length:\n            min_length = length\n    \n    return min_length\n",
    "MbppEval/100": "def next_smallest_palindrome(num):\n    def is_palindrome(number):\n        return str(number) == str(number)[::-1]\n\n    # Main function\n    while True:\n        num += 1\n        if is_palindrome(num):\n            return num\n",
    "MbppEval/419": "def round_and_sum(list1):\n    rounded_numbers = []\n\n    for number in list1:\n        rounded_number = round(number)\n        rounded_numbers.append(rounded_number)\n\n    total_sum = sum(rounded_numbers)\n    result = total_sum * len(list1)\n    return result\n\n# Test the function with example inputs\nprint(round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50]))\nprint(round_and_sum([5, 2, 9, 24.3, 29]))\nprint(round_and_sum([25.0, 56.7, 89.2]))\n",
    "MbppEval/296": "def get_Inv_Count(arr): \n    count = [0]  # Variable to store the count of inversions\n\n    def merge(arr, left_half, right_half):\n        i = j = k = 0\n        \n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] <= right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n                # Count the inversions when a number from right half is smaller than a number in the left half\n                count[0] += (len(left_half) - i)\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    def mergeSort(arr):\n        if len(arr) > 1:  # If the array has more than 1 element\n            mid = len(arr) // 2\n            left_half = arr[:mid]  # Divide the array into left half\n            right_half = arr[mid:]  # Divide the array into right half\n\n            mergeSort(left_half)  # Recursively sort the left half\n            mergeSort(right_half)  # Recursively sort the right half\n\n            merge(arr, left_half, right_half)  # Merge the sorted left and right halves\n\n    mergeSort(arr)  # Call the mergeSort function to count inversions\n    return count[0]  # Return the count of inversions\n",
    "MbppEval/245": "def max_sum(arr):\n    inc = [0] * len(arr)\n    dec = [0] * len(arr)\n    result = 0\n    \n    for i in range(len(arr)):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n    \n    for i in range(len(arr)-1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(len(arr)-1, i, -1):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n    \n    for i in range(len(arr)):\n        result = max(result, inc[i] + dec[i] - arr[i])\n    \n    return result\n",
    "MbppEval/18": "NO_OF_CHARS = 256\n\ndef remove_dirty_chars(string, dirty_chars):\n    clean_chars_list = [] \n\n    for char in string: \n        if char not in dirty_chars: \n            clean_chars_list.append(char) \n\n    clean_string = ''.join(clean_chars_list) \n    return clean_string\n\n# Testing the function with the given examples\nprint(remove_dirty_chars(\"probasscurve\", \"pros\"))  # Expected output: 'bacuve'\nprint(remove_dirty_chars(\"digitalindia\", \"talent\"))  # Expected output: 'digiidi'\nprint(remove_dirty_chars(\"exoticmiles\", \"toxic\"))  # Expected output: 'emles'\n",
    "MbppEval/391": "def convert_list_dictionary(l1, l2, l3):\n    result = []\n    for item1, item2, item3 in zip(l1, l2, l3):\n        nested_dict = {item1: {item2: item3}}\n        result.append(nested_dict)\n    \n    return result\n",
    "MbppEval/239": "def get_total_number_of_sequences(m, n):\n    def generate_sequences(curr_element, index, m, sequence):\n        if index == n:\n            return 1\n        \n        total = 0\n        for next_element in range(curr_element * 2, m + 1):\n            total += generate_sequences(next_element, index + 1, m, sequence + [next_element])\n\n        return total\n\n    return generate_sequences(1, 1, m, [1])\n",
    "MbppEval/733": "def find_first_occurrence(A, x):\n    for i in range(len(A)):\n        if A[i] == x:\n            return i\n    \n    return -1\n"
}
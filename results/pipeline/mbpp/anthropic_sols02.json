{
    "MbppEval/80": "def tetrahedral_number(n):\n    return (n * (n + 1) * (n + 2)) / 6\n",
    "MbppEval/67": "from math import comb\n\ndef bell_number(n):\n    bell_list = [0] * (n + 1)\n    bell_list[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            bell_list[i] += bell_list[j] * comb(i - 1, j)\n\n    return bell_list[n]\n",
    "MbppEval/18": "def remove_dirty_chars(string, chars_to_remove):\n    removal_set = set(chars_to_remove)\n    result = ''.join(char for char in string if char not in removal_set)\n    return result\n",
    "MbppEval/64": "def subject_marks(subjectmarks):\n    sorted_marks = sorted(subjectmarks, key=lambda x: x[1])\n    return sorted_marks\n",
    "MbppEval/12": "def sort_matrix(M):\n    row_sums = []\n    for row in M:\n        row_sum = sum(row)\n        row_sums.append(row_sum)\n    sorted_matrix = []\n    for row_sum in sorted(row_sums):\n        index = row_sums.index(row_sum)\n        sorted_matrix.append(M[index])\n    return sorted_matrix\n",
    "MbppEval/63": "def max_difference(test_list):\n    max_diff = 0\n    for a, b in test_list:\n        diff = abs(a - b)\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff\n",
    "MbppEval/4": "import heapq as hq\n\ndef heap_queue_largest(nums, n):\n    return sorted(hq.nlargest(n, nums), reverse=True)\n",
    "MbppEval/85": "import math\n\ndef surfacearea_sphere(r):\n    '''\n    Write a function to find the surface area of a sphere.\n\n    Examples:\n    surfacearea_sphere(10) == 1256.6370614359173\n    surfacearea_sphere(15) == 2827.4333882308138\n    surfacearea_sphere(20) == 5026.548245743669\n    '''\n    return 4 * math.pi * r ** 2\n",
    "MbppEval/19": "def test_duplicate(arraynums):\n    unique_elements = set()\n    for num in arraynums:\n        if num in unique_elements:\n            return True\n        unique_elements.add(num)\n    return False\n",
    "MbppEval/20": "def is_woodall(x):\n    woodall_number = 2 ** x + 1\n    return woodall_number == x\n",
    "MbppEval/70": "def find_equal_tuple(Input):\n    length = len(Input[0])\n    for tup in Input:\n        if len(tup) != length:\n            return \"All tuples do not have same length\"\n    return \"All tuples have same length\"\n",
    "MbppEval/8": "def square_nums(nums):\n    squared_nums = []\n    for num in nums:\n        squared_nums.append(num ** 2)\n    return squared_nums\n",
    "MbppEval/68": "def is_Monotonic(A):\n    is_increasing = True\n    is_decreasing = True\n    \n    for i in range(1, len(A)):\n        if A[i] > A[i-1]:\n            is_decreasing = False\n        if A[i] < A[i-1]:\n            is_increasing = False\n    \n    return is_increasing or is_decreasing\n",
    "MbppEval/16": "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n",
    "MbppEval/61": "from collections import defaultdict\n\ndef count_Substrings(s):\n    count_dict = defaultdict(int)\n\n    for i in range(1, len(s) + 1):\n        for j in range(len(s) - i + 1):\n            substring = s[j:j+i]\n            if sum(int(digit) for digit in substring) == i:\n                count_dict[i] += 1\n\n    return sum(count_dict.values())\n",
    "MbppEval/14": "def find_Volume(l, b, h):\n    volume = (1/2) * b * h * l\n    return volume\n",
    "MbppEval/75": "def find_tuples(test_list, K):\n    result = []\n    for tup in test_list:\n        if all(x % K == 0 for x in tup):\n            result.append(tup)\n    return str(result)\n",
    "MbppEval/65": "def _recursive_list_sum(data):\n    total = 0\n    for element in data:\n        if isinstance(element, list):\n            total += _recursive_list_sum(element)\n        else:\n            total += element\n    return total\n\ndef recursive_list_sum(data_list):\n    return _recursive_list_sum(data_list)\n",
    "MbppEval/7": "import re\n\ndef find_char_long(text):\n    words = re.findall(r'\\b\\w{4,}\\b', text)\n    return words\n",
    "MbppEval/94": "from operator import itemgetter\n\ndef index_minimum(test_list):\n    sorted_list = sorted(test_list, key=itemgetter(1))\n    return sorted_list[0][0]\n",
    "MbppEval/95": "def Find_Min_Length(lst):\n    min_length = float('inf')\n    for inner_list in lst:\n        length = len(inner_list)\n        if length < min_length:\n            min_length = length\n    return min_length\n",
    "MbppEval/84": "def sequence(n):\n    if n <= 2:\n        return 1\n    else:\n        return len(set(str(sequence(n-1))))\n",
    "MbppEval/77": "def is_Diff(n):\n    \"\"\"\n    Write a python function to find whether a number is divisible by 11.\n\n    Examples:\n    is_Diff(12345) == False\n    is_Diff(1212112) == True\n    is_Diff(1212) == False\n    \"\"\"\n    num_str = str(n)\n    odd_sum = 0\n    even_sum = 0\n    for i, digit in enumerate(num_str):\n        if i % 2 == 0:\n            even_sum += int(digit)\n        else:\n            odd_sum += int(digit)\n    diff = abs(odd_sum - even_sum)\n    return diff % 11 == 0\n",
    "MbppEval/62": "def smallest_num(xs):\n    \"\"\"\n    Write a python function to find the smallest number in a list.\n\n    Examples:\n    smallest_num([10, 20, 1, 45, 99]) == 1\n    smallest_num([1, 2, 3]) == 1\n    smallest_num([45, 46, 50, 60]) == 45\n    \"\"\"\n    smallest = xs[0]\n    for num in xs[1:]:\n        if num < smallest:\n            smallest = num\n    return smallest\n",
    "MbppEval/17": "def square_perimeter(a):\n    return 4 * a\n",
    "MbppEval/109": "def odd_Equivalent(s, n):\n    count = 0\n    for _ in range(n):\n        s = s[1:] + s[0]\n        num = int(s, 2)\n        if num % 2 == 1:\n            count += 1\n    return count\n",
    "MbppEval/6": "def differ_At_One_Bit_Pos(x, y):\n    xor_result = x ^ y\n    if bin(xor_result).count('1') == 1:\n        return True\n    else:\n        return False\n",
    "MbppEval/71": "def comb_sort(nums):\n    n = len(nums)\n    gap = n\n    swaps = True\n\n    while gap > 1 or swaps:\n        gap = max(1, int(gap / 1.25))\n        swaps = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swaps = True\n\n    return nums\n",
    "MbppEval/57": "def find_Max_Num(arr, n):\n    arr.sort(reverse=True)\n    largest_num = ''.join(map(str, arr))\n    return int(largest_num)\n",
    "MbppEval/91": "def find_substring(str1, sub_str):\n    for s in str1:\n        if sub_str in s:\n            return True\n    return False\n",
    "MbppEval/99": "def decimal_to_binary(n):\n    binary_str = \"\"\n    \n    while n > 0:\n        remainder = n % 2\n        binary_str = str(remainder) + binary_str\n        n //= 2\n    \n    if not binary_str:\n        return '0'\n    \n    return binary_str\n",
    "MbppEval/90": "def len_log(list1):\n    max_length = 0\n    for word in list1:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length\n",
    "MbppEval/96": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count\n",
    "MbppEval/93": "def power(a, b):\n    if b == 0:\n        return 1\n    \n    result = 1\n    for _ in range(b):\n        result *= a\n    \n    return result\n",
    "MbppEval/111": "def common_in_nested_lists(nestedlist):\n    if not nestedlist:\n        return []\n\n    common_elements = set(nestedlist[0])  # Initialize with the first list\n\n    for lst in nestedlist[1:]:\n        common_elements = common_elements.intersection(set(lst))\n\n    return list(common_elements)\n",
    "MbppEval/124": "import cmath\n\ndef angle_complex(a, b):\n    return cmath.phase(complex(a, b))\n",
    "MbppEval/98": "def multiply_num(numbers):\n    product = 1\n    length = len(numbers)\n    \n    for num in numbers:\n        product *= num\n    \n    return product / length\n",
    "MbppEval/115": "def empty_dit(list1):\n    all_empty = True\n    for element in list1:\n        if isinstance(element, dict):\n            if element:\n                all_empty = False\n                break\n    return all_empty\n",
    "MbppEval/97": "def frequency_lists(list1):\n    \"\"\"\n    Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n    \"\"\"\n    freq_dict = {}\n    \n    for inner_list in list1:\n        for element in inner_list:\n            if element in freq_dict:\n                freq_dict[element] += 1\n            else:\n                freq_dict[element] = 1\n    \n    return freq_dict\n",
    "MbppEval/105": "def count(lst):\n    true_count = 0\n    for element in lst:\n        if element:\n            true_count += 1\n    return true_count\n",
    "MbppEval/87": "import collections as ct\n\ndef merge_dictionaries_three(dict1, dict2, dict3):\n    result = {}\n    \n    for key, value in dict1.items():\n        result[key] = value\n    \n    for key, value in dict2.items():\n        result[key] = value\n    \n    for key, value in dict3.items():\n        result[key] = value\n    \n    return result\n",
    "MbppEval/120": "def max_product_tuple(list1):\n    max_product = 0\n    \n    for tup in list1:\n        product = abs(tup[0] * tup[1])\n        if product > max_product:\n            max_product = product\n    \n    return max_product\n",
    "MbppEval/123": "def amicable_numbers_sum(limit):\n    amicable_numbers = []\n\n    for n in range(1, limit + 1):\n        divisor_sum = sum(i for i in range(1, n) if n % i == 0)\n        if sum(i for i in range(1, divisor_sum) if divisor_sum % i == 0) == n and n != divisor_sum:\n            amicable_numbers.append(n)\n\n    return sum(amicable_numbers)\n",
    "MbppEval/2": "def similar_elements(test_tup1, test_tup2):\n    common_elements = []\n    \n    for element in test_tup1:\n        if element in test_tup2:\n            common_elements.append(element)\n    \n    return tuple(common_elements)\n",
    "MbppEval/89": "def closest_num(N):\n    if N < 0:\n        return N - 1\n    \n    N_str = str(N)\n    last_digit = int(N_str[-1])\n    \n    if last_digit == 0:\n        return N - 1\n    else:\n        new_last_digit = last_digit - 1\n        new_N_str = N_str[:-1] + str(new_last_digit)\n        return int(new_N_str)\n",
    "MbppEval/102": "def snake_to_camel(word):\n    words = word.split('_')\n    first_word = words[0].capitalize()\n    other_words = [w.capitalize() for w in words[1:]]\n    camel_case = first_word + ''.join(other_words)\n    return camel_case\n",
    "MbppEval/106": "def add_lists(test_list, test_tup):\n    return test_tup + tuple(test_list)\n",
    "MbppEval/103": "def eulerian_num(n, m):\n    if n == 0:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n-1, m-1) + (m + 1) * eulerian_num(n-1, m)\n",
    "MbppEval/132": "def tup_string(tup1):\n    result = ''.join(tup1)\n    return result\n",
    "MbppEval/92": "def is_undulating(n):\n    if not isinstance(n, str):\n        n = str(n)\n    if not n:\n        return False\n    for i in range(len(n) - 1):\n        if n[i] == n[i+1]:\n            return False\n    return True\n",
    "MbppEval/11": "def remove_Occ(s, ch):\n    if not s:\n        return s\n\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n\n    if first_index == last_index:\n        return s.replace(ch, \"\", 1)\n    else:\n        return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n",
    "MbppEval/100": "def next_smallest_palindrome(num):\n    \"\"\"\n    Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\n    Examples:\n    next_smallest_palindrome(99) == 101\n    next_smallest_palindrome(1221) == 1331\n    next_smallest_palindrome(120) == 121\n    \"\"\"\n    # Convert the input number to a string\n    num_str = str(num)\n\n    # Determine the length of the number\n    length = len(num_str)\n\n    # If the length is odd, find the middle digit and increment it by 1 if it's not 9\n    if length % 2 == 1:\n        middle = length // 2\n        if num_str[middle] != '9':\n            num_str = num_str[:middle] + str(int(num_str[middle]) + 1) + num_str[middle+1:]\n        else:\n            num_str = num_str[:middle] + '0' + num_str[middle+1:]\n    # If the length is even, find the middle two digits and increment the right digit by 1 if it's not 9\n    else:\n        middle = length // 2 - 1\n        if num_str[middle+1] != '9':\n            num_str = num_str[:middle+1] + str(int(num_str[middle+1]) + 1) + num_str[middle+2:]\n        else:\n            num_str = num_str[:middle+1] + '0' + num_str[middle+2:]\n\n    # Construct the new number by mirroring the left half to the right half\n    left_half = num_str[:length//2]\n    if length % 2 == 1:\n        return int(num_str[:middle+1] + left_half[::-1])\n    else:\n        return int(left_half + left_half[::-1])\n",
    "MbppEval/130": "from collections import defaultdict\n\ndef max_occurrences(nums):\n    count_dict = defaultdict(int)\n    for num in nums:\n        count_dict[num] += 1\n    max_count = 0\n    max_element = None\n    for element, freq in count_dict.items():\n        if freq > max_count:\n            max_count = freq\n            max_element = element\n    return (max_element, max_count)\n",
    "MbppEval/127": "def multiply_int(x, y):\n    '''\n    Write a function to multiply two integers.\n\n    Examples:\n    multiply_int(10,20) == 200\n    multiply_int(5,10) == 50\n    multiply_int(4,8) == 32\n    '''\n    return x * y\n",
    "MbppEval/126": "def sum_common_divisors(a, b):\n    \"\"\"\n    Write a python function to find the sum of common divisors of two given numbers.\n\n    Examples:\n    sum_common_divisors(10, 15) == 6\n    sum_common_divisors(100, 150) == 93\n    sum_common_divisors(4, 6) == 3\n    \"\"\"\n    common_divisors = set()\n    for i in range(1, min(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors.add(i)\n    return sum(common_divisors)\n",
    "MbppEval/131": "def reverse_vowels(str1):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    char_list = list(str1)\n    vowel_list = [char for char in char_list if char.lower() in vowels]\n    vowel_list.reverse()\n    \n    result = []\n    vowel_index = 0\n    for char in char_list:\n        if char.lower() in vowels:\n            result.append(vowel_list[vowel_index])\n            vowel_index += 1\n        else:\n            result.append(char)\n    \n    return ''.join(result)\n",
    "MbppEval/117": "def list_to_float(test_list):\n    result = []\n    for inner_list in test_list:\n        try:\n            first_float = float(inner_list[0])\n        except ValueError:\n            first_float = inner_list[0]\n        try:\n            second_float = float(inner_list[1])\n        except ValueError:\n            second_float = inner_list[1]\n        result.append((first_float, second_float))\n    return str(result)\n",
    "MbppEval/119": "def search(arr):\n    low = 0\n    high = len(arr) - 1\n    \n    while low < high:\n        mid = (low + high) // 2\n        if (mid % 2 == 0 and arr[mid] == arr[mid+1]) or \\\n           (mid % 2 == 1 and arr[mid] == arr[mid-1]):\n            low = mid + 1\n        else:\n            high = mid\n    \n    return arr[low]\n",
    "MbppEval/143": "def find_lists(Input):\n    count = 0\n    for element in Input:\n        if isinstance(element, list):\n            count += 1\n    return count\n",
    "MbppEval/116": "def tuple_to_int(nums):\n    result = 0\n    for i, num in enumerate(nums):\n        result = result * 10 + num\n    return result\n",
    "MbppEval/139": "import math\n\ndef circle_circumference(r):\n    \"\"\"\n    Write a function to find the circumference of a circle.\n\n    Examples:\n    circle_circumference(10) == 62.83185307179586\n    circle_circumference(5) == 31.41592653589793\n    circle_circumference(4) == 25.132741228718345\n    \"\"\"\n    circumference = 2 * math.pi * r\n    return circumference\n",
    "MbppEval/165": "def count_char_position(str1):\n    count = 0\n    for i, char in enumerate(str1.lower()):\n        if i == ord(char) - ord('a'):\n            count += 1\n    return count\n",
    "MbppEval/133": "def sum_negativenum(nums):\n    negative_sum = 0\n    for num in nums:\n        if num < 0:\n            negative_sum += num\n    return negative_sum\n",
    "MbppEval/162": "def sum_series(n):\n    total = 0\n    for i in range(n // 2 + 1):\n        total += n - 2 * i\n    return total\n",
    "MbppEval/168": "def frequency(a, x):\n    count = 0\n    for element in a:\n        if element == x:\n            count += 1\n    return count\n",
    "MbppEval/145": "def max_Abs_Diff(arr):\n    \"\"\"\n    Find the maximum difference between any two elements in a given array.\n\n    Args:\n        arr (list): The input array.\n\n    Returns:\n        int: The maximum absolute difference between any two elements in the array.\n    \"\"\"\n    max_val = max(arr)\n    min_val = min(arr)\n    return abs(max_val - min_val)\n",
    "MbppEval/171": "def perimeter_pentagon(a):\n    return 5 * a\n",
    "MbppEval/164": "import math\n\ndef div_sum(n):\n    divisor_sum = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            divisor_sum += i\n    return divisor_sum\n\ndef areEquivalent(a, b):\n    a_divisor_sum = div_sum(a)\n    b_divisor_sum = div_sum(b)\n    return a_divisor_sum == b_divisor_sum\n",
    "MbppEval/170": "def sum_range_list(list1, m, n):\n    total = 0\n    for i in range(m, n+1):\n        total += list1[i]\n    return total\n",
    "MbppEval/227": "def min_of_three(a, b, c):\n    return min(a, b, c)\n",
    "MbppEval/172": "def count_occurance(s):\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i:i+3] == 'std':\n            count += 1\n    return count\n",
    "MbppEval/226": "def odd_values_string(str):\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result += str[i]\n    return result\n",
    "MbppEval/163": "from math import tan, pi\n\ndef area_polygon(s, n):\n    area = (n * s**2) / (4 * tan(pi/n))\n    return round(area, 10)\n",
    "MbppEval/224": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n",
    "MbppEval/83": "def get_Char(strr):\n    \"\"\"\n    Write a python function to find the character made by adding the ASCII value of all the alphabetic characters of the given string modulo 26.\n\n    Examples:\n    get_Char(\"abc\") == \"f\"\n    get_Char(\"gfg\") == \"t\"\n    get_Char(\"ab\") == \"c\"\n    get_Char(\"a1b!c2\") == \"f\"\n    \"\"\"\n    total = 0\n    for char in strr:\n        if char.isalpha():\n            total += ord(char.lower())\n    return chr(total % 26 + 65)\n",
    "MbppEval/222": "def check_type(test_tuple):\n    \"\"\"\n    Write a function to check if all the elements in tuple have same data type or not.\n\n    Examples:\n    check_type((5, 6, 7, 3, 5, 6)) == True\n    check_type((1, 2, \"4\")) == False\n    check_type((3, 2, 1, 4, 5)) == True\n    \"\"\"\n    if len(test_tuple) == 0:\n        return True\n\n    data_type = type(test_tuple[0])\n\n    for element in test_tuple:\n        if type(element) != data_type:\n            return False\n\n    return True\n",
    "MbppEval/3": "import math\n\ndef is_not_prime(n):\n    '''\n    Write a python function to identify non-prime numbers.\n\n    Examples:\n    is_not_prime(2) == False\n    is_not_prime(10) == True\n    is_not_prime(35) == True\n    '''\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return True\n    return False\n",
    "MbppEval/234": "def volume_cube(l):\n    return l * l * l\n",
    "MbppEval/128": "def long_words(n, string):\n    words = string.split()\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list\n",
    "MbppEval/229": "def re_arrange_array(arr, n):\n    i = 0\n    j = 0\n    \n    for i in range(n):\n        if arr[i] < 0:\n            arr[i], arr[j] = arr[j], arr[i]\n            j += 1\n    \n    return arr\n",
    "MbppEval/166": "def find_even_pair(A):\n    even_xor_dict = {}\n    count = 0\n    for a in A:\n        if (a ^ 2) in even_xor_dict:\n            count += even_xor_dict[a ^ 2]\n        even_xor_dict[a] = even_xor_dict.get(a, 0) + 1\n    return count\n",
    "MbppEval/140": "def extract_singly(test_list):\n    result = []\n    for inner_list in test_list:\n        result.extend(inner_list)\n    return set(result)\n",
    "MbppEval/113": "def check_integer(text):\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n",
    "MbppEval/141": "def pancake_sort(nums):\n    n = len(nums)\n    for i in range(n, 0, -1):\n        max_index = 0\n        for j in range(1, i):\n            if nums[j] > nums[max_index]:\n                max_index = j\n        \n        # Reverse the subarray from the beginning to the maximum element\n        nums[:max_index+1] = reversed(nums[:max_index+1])\n        \n        # Reverse the subarray from the beginning to the current index\n        nums[:i] = reversed(nums[:i])\n    \n    return nums\n",
    "MbppEval/125": "def find_length(string, n):\n    max_diff = 0\n\n    for i in range(n):\n        num_0 = 0\n        num_1 = 0\n        for j in range(i, n):\n            if string[j] == '0':\n                num_0 += 1\n            else:\n                num_1 += 1\n            curr_diff = abs(num_0 - num_1)\n            max_diff = max(max_diff, curr_diff)\n\n    return max_diff\n",
    "MbppEval/232": "import heapq\n\ndef larg_nnum(list1, n):\n    heapq.heapify(list1)\n    return heapq.nlargest(n, list1)\n",
    "MbppEval/248": "def harmonic_sum(n):\n    if n == 1:\n        return 0\n    \n    harmonic_sum_n_1 = 0\n    for i in range(1, n):\n        harmonic_sum_n_1 += 1 / i\n    \n    return harmonic_sum_n_1\n",
    "MbppEval/167": "def next_power_of_2(n):\n    if n == 0:\n        return 1\n    else:\n        return 2 ** (n - 1).bit_length()\n",
    "MbppEval/246": "def babylonian_squareroot(number):\n    \"\"\"\n    Write a function for computing square roots using the babylonian method.\n\n    Examples:\n    babylonian_squareroot(10) == 3.162277660168379\n    babylonian_squareroot(2) == 1.414213562373095\n    babylonian_squareroot(9) == 3.0\n    \"\"\"\n    guess = number\n    tolerance = 1e-10\n\n    while abs(guess - number/guess) > tolerance:\n        guess = (guess + number/guess) / 2\n\n    return guess\n",
    "MbppEval/160": "def find_solution(a, b, n):\n    for x in range(n // a + 1):\n        y = (n - a * x) / b\n        if y.is_integer() and y >= 0:\n            return ('x = ', x, ', y = ', int(y))\n    return \"No solution\"\n",
    "MbppEval/249": "def intersection_array(array_nums1, array_nums2):\n    common_elements = []\n    for num in array_nums1:\n        if num in array_nums2:\n            common_elements.append(num)\n    return common_elements\n",
    "MbppEval/245": "def max_sum(arr):\n    n = len(arr)\n    \n    lis = [1] * n\n    lds = [1] * n\n    \n    for i in range(1, n):\n        if arr[i] > arr[i-1]:\n            lis[i] = lis[i-1] + 1\n    \n    for i in range(n-2, -1, -1):\n        if arr[i] > arr[i+1]:\n            lds[i] = lds[i+1] + 1\n    \n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, lis[i] + lds[i] - 1)\n    \n    return max_sum\n",
    "MbppEval/88": "import collections\n\ndef freq_count(list1):\n    return dict(collections.Counter(list1))\n",
    "MbppEval/230": "def replace_blank(str1, char):\n    result = \"\"\n    for c in str1:\n        if c == \" \":\n            result += char\n        else:\n            result += c\n    return result\n",
    "MbppEval/239": "def get_total_number_of_sequences(m, n):\n    if n == 1:\n        return m\n    if m < 2:\n        return 0\n    \n    total = 0\n    for first_element in range(2, m+1):\n        total += get_total_number_of_sequences(min(m, first_element * 2), n-1)\n    \n    return total\n",
    "MbppEval/242": "def count_charac(str1):\n    return len(str1)\n",
    "MbppEval/252": "import cmath\n\ndef convert(num):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n\n    Args:\n        num (complex): The complex number to be converted.\n\n    Returns:\n        tuple: A tuple containing the magnitude and angle of the complex number.\n    \"\"\"\n    magnitude = abs(num)\n    angle = cmath.phase(num)\n    return (magnitude, angle)\n",
    "MbppEval/101": "def kth_element(arr, k):\n    \"\"\"\n    Write a function to find the kth element in the given array using 1-based indexing.\n\n    Examples:\n    kth_element([12,3,5,7,19], 5, 2) == 3\n    kth_element([17,24,8,23], 4, 3) == 8\n    kth_element([16,21,25,36,4], 5, 4) == 36\n    \"\"\"\n    if not arr or k < 1 or k > len(arr):\n        return None\n\n    return _quickselect(arr, 0, len(arr) - 1, k - 1)\n\n\ndef _quickselect(arr, left, right, k):\n    \"\"\"\n    Helper function to find the kth smallest element using the quick-select algorithm.\n    \"\"\"\n    pivot = arr[right]\n    i = left\n\n    for j in range(left, right):\n        if arr[j] < pivot:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n\n    arr[i], arr[right] = arr[right], arr[i]\n\n    if i == k:\n        return arr[i]\n    elif i > k:\n        return _quickselect(arr, left, i - 1, k)\n    else:\n        return _quickselect(arr, i + 1, right, k)\n",
    "MbppEval/233": "import math\n\ndef lateralsuface_cylinder(r, h):\n    \"\"\"\n    Write a function to find the lateral surface area of a cylinder.\n\n    Examples:\n    lateralsuface_cylinder(10, 5) == 314.1592653589793\n    lateralsuface_cylinder(4, 5) == 125.66370614359172\n    lateralsuface_cylinder(4, 10) == 251.32741228718345\n    \"\"\"\n    lateral_surface_area = 2 * math.pi * r * h\n    return lateral_surface_area\n",
    "MbppEval/253": "def count_integer(list1):\n    count = 0\n    for element in list1:\n        if isinstance(element, int):\n            count += 1\n    return count\n",
    "MbppEval/228": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    mask = (1 << (r - l + 1)) - 1\n    mask <<= l\n    return (n & mask) == mask\n",
    "MbppEval/257": "def swap_numbers(a, b):\n    return (b, a)\n",
    "MbppEval/251": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result\n",
    "MbppEval/259": "def maximize_elements(test_tup1, test_tup2):\n    maximized_tuples = []\n    for t1, t2 in zip(test_tup1, test_tup2):\n        maximized_tuples.append((max(t1[0], t2[0]), max(t1[1], t2[1])))\n    return tuple(maximized_tuples)\n",
    "MbppEval/247": "def lps(str):\n    n = len(str)\n    dp = [[0] * n for _ in range(n)]\n\n    # Base case: for substrings of length 1, the length of the longest palindromic subsequence is 1\n    for i in range(n):\n        dp[i][i] = 1\n\n    # For substrings of length 2, if the characters are the same, the length is 2, else it is 1\n    for i in range(n-1):\n        if str[i] == str[i+1]:\n            dp[i][i+1] = 2\n        else:\n            dp[i][i+1] = 1\n\n    # For substrings of length greater than 2\n    for length in range(3, n+1):\n        for i in range(n-length+1):\n            j = i + length - 1\n            if str[i] == str[j]:\n                dp[i][j] = 2 + dp[i+1][j-1]\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n\n    return dp[0][n-1]\n",
    "MbppEval/237": "from collections import Counter\n\ndef check_occurences(test_list):\n    tuple_count = {}\n\n    for tup in test_list:\n        if tup in tuple_count:\n            tuple_count[tup] += 1\n        else:\n            tuple_count[tup] = 1\n\n    return tuple_count\n",
    "MbppEval/255": "from itertools import combinations_with_replacement\n\ndef combinations_colors(l, n):\n    return list(map(tuple, combinations_with_replacement(l, n)))\n",
    "MbppEval/262": "def split_two_parts(list1, L):\n    first_part = list1[:L]\n    second_part = list1[L:]\n    return (first_part, second_part)\n",
    "MbppEval/118": "def string_to_list(string):\n    return string.split()\n",
    "MbppEval/240": "def replace_list(list1, list2):\n    len_list1 = len(list1)\n    list1[-1] = list2\n    return list1\n",
    "MbppEval/267": "def square_Sum(n):\n    total = 0\n    for i in range(1, n+1):\n        total += (2 * i - 1) ** 2\n    return total\n",
    "MbppEval/269": "def ascii_value(k):\n    return ord(k)\n",
    "MbppEval/266": "def lateralsurface_cube(side_length):\n    \"\"\"\n    Calculates the lateral surface area of a cube given its side length.\n\n    Args:\n        side_length (float): The length of one side of the cube.\n\n    Returns:\n        float: The lateral surface area of the cube.\n    \"\"\"\n    return 4 * side_length * side_length\n",
    "MbppEval/260": "def newman_prime(n):\n    \"\"\"\n    Finds the nth Newman-Shanks-Williams prime number.\n    \"\"\"\n    if n == 1:\n        return 2\n    \n    newman_primes = [2]\n    p = 3\n    while len(newman_primes) < n:\n        if is_prime(p) and is_prime(2 ** p - 1):\n            newman_primes.append(2 ** p - 1)\n        p += 2\n    \n    return newman_primes[n - 1]\n\ndef is_prime(n):\n    \"\"\"\n    Checks if a number is prime.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n",
    "MbppEval/264": "def dog_age(h_age):\n    \"\"\"\n    Write a function to calculate a dog's age in dog's years.\n\n    Examples:\n    dog_age(12) == 61\n    dog_age(15) == 73\n    dog_age(24) == 109\n    \"\"\"\n    if h_age <= 2:\n        return h_age * 10.5\n    else:\n        return 21 + (h_age - 2) * 4\n",
    "MbppEval/268": "def find_star_num(n):\n    \"\"\"\n    Write a function to find the n'th star number.\n\n    Examples:\n    find_star_num(3) == 37\n    find_star_num(4) == 73\n    find_star_num(5) == 121\n    \"\"\"\n    result = 0\n    for i in range(1, n+1):\n        result += (i * (i + 1)) // 2\n    return result\n",
    "MbppEval/271": "def even_Power_Sum(n):\n    total_sum = 0\n    for i in range(1, n+1):\n        total_sum += (2 * i) ** 5\n    return total_sum\n",
    "MbppEval/272": "def rear_extract(test_list):\n    result = [tup[-1] for tup in test_list]\n    return result\n",
    "MbppEval/261": "def division_elements(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length.\")\n    \n    result = []\n    for i in range(len(test_tup1)):\n        try:\n            result.append(test_tup1[i] / test_tup2[i])\n        except ZeroDivisionError:\n            result.append(0)\n    \n    return tuple(result)\n",
    "MbppEval/278": "def count_first_elements(test_tup):\n    for i, element in enumerate(test_tup):\n        if isinstance(element, tuple):\n            return i\n    return 0\n",
    "MbppEval/273": "def subtract_elements(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        return \"Error: Input tuples must have the same length.\"\n    \n    result = []\n    for i in range(len(test_tup1)):\n        result.append(test_tup1[i] - test_tup2[i])\n    \n    return tuple(result)\n",
    "MbppEval/277": "def dict_filter(dict_in, n):\n    new_dict = {}\n    for key, value in dict_in.items():\n        if value >= n:\n            new_dict[key] = value\n    return new_dict\n",
    "MbppEval/256": "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n\n    Examples:\n    count_Primes_nums(5) == 2\n    count_Primes_nums(10) == 4\n    count_Primes_nums(100) == 25\n    \"\"\"\n    if n < 2:\n        return 0\n\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n\n    return sum(is_prime)\n",
    "MbppEval/274": "import math\n\ndef even_binomial_Coeff_Sum(n):\n    sum_even = 0\n    for i in range(0, n+1, 2):\n        sum_even += math.comb(n, i)\n    return sum_even\n",
    "MbppEval/286": "def max_sub_array_sum_repeated(a, n, k):\n    max_sum = float('-inf')\n    total_sum = sum(a)\n    \n    # Compute the maximum sum of a contiguous subarray in the original array\n    curr_sum = 0\n    for num in a:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    repeated_sum = 0\n    for i in range(k-1):\n        repeated_sum += total_sum\n        max_sum = max(max_sum, repeated_sum)\n    \n    return max_sum\n",
    "MbppEval/270": "def sum_even_and_even_index(arr):\n    sum = 0\n    for i, num in enumerate(arr):\n        if num % 2 == 0 and i % 2 == 0:\n            sum += num\n    return sum\n",
    "MbppEval/280": "def sequential_search(dlist, item):\n    found = False\n    index = -1\n    \n    for i, element in enumerate(dlist):\n        if element == item:\n            found = True\n            index = i\n            break\n    \n    return (found, index)\n",
    "MbppEval/279": "def is_num_decagonal(n):\n    return n * (3 * n - 2)\n",
    "MbppEval/79": "def word_len(s):\n    return len(s) % 2 == 1\n",
    "MbppEval/287": "def square_Sum(n):\n    return n * (2 * n + 1) * (2 * n - 1) // 3\n",
    "MbppEval/282": "def sub_list(nums1, nums2):\n    if len(nums1) != len(nums2):\n        return []\n\n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] - nums2[i])\n\n    return result\n",
    "MbppEval/276": "import math\n\ndef volume_cylinder(r, h):\n    volume = math.pi * r**2 * h\n    return volume\n",
    "MbppEval/294": "def max_val(listval):\n    max_value = float('-inf')\n    \n    for element in listval:\n        if isinstance(element, (int, float)):\n            max_value = max(max_value, element)\n    \n    return max_value\n",
    "MbppEval/265": "def list_split(S, step):\n    result = [[] for _ in range(step)]\n    for i, item in enumerate(S):\n        result[i % step].append(item)\n    return result\n",
    "MbppEval/300": "def count_binary_seq(n):\n    \"\"\"\n    Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.\n\n    Examples:\n    count_binary_seq(1) == 2.0\n    count_binary_seq(2) == 6.0\n    count_binary_seq(3) == 20.0\n    \"\"\"\n    if n == 1:\n        return 2.0\n\n    count = 0\n    for i in range(2 ** (2 * n)):\n        binary_seq = format(i, f\"0{2 * n}b\")\n        first_half = int(binary_seq[:n], 2)\n        second_half = int(binary_seq[n:], 2)\n        if first_half == second_half:\n            count += 1\n\n    return count\n",
    "MbppEval/292": "def find(n, m):\n    return n // m\n",
    "MbppEval/295": "def sum_div(number):\n    divisors = []\n    for i in range(1, number + 1):\n        if number % i == 0:\n            divisors.append(i)\n    return sum(divisors)\n",
    "MbppEval/223": "def is_majority(arr, n, x):\n    # Find the first occurrence of x\n    left = 0\n    right = n - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == x:\n            if mid == 0 or arr[mid-1] != x:\n                break\n            right = mid - 1\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    # If x is not present in the array, return False\n    if left > right:\n        return False\n    \n    # Find the last occurrence of x\n    start = mid\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == x:\n            if mid == n-1 or arr[mid+1] != x:\n                break\n            left = mid + 1\n        elif arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    # Calculate the number of occurrences of x\n    count = mid - start + 1\n    \n    # Check if count is greater than n//2\n    return count > n // 2\n",
    "MbppEval/283": "def validate(n):\n    str_n = str(n)\n    digit_count = {}\n\n    for digit in str_n:\n        digit_count[digit] = digit_count.get(digit, 0) + 1\n\n    for digit, count in digit_count.items():\n        if count > int(digit):\n            return False\n\n    return True\n",
    "MbppEval/250": "def count_X(tup, x):\n    count = 0\n    for element in tup:\n        if element == x:\n            count += 1\n    return count\n",
    "MbppEval/296": "def get_Inv_Count(arr):\n    return merge_sort(arr, 0, len(arr) - 1)\n\ndef merge_sort(arr, left, right):\n    if left < right:\n        mid = (left + right) // 2\n        left_count = merge_sort(arr, left, mid)\n        right_count = merge_sort(arr, mid + 1, right)\n        return left_count + right_count + merge(arr, left, mid, right)\n    return 0\n\ndef merge(arr, left, mid, right):\n    i = left\n    j = mid + 1\n    count = 0\n    temp = [0] * (right - left + 1)\n    k = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp[k] = arr[i]\n            i += 1\n        else:\n            temp[k] = arr[j]\n            count += mid - i + 1\n            j += 1\n        k += 1\n\n    while i <= mid:\n        temp[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp[i - left]\n\n    return count\n",
    "MbppEval/310": "def string_to_tuple(str1):\n    return tuple(str1)\n",
    "MbppEval/309": "def maximum(a, b):\n    \"\"\"\n    Write a python function to find the maximum of two numbers.\n\n    Examples:\n    maximum(5, 10) == 10\n    maximum(-1, -2) == -1\n    maximum(9, 7) == 9\n    \"\"\"\n    if a >= b:\n        return a\n    else:\n        return b\n",
    "MbppEval/306": "def max_sum_increasing_subseq(a, n, index, k):\n    dp = [0] * n\n    max_sum = 0\n\n    # Base case\n    if index == 0:\n        return a[0]\n\n    # Iterate through the array\n    for i in range(n):\n        # Find the maximum sum of increasing subsequence up to index i\n        for j in range(i):\n            if a[j] < a[i]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n\n        # Update the max_sum if i is less than k\n        if i < k:\n            max_sum = max(max_sum, dp[i])\n\n    return max_sum\n",
    "MbppEval/293": "import math\n\ndef otherside_rightangle(w, h):\n    return math.sqrt(w**2 + h**2)\n",
    "MbppEval/312": "import math\n\ndef volume_cone(r, h):\n    \"\"\"\n    Write a function to find the volume of a cone.\n\n    Examples:\n    volume_cone(5, 12) == 314.1592653589793\n    volume_cone(10, 15) == 1570.7963267948966\n    volume_cone(19, 17) == 6426.651371693521\n    \"\"\"\n    return (1/3) * math.pi * r**2 * h\n",
    "MbppEval/308": "def large_product(nums1, nums2, N):\n    products = [num1 * num2 for num1 in nums1 for num2 in nums2]\n    products.sort(reverse=True)\n    return products[:N]\n",
    "MbppEval/389": "def find_lucas(n):\n    \"\"\"\n    Write a function to find the n'th lucas number.\n\n    Examples:\n    find_lucas(9) == 76\n    find_lucas(4) == 7\n    find_lucas(3) == 4\n    \"\"\"\n    if n == 1:\n        return 2\n    elif n == 2:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(3, n+1):\n            a, b = b, a + b\n        return b\n",
    "MbppEval/390": "def add_string(list_, string):\n    formatted_strings = []\n    for item in list_:\n        formatted_strings.append(string.format(item))\n    return formatted_strings\n",
    "MbppEval/305": "import re\n\ndef start_withp(words):\n    p_words = [word for word in words if re.match(r'^p', word, re.IGNORECASE)]\n    return tuple(p_words[:2])\n",
    "MbppEval/304": "def find_Element(arr, ranges, rotations, index):\n    for start, end in ranges:\n        arr = rotate_array(arr[start:end+1], rotations) + arr[:start] + arr[end+1:]\n    return arr[index]\n\ndef rotate_array(arr, k):\n    return arr[-k:] + arr[:-k]\n",
    "MbppEval/391": "def convert_list_dictionary(l1, l2, l3):\n    result = []\n    for item1, item2, item3 in zip(l1, l2, l3):\n        nested_dict = {item1: {item2: item3}}\n        result.append(nested_dict)\n    return result\n",
    "MbppEval/307": "def colon_tuplex(tuplex, n):\n    return tuplex[:2] + ([n],) + tuplex[3:]\n",
    "MbppEval/297": "def flatten_list(list1):\n    flattened = []\n    \n    for item in list1:\n        if isinstance(item, list):\n            flattened.extend(flatten_list(item))\n        else:\n            flattened.append(item)\n    \n    return flattened\n",
    "MbppEval/291": "def count_no_of_ways(n, k):\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n    \n    same = k\n    diff = k * (k-1)\n    total = same + diff\n    \n    for i in range(3, n+1):\n        same, diff = diff, (same + diff) * (k-1)\n        total = same + diff\n    \n    return total\n",
    "MbppEval/396": "import re\n\nregex = r'^[a-z]$|^([a-z]).*\\1$'\n\ndef check_char(string):\n    if re.match(regex, string):\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n",
    "MbppEval/301": "def dict_depth(d):\n    \"\"\"\n    Write a function to find the depth of a dictionary.\n\n    Examples:\n    dict_depth({'a':1, 'b': {'c': {'d': {}}}}) == 4\n    dict_depth({'a':1, 'b': {'c':'python'}}) == 2\n    dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}}) == 3\n    \"\"\"\n    if not d:\n        return 0\n    return 1 + (max(map(dict_depth, d.values())) if any(isinstance(v, dict) for v in d.values()) else 0)\n",
    "MbppEval/397": "def median_numbers(a, b, c):\n    numbers = [a, b, c]\n    sorted_numbers = sorted(numbers)\n    median = sorted_numbers[1]\n    return float(median)\n",
    "MbppEval/395": "def first_non_repeating_character(str1):\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    return None\n",
    "MbppEval/284": "def check_element(lst, element):\n    all_equal = True\n    for item in lst:\n        if item != element:\n            all_equal = False\n            break\n    return all_equal\n",
    "MbppEval/404": "def minimum(a, b):\n    \"\"\"\n    Write a python function to find the minimum of two numbers.\n\n    Examples:\n    minimum(1, 2) == 1\n    minimum(-5, -4) == -5\n    minimum(0, 0) == 0\n    \"\"\"\n    if a <= b:\n        return a\n    else:\n        return b\n",
    "MbppEval/392": "def get_max_sum(n):\n    return f(n)\n\ndef f(n):\n    if n <= 1:\n        return n\n    \n    return max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n",
    "MbppEval/388": "def highest_Power_of_2(n):\n    power_of_2 = 1\n    while power_of_2 <= n:\n        power_of_2 <<= 1\n    return power_of_2 >> 1\n",
    "MbppEval/137": "def zero_count(nums):\n    zero_count = nums.count(0)\n    total_count = len(nums)\n    return zero_count / total_count\n",
    "MbppEval/138": "def is_Sum_Of_Powers_Of_Two(n):\n    \"\"\"\n    Checks whether the given number can be represented as a sum of non-zero powers of 2.\n\n    Args:\n        n (int): The number to be checked.\n\n    Returns:\n        bool: True if the number can be represented as a sum of non-zero powers of 2, False otherwise.\n    \"\"\"\n    binary_repr = bin(n)[2:]  # Convert to binary and remove the '0b' prefix\n    \n    # Check if the binary representation has only non-zero digits\n    return all(int(digit) > 0 for digit in binary_repr)\n",
    "MbppEval/407": "def rearrange_bigger(n):\n    digits = list(str(n))\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i+1]:\n        i -= 1\n    if i < 0:\n        return False\n    j = len(digits) - 1\n    while j > i and digits[j] <= digits[i]:\n        j -= 1\n    digits[i], digits[j] = digits[j], digits[i]\n    digits[i+1:] = digits[i+1:][::-1]\n    return int(''.join(digits))\n",
    "MbppEval/415": "def max_Product(arr):\n    max_product = float('-inf')\n    max_pair = None\n    \n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n                max_pair = (arr[i], arr[j])\n    \n    return max_pair\n",
    "MbppEval/419": "def round_and_sum(list1):\n    rounded_numbers = [round(num) for num in list1]\n    total_sum = sum(rounded_numbers)\n    result = total_sum * len(list1)\n    return result\n",
    "MbppEval/311": "def set_left_most_unset_bit(n):\n    binary_str = bin(n)[2:]\n    leftmost_unset_bit_pos = 0\n    for i, bit in enumerate(binary_str):\n        if bit == '0':\n            leftmost_unset_bit_pos = len(binary_str) - i\n            break\n    result = n | (1 << (leftmost_unset_bit_pos - 1))\n    return result\n",
    "MbppEval/399": "def bitwise_xor(test_tup1, test_tup2):\n    result = tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n    return result\n",
    "MbppEval/412": "def remove_odd(l):\n    even_list = []\n    for num in l:\n        if num % 2 == 0:\n            even_list.append(num)\n    return even_list\n",
    "MbppEval/420": "def cube_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2 * i) ** 3\n    return sum\n",
    "MbppEval/410": "def min_val(listval):\n    \"\"\"\n    Write a function to find the minimum value in a given heterogeneous list.\n\n    Examples:\n    min_val(['Python', 3, 2, 4, 5, 'version']) == 2\n    min_val(['Python', 15, 20, 25]) == 15\n    min_val(['Python', 30, 20, 40, 50, 'version']) == 20\n    \"\"\"\n    min_value = float('inf')\n\n    for item in listval:\n        if isinstance(item, (int, float)):\n            min_value = min(min_value, item)\n\n    return min_value\n",
    "MbppEval/405": "def check_tuplex(tuplex, tuple1):\n    return tuple1 in tuplex\n",
    "MbppEval/424": "def extract_rear(test_tuple):\n    result = []\n    for item in test_tuple:\n        result.append(str(item)[-1])\n    return result\n",
    "MbppEval/406": "def find_Parity(x):\n    if x & 1 == 1:\n        return \"Odd Parity\"\n    else:\n        return \"Even Parity\"\n",
    "MbppEval/421": "def concatenate_tuple(test_tup):\n    result = \"-\".join(map(str, test_tup))\n    return result\n",
    "MbppEval/422": "def find_Average_Of_Cube(n):\n    sum_of_numbers = n * (n + 1) / 2\n    sum_of_cubes = n * (n + 1) * (2 * n + 1) / 6\n    return sum_of_cubes / sum_of_numbers\n",
    "MbppEval/285": "import re\n\ndef text_match_two_three(text):\n    pattern = r'ab{2,3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
    "MbppEval/408": "import heapq\n\ndef k_smallest_pairs(nums1, nums2, k):\n    result = []\n    heap = []\n\n    # Add the first pair to the min-heap\n    heapq.heappush(heap, (nums1[0] + nums2[0], 0, 0))\n\n    # Populate the result list\n    while len(result) < k and heap:\n        _, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n\n        if j < len(nums2) - 1:\n            heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))\n\n    return result\n",
    "MbppEval/417": "def group_tuples(input_list):\n    result = {}\n    for tup in input_list:\n        first_element = tup[0]\n        if first_element not in result:\n            result[first_element] = [tup]\n        else:\n            result[first_element].append(tup)\n    return [tuple(v) for v in result.values()]\n",
    "MbppEval/426": "def filter_oddnumbers(nums):\n    odd_numbers = []\n    for num in nums:\n        if num % 2 != 0:\n            odd_numbers.append(num)\n    return odd_numbers\n",
    "MbppEval/425": "def count_element_in_list(list1, x):\n    count = 0\n    for sub_list in list1:\n        if x in sub_list:\n            count += 1\n    return count\n",
    "MbppEval/142": "def count_samepair(list1, list2, list3):\n    count = 0\n    for a, b, c in zip(list1, list2, list3):\n        if a == b == c:\n            count += 1\n    return count\n",
    "MbppEval/411": "import re\n\ndef snake_to_camel(word):\n    result = \"\"\n    words = word.split(\"_\")\n    \n    # Convert the first word to start with uppercase\n    result += words[0].capitalize()\n    \n    # Convert the remaining words to start with uppercase\n    for w in words[1:]:\n        result += w.capitalize()\n    \n    return result\n",
    "MbppEval/427": "import re\n\ndef change_date_format(dt):\n    match = re.match(r'(\\d{4})-(\\d{2})-(\\d{2})', dt)\n    if match:\n        year, month, day = match.groups()\n        return f'{day}-{month}-{year}'\n    else:\n        return None\n",
    "MbppEval/418": "def Find_Max(lst):\n    max_length = 0\n    max_element = None\n\n    for element in lst:\n        if len(element) > max_length:\n            max_length = len(element)\n            max_element = element\n\n    return max_element\n",
    "MbppEval/432": "def median_trapezium(base1, base2, height):\n    median = (base1 + base2) / 2\n    return median\n",
    "MbppEval/430": "def parabola_directrix(a, b, c):\n    x_directrix = -b / (2 * a)\n    return x_directrix\n",
    "MbppEval/290": "def max_length(list1):\n    max_len = 0\n    max_list = []\n\n    for sub_list in list1:\n        if len(sub_list) > max_len:\n            max_len = len(sub_list)\n            max_list = sub_list\n\n    return (max_len, max_list)\n",
    "MbppEval/439": "def multiple_to_single(L):\n    result = ''\n    for num in L:\n        result += str(num)\n    return result\n",
    "MbppEval/428": "def shell_sort(my_list):\n    n = len(my_list)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j-gap] > temp:\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            my_list[j] = temp\n        gap //= 2\n    \n    return my_list\n",
    "MbppEval/440": "import re\n\ndef find_adverb_position(text):\n    match = re.search(r'\\w+ly', text)\n    if match:\n        start = match.start()\n        end = match.end()\n        adverb = match.group()\n        return (start, end, adverb)\n    else:\n        return None\n",
    "MbppEval/434": "import re\n\ndef text_match_one(text):\n    pattern = r'ab+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
    "MbppEval/441": "def surfacearea_cube(l):\n    return 6 * (l ** 2)\n",
    "MbppEval/444": "def trim_tuple(test_list, K):\n    return [tup[K:] for tup in test_list]\n",
    "MbppEval/443": "def largest_neg(list1):\n    largest_negative = float('-inf')\n    \n    for num in list1:\n        if num < 0 and num > largest_negative:\n            largest_negative = num\n    \n    if largest_negative == float('-inf'):\n        return None\n    else:\n        return largest_negative\n",
    "MbppEval/436": "def neg_nos(list1):\n    \"\"\"\n    Write a python function to return the negative numbers in a list.\n\n    Examples:\n    neg_nos([-1,4,5,-6]) == [-1,-6]\n    neg_nos([-1,-2,3,4]) == [-1,-2]\n    neg_nos([-7,-6,8,9]) == [-7,-6]\n    \"\"\"\n    return [num for num in list1 if num < 0]\n",
    "MbppEval/398": "def sum_of_digits(nums):\n    total_sum = 0\n    for num in nums:\n        if isinstance(num, (int, float)):\n            num = abs(int(num))\n            while num > 0:\n                total_sum += num % 10\n                num //= 10\n    return total_sum\n",
    "MbppEval/414": "def overlapping(list1, list2):\n    overlap = False\n    for item in list1:\n        if item in list2:\n            overlap = True\n            break\n    return overlap\n",
    "MbppEval/438": "def count_bidirectional(test_list):\n    count = 0\n    for tup in test_list:\n        reverse_tup = (tup[1], tup[0])\n        if reverse_tup in test_list:\n            count += 1\n    return str(count)\n",
    "MbppEval/451": "import re\n\ndef remove_whitespaces(text1):\n    return re.sub(r'\\s+', '', text1)\n",
    "MbppEval/435": "def last_Digit(n):\n    return n % 10\n",
    "MbppEval/437": "def remove_odd(str1):\n    result = \"\"\n    for i, char in enumerate(str1):\n        if i % 2 == 0:\n            result += char\n    return result\n",
    "MbppEval/448": "def cal_sum(n):\n    \"\"\"\n    Write a function to calculate the sum of Perrin numbers.\n\n    Examples:\n    cal_sum(9) == 49\n    cal_sum(10) == 66\n    cal_sum(11) == 88\n    \"\"\"\n    perrin_nums = [3, 0, 2]\n    if n <= 3:\n        return sum(perrin_nums[:n])\n    for i in range(3, n):\n        next_perrin = perrin_nums[-2] + perrin_nums[-3]\n        perrin_nums.append(next_perrin)\n    return sum(perrin_nums)\n",
    "MbppEval/446": "from collections import Counter\n\ndef count_Occurrence(tup, lst):\n    counter = Counter(tup)\n    count = 0\n    for element in lst:\n        if element in counter:\n            count += counter[element]\n    return count\n",
    "MbppEval/457": "def Find_Min(lst):\n    min_length = float('inf')\n    min_sublist = None\n\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n\n    return min_sublist\n",
    "MbppEval/56": "def rev(num):\n    \"\"\"\n    Write a python function to check if a given number is one less than twice its reverse.\n\n    Examples:\n    rev(70) == False\n    rev(23) == False\n    rev(73) == True\n    \"\"\"\n    reversed_num = int(str(num)[::-1])\n    return num == 2 * reversed_num - 1\n",
    "MbppEval/452": "def loss_amount(actual_cost, sale_amount):\n    \"\"\"\n    Write a function that gives loss amount on a sale if the given amount has loss else return 0.\n\n    Examples:\n    loss_amount(1500, 1200) == 300\n    loss_amount(100, 200) == 0\n    loss_amount(2000, 5000) == 0\n    \"\"\"\n    if sale_amount < actual_cost:\n        return actual_cost - sale_amount\n    else:\n        return 0\n",
    "MbppEval/244": "import math\n\ndef next_Perfect_Square(N):\n    next_sqrt = math.ceil(math.sqrt(N))\n    return next_sqrt ** 2\n",
    "MbppEval/442": "from array import array\n\ndef positive_count(nums):\n    positive_count = 0\n    for num in nums:\n        if num > 0:\n            positive_count += 1\n    return positive_count / len(nums)\n",
    "MbppEval/454": "import re\n\ndef text_match_wordz(text):\n    if re.search(r'\\w*z\\w*', text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
    "MbppEval/455": "import calendar\n\ndef check_monthnumb_number(month, year):\n    _, num_days = calendar.monthrange(year, month)\n    return num_days == 31\n",
    "MbppEval/401": "def add_nested_tuples(test_tup1, test_tup2):\n    result = []\n    for tup1, tup2 in zip(test_tup1, test_tup2):\n        result.append(tuple(a + b for a, b in zip(tup1, tup2)))\n    return tuple(result)\n",
    "MbppEval/459": "import re\n\ndef remove_uppercase(str1):\n    return re.sub(r'[A-Z]+', '', str1)\n",
    "MbppEval/460": "def Extract(lst):\n    first_elements = []\n    for sub_list in lst:\n        first_elements.append(sub_list[0])\n    return first_elements\n",
    "MbppEval/462": "def combinations_list(list1):\n    result = []\n\n    def generate_combinations(curr_combo, remaining_list):\n        if not remaining_list:\n            result.append(curr_combo[:])\n            return\n\n        # Include the first element\n        curr_combo.append(remaining_list[0])\n        generate_combinations(curr_combo, remaining_list[1:])\n        curr_combo.pop()\n\n        # Exclude the first element\n        generate_combinations(curr_combo, remaining_list[1:])\n\n    generate_combinations([], list1)\n    return result\n",
    "MbppEval/461": "def upper_ctr(str):\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count\n",
    "MbppEval/393": "def max_length_list(input_list):\n    max_length = 0\n    max_length_list = None\n\n    for lst in input_list:\n        length = len(lst)\n        if length > max_length:\n            max_length = length\n            max_length_list = lst\n\n    return max_length, max_length_list\n",
    "MbppEval/431": "def common_element(list1, list2):\n    has_common = False\n    for item in list1:\n        if item in list2:\n            has_common = True\n            break\n    return has_common\n",
    "MbppEval/470": "def add_pairwise(test_tup):\n    pairwise_additions = []\n    for i in range(len(test_tup) - 1):\n        pairwise_additions.append(test_tup[i] + test_tup[i+1])\n    return tuple(pairwise_additions)\n",
    "MbppEval/464": "def check_value(d, n):\n    if not d:\n        return True\n\n    first_value = next(iter(d.values()))\n    for value in d.values():\n        if value != first_value:\n            return False\n\n    return True\n",
    "MbppEval/456": "def reverse_string_list(stringlist):\n    reversed_strings = []\n    for string in stringlist:\n        reversed_strings.append(string[::-1])\n    return reversed_strings\n",
    "MbppEval/463": "def max_subarray_product(arr):\n    if not arr:\n        return 0\n\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        curr = arr[i]\n        temp_max = max(curr, max_so_far * curr, min_so_far * curr)\n        min_so_far = min(curr, max_so_far * curr, min_so_far * curr)\n\n        max_so_far = temp_max\n\n        result = max(max_so_far, result)\n\n    return result\n",
    "MbppEval/465": "def drop_empty(dict1):\n    new_dict = {}\n    for key, value in dict1.items():\n        if value is not None:\n            new_dict[key] = value\n    return new_dict\n",
    "MbppEval/479": "def first_Digit(n):\n    num_str = str(n)\n    first_digit = int(num_str[0])\n    return first_digit\n",
    "MbppEval/445": "def index_multiplication(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Input tuples must have the same length.\")\n    \n    result = []\n    for pair1, pair2 in zip(test_tup1, test_tup2):\n        result.append((pair1[0] * pair2[0], pair1[1] * pair2[1]))\n    \n    return tuple(result)\n",
    "MbppEval/471": "def find_remainder(arr, n):\n    product = 1\n    for num in arr:\n        product *= num\n    return product % n\n",
    "MbppEval/559": "def max_sub_array_sum(a, size):\n    max_so_far = a[0]\n    max_ending_here = a[0]\n\n    for i in range(1, size):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n",
    "MbppEval/477": "def is_lower(string):\n    return string.lower()\n",
    "MbppEval/476": "def big_sum(nums):\n    smallest = min(nums)\n    largest = max(nums)\n    return smallest + largest\n",
    "MbppEval/474": "def replace_char(str1, ch, newch):\n    new_str = \"\"\n    for c in str1:\n        if c == ch:\n            new_str += newch\n        else:\n            new_str += c\n    return new_str\n",
    "MbppEval/473": "def tuple_intersection(test_list1, test_list2):\n    intersection_set = set()\n\n    for tup in test_list1:\n        reversed_tup = (tup[1], tup[0])\n        if tup in test_list2 or reversed_tup in test_list2:\n            intersection_set.add(tup)\n\n    for tup in test_list2:\n        reversed_tup = (tup[1], tup[0])\n        if tup in test_list1 or reversed_tup in test_list1:\n            intersection_set.add(tup)\n\n    return intersection_set\n",
    "MbppEval/472": "def check_Consecutive(l):\n    \"\"\"\n    Write a python function to check whether the given list contains consecutive numbers or not.\n\n    Examples:\n    check_Consecutive([1,2,3,4,5]) == True\n    check_Consecutive([1,2,3,5,6]) == False\n    check_Consecutive([1,2,1]) == False\n    \"\"\"\n    is_consecutive = True\n    for i in range(len(l) - 1):\n        if l[i+1] - l[i] != 1:\n            is_consecutive = False\n            break\n    return is_consecutive\n",
    "MbppEval/556": "def find_Odd_Pair(A, N):\n    even_count = 0\n    odd_count = 0\n    \n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return even_count * odd_count\n",
    "MbppEval/447": "def cube_nums(nums):\n    cubes = []\n    for num in nums:\n        cubes.append(num ** 3)\n    return cubes\n",
    "MbppEval/413": "def extract_nth_element(list1, n):\n    result = [item[n] for item in list1]\n    return result\n",
    "MbppEval/567": "def issort_list(list1):\n    return all(list1[i] <= list1[i+1] for i in range(len(list1) - 1))\n",
    "MbppEval/566": "def sum_digits(n):\n    total = 0\n    for digit in str(n):\n        total += int(digit)\n    return total\n",
    "MbppEval/558": "def digit_distance_nums(n1, n2):\n    n1_str = str(n1)\n    n2_str = str(n2)\n\n    total_diff = 0\n\n    for i in range(max(len(n1_str), len(n2_str))):\n        d1 = int(n1_str[i]) if i < len(n1_str) else 0\n        d2 = int(n2_str[i]) if i < len(n2_str) else 0\n\n        total_diff += abs(d1 - d2)\n\n    return total_diff\n",
    "MbppEval/579": "def find_dissimilar(test_tup1, test_tup2):\n    dissimilar_elements = set()\n    \n    for element in test_tup1:\n        if element not in test_tup2:\n            dissimilar_elements.add(element)\n            \n    for element in test_tup2:\n        if element not in test_tup1:\n            dissimilar_elements.add(element)\n            \n    return tuple(dissimilar_elements)\n",
    "MbppEval/554": "def Split(list_of_integers):\n    odd_numbers = []\n    for num in list_of_integers:\n        if num % 2 != 0:\n            odd_numbers.append(num)\n    return odd_numbers\n",
    "MbppEval/569": "def sort_sublists(list1):\n    sorted_list = []\n    for sublist in list1:\n        sorted_list.append(sorted(sublist))\n    return sorted_list\n",
    "MbppEval/560": "def union_elements(test_tup1, test_tup2):\n    return tuple(sorted(set(list(test_tup1) + list(test_tup2))))\n",
    "MbppEval/582": "def my_dict(dict1):\n    return not dict1\n",
    "MbppEval/86": "def centered_hexagonal_number(n):\n    return n * (5 * n - 3)\n",
    "MbppEval/576": "def is_Sub_Array(A, B):\n    i, j = 0, 0\n    while i < len(A) and j < len(B):\n        if A[i] == B[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n        if j == len(B):\n            return True\n    return False\n",
    "MbppEval/583": "from math import gamma\n\ndef catalan_number(num):\n    \"\"\"\n    Returns the nth Catalan number.\n    \"\"\"\n    numerator = gamma(2 * num + 1)\n    denominator = gamma(num + 1) * gamma(num + 1)\n    return int(numerator / denominator)\n",
    "MbppEval/577": "def last_Digit_Factorial(n):\n    \"\"\"\n    Write a python function to find the last digit in factorial of a given number.\n\n    Examples:\n    last_Digit_Factorial(4) == 4\n    last_Digit_Factorial(21) == 0\n    last_Digit_Factorial(30) == 0\n    \"\"\"\n    if n == 0:\n        return 1\n\n    last_digits = [1, 1, 2, 6, 4, 2, 2, 4, 2, 8]\n    return last_digits[n % 10]\n",
    "MbppEval/568": "def empty_list(length):\n    return [{} for _ in range(length)]\n",
    "MbppEval/584": "import re\n\ndef find_adverbs(text):\n    pattern = r'\\w+ly'\n    match = re.search(pattern, text)\n    if match:\n        adverb = match.group()\n        start = match.start()\n        end = match.end()\n        return f\"{start}-{end}: {adverb}\"\n    else:\n        return \"\"\n",
    "MbppEval/578": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for x, y, z in zip(list1, list2, list3):\n        interleaved_list.append(x)\n        interleaved_list.append(y)\n        interleaved_list.append(z)\n    return interleaved_list\n",
    "MbppEval/580": "def even_ele(test_tuple, even_fnc):\n    even_list = []\n    for element in test_tuple:\n        if isinstance(element, tuple):\n            even_list.append(even_ele(element, even_fnc))\n        elif even_fnc(element):\n            even_list.append(element)\n    return tuple(even_list)\n",
    "MbppEval/587": "def list_tuple(listx):\n    return tuple(listx)\n",
    "MbppEval/450": "def extract_string(str_list, length):\n    result = []\n    for s in str_list:\n        if len(s) == length:\n            result.append(s)\n    return result\n",
    "MbppEval/394": "def check_distinct(test_tup):\n    return len(set(test_tup)) == len(test_tup)\n",
    "MbppEval/475": "from collections import Counter\n\ndef sort_counter(dict1):\n    counter = Counter(dict1)\n    sorted_counter = counter.most_common()\n    return sorted_counter\n",
    "MbppEval/586": "def split_Arr(l, n):\n    \"\"\"\n    Write a python function to split a list at the nth element and add the first part to the end.\n\n    Examples:\n    split_Arr([12,10,5,6,52,36],6,2) == [5,6,52,36,12,10]\n    split_Arr([1,2,3,4],4,1) == [2,3,4,1]\n    split_Arr([0,1,2,3,4,5,6,7],8,3) == [3,4,5,6,7,0,1,2]\n    \"\"\"\n    if n < 0 or n > len(l):\n        return l\n    \n    first_part = l[:n]\n    second_part = l[n:]\n    \n    return second_part + first_part\n",
    "MbppEval/468": "def max_product(arr):\n    if len(arr) == 0:\n        return 0\n    \n    max_prod = arr[0]\n    curr_prod = arr[0]\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            curr_prod *= arr[i]\n            max_prod = max(max_prod, curr_prod)\n        else:\n            curr_prod = arr[i]\n    \n    return max_prod\n",
    "MbppEval/599": "def sum_average(number):\n    sum_of_numbers = 0\n    for i in range(1, number + 1):\n        sum_of_numbers += i\n    average_of_numbers = sum_of_numbers / number\n    return (sum_of_numbers, average_of_numbers)\n",
    "MbppEval/564": "def count_Pairs(arr, n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count\n",
    "MbppEval/597": "def find_kth(arr1, arr2, k):\n    i, j = 0, 0\n    count = 0\n\n    while count < k - 1:\n        if i < len(arr1) and (j >= len(arr2) or arr1[i] < arr2[j]):\n            i += 1\n        else:\n            j += 1\n        count += 1\n\n    return min(arr1[i] if i < len(arr1) else float('inf'), arr2[j] if j < len(arr2) else float('inf'))\n",
    "MbppEval/585": "import heapq\n\ndef expensive_items(items, n):\n    price_items = [(item['price'], item) for item in items]\n    most_expensive = [item[1] for item in heapq.nlargest(n, price_items)]\n    return most_expensive\n",
    "MbppEval/602": "def first_repeated_char(str1):\n    char_dict = {}\n\n    for i, char in enumerate(str1):\n        if char in char_dict:\n            return char\n        else:\n            char_dict[char] = i\n\n    return \"None\"\n",
    "MbppEval/563": "import re\n\ndef extract_values(text):\n    values = re.findall(r'\"(.*?)\"', text)\n    return values\n",
    "MbppEval/478": "import re\n\ndef remove_lowercase(str1):\n    lowercase_substrings = re.findall(r'[a-z]+', str1)\n    new_string = ''.join(char for char in str1 if char not in ''.join(lowercase_substrings))\n    return new_string\n",
    "MbppEval/596": "import sys\n\ndef tuple_size(tuple_list):\n    '''\n    Write a function to find the size in bytes of the given tuple.\n\n    Examples:\n    tuple_size((\"A\", 1, \"B\", 2, \"C\", 3)) == 42\n    tuple_size((1, \"Raju\", 2, \"Nikhil\", 3, \"Deepanshu\")) == 72\n    tuple_size(((1, \"Lion\"), (2, \"Tiger\"), (3, \"Fox\"), (4, \"Wolf\"))) == 80\n    '''\n    total_size = 0\n    for tup in tuple_list:\n        tup_size = 0\n        for item in tup:\n            tup_size += sys.getsizeof(item)\n        total_size += tup_size\n    return total_size\n",
    "MbppEval/588": "def big_diff(nums):\n    max_num = max(nums)\n    min_num = min(nums)\n    return max_num - min_num\n",
    "MbppEval/594": "def diff_even_odd(list1):\n    first_even = None\n    first_odd = None\n    \n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None or first_odd is None:\n        return None\n    \n    return abs(first_even - first_odd)\n",
    "MbppEval/592": "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\ndef binomial_Coeff(n, k):\n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef sum_Of_product(n):\n    result = 0\n    for i in range(n):\n        result += binomial_Coeff(n, i) * binomial_Coeff(n, i+1)\n    return result\n",
    "MbppEval/589": "import math\n\ndef perfect_squares(a, b):\n    \"\"\"\n    Write a function to find perfect squares between two given numbers.\n\n    Examples:\n    perfect_squares(1,30) == [1, 4, 9, 16, 25]\n    perfect_squares(50,100) == [64, 81, 100]\n    perfect_squares(100,200) == [100, 121, 144, 169, 196]\n    \"\"\"\n    if not (isinstance(a, int) and isinstance(b, int) and a > 0 and b > 0):\n        raise ValueError(\"a and b must be positive integers\")\n\n    perfect_squares_list = []\n\n    for num in range(a, b+1):\n        sqrt = math.sqrt(num)\n        if sqrt.is_integer():\n            perfect_squares_list.append(num)\n\n    return perfect_squares_list\n",
    "MbppEval/590": "import cmath\n\ndef polar_rect(x, y):\n    r = (x ** 2 + y ** 2) ** 0.5\n    theta = cmath.atan2(y, x)\n    real = r * cmath.cos(theta)\n    imag = r * cmath.sin(theta)\n    return (real, imag), complex(real, imag)\n",
    "MbppEval/610": "def remove_kth_element(list1, k):\n    result = []\n    for i, item in enumerate(list1):\n        if i != k:\n            result.append(item)\n    return result\n",
    "MbppEval/600": "def is_Even(n):\n    if n % 2 == 0:\n        return True\n    else:\n        return False\n",
    "MbppEval/593": "import re\n\ndef removezero_ip(ip):\n    octets = ip.split('.')\n    cleaned_octets = [str(int(octet)) for octet in octets]\n    cleaned_ip = '.'.join(cleaned_octets)\n    return cleaned_ip\n",
    "MbppEval/606": "import math\n\ndef radian_degree(degree):\n    return degree * (math.pi / 180)\n",
    "MbppEval/604": "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_sentence = ' '.join(reversed_words)\n    return reversed_sentence\n",
    "MbppEval/591": "def swap_List(newList):\n    if len(newList) < 2:\n        return newList\n    newList[0], newList[-1] = newList[-1], newList[0]\n    return newList\n",
    "MbppEval/612": "def merge(lst):\n    first_elements = []\n    second_elements = []\n    \n    for sub_list in lst:\n        first_elements.append(sub_list[0])\n        second_elements.append(sub_list[1])\n    \n    return [first_elements, second_elements]\n",
    "MbppEval/598": "def armstrong_number(number):\n    \"\"\"\n    Write a function to check whether the given number is armstrong or not.\n\n    Examples:\n    armstrong_number(153) == True\n    armstrong_number(259) == False\n    armstrong_number(4458) == False\n    \"\"\"\n    num_str = str(number)\n    sum_of_cubes = 0\n    for digit in num_str:\n        sum_of_cubes += int(digit) ** len(num_str)\n    return sum_of_cubes == number\n",
    "MbppEval/605": "def prime_num(num):\n    '''\n    Write a function to check if the given integer is a prime number.\n\n    Examples:\n    prime_num(13) == True\n    prime_num(7) == True\n    prime_num(-1010) == False\n    '''\n    is_prime = True\n\n    # Check if the number is less than 2\n    if num < 2:\n        is_prime = False\n        return is_prime\n\n    # Check if the number is divisible by any number between 2 and its square root\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            is_prime = False\n            break\n\n    return is_prime\n",
    "MbppEval/595": "def min_Swaps(str1, str2):\n    if len(str1) != len(str2):\n        return \"Not Possible\"\n    \n    diff = sum(1 for c1, c2 in zip(str1, str2) if c1 != c2)\n    \n    if diff % 2 != 0:\n        return \"Not Possible\"\n    \n    return diff // 2\n",
    "MbppEval/623": "def nth_nums(nums, n):\n    results = []\n    for num in nums:\n        result = num ** n\n        results.append(result)\n    return results\n",
    "MbppEval/625": "def swap_List(new_list):\n    first = new_list[0]\n    last = new_list[-1]\n    new_list[0] = last\n    new_list[-1] = first\n    return new_list\n",
    "MbppEval/619": "def move_num(test_str):\n    non_numeric = \"\"\n    numbers = \"\"\n    for char in test_str:\n        if char.isdigit():\n            numbers += char\n        else:\n            non_numeric += char\n    return non_numeric + numbers\n",
    "MbppEval/618": "def div_list(nums1, nums2):\n    if len(nums1) != len(nums2):\n        return []\n    \n    result = []\n    for i in range(len(nums1)):\n        result.append(nums1[i] / nums2[i])\n    \n    return result\n",
    "MbppEval/624": "def is_upper(string):\n    return string.upper()\n",
    "MbppEval/607": "import re\n\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return None\n",
    "MbppEval/620": "def largest_subset(a):\n    max_size = 0\n    subset = []\n\n    for i in range(1, 2 ** len(a)):\n        current_subset = []\n        for j in range(len(a)):\n            if i & (1 << j):\n                current_subset.append(a[j])\n\n        if all(a % b == 0 or b % a == 0 for a in current_subset for b in current_subset):\n            if len(current_subset) > max_size:\n                max_size = len(current_subset)\n                subset = current_subset\n\n    return max_size\n",
    "MbppEval/622": "def get_median(arr1, arr2, n):\n    merged = []\n    i, j = 0, 0\n    while i < n and j < n:\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    \n    while i < n:\n        merged.append(arr1[i])\n        i += 1\n    while j < n:\n        merged.append(arr2[j])\n        j += 1\n    \n    length = len(merged)\n    if length % 2 == 0:\n        return (merged[length // 2 - 1] + merged[length // 2]) / 2\n    else:\n        return merged[length // 2]\n",
    "MbppEval/629": "def Split(list_of_numbers):\n    even_nums = []\n    for num in list_of_numbers:\n        if num % 2 == 0:\n            even_nums.append(num)\n    return even_nums\n",
    "MbppEval/626": "def triangle_area(r):\n    \"\"\"\n    Write a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n\n    Examples:\n    triangle_area(0) == 0\n    triangle_area(-1) == -1\n    triangle_area(2) == 4\n    \"\"\"\n    if r < 0:\n        return -1\n    return r ** 2\n",
    "MbppEval/632": "def move_zero(num_list):\n    result = []\n    zero_count = 0\n\n    for num in num_list:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n\n    result.extend([0] * zero_count)\n    return result\n",
    "MbppEval/628": "def replace_spaces(string):\n    result = \"\"\n    for char in string:\n        if char == \" \":\n            result += \"%20\"\n        else:\n            result += char\n    return result\n",
    "MbppEval/638": "import math\n\ndef wind_chill(v, t):\n    \"\"\"\n    Write a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\n    Examples:\n    wind_chill(120, 35) == 40\n    wind_chill(40, 70) == 86\n    wind_chill(10, 100) == 116\n    \"\"\"\n    wind_chill_index = 13.12 + 0.6215 * t - 11.37 * v ** 0.16 + 0.3965 * t * v ** 0.16\n    return round(wind_chill_index)\n",
    "MbppEval/633": "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            total_xor_sum ^= (arr[i] ^ arr[j])\n    \n    return total_xor_sum\n",
    "MbppEval/637": "def noprofit_noloss(actual_cost, sale_amount):\n    if actual_cost == sale_amount:\n        return True\n    else:\n        return False\n",
    "MbppEval/635": "import heapq as hq\n\ndef heap_sort(iterable):\n    \"\"\"\n    Sort the given list using heap sort.\n\n    Args:\n        iterable (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    # Step 1: Create a max-heap from the given list\n    heap = [-x for x in iterable]\n    hq.heapify(heap)\n\n    # Step 2: Repeatedly extract the maximum element from the heap\n    result = []\n    while heap:\n        result.append(-hq.heappop(heap))\n\n    return result\n",
    "MbppEval/611": "def max_of_nth(test_list, N):\n    max_value = float('-inf')\n    for row in test_list:\n        if len(row) > N:\n            max_value = max(max_value, row[N])\n    return max_value\n",
    "MbppEval/726": "def multiply_elements(test_tup):\n    result = ()\n    for i in range(len(test_tup) - 1):\n        result += (test_tup[i] * test_tup[i+1],)\n    return result\n",
    "MbppEval/644": "def reverse_Array_Upto_K(input, k):\n    left = 0\n    right = k - 1\n    \n    while left < right:\n        input[left], input[right] = input[right], input[left]\n        left += 1\n        right -= 1\n    \n    return input\n",
    "MbppEval/723": "def count_same_pair(nums1, nums2):\n    count_dict = {}\n    for num in nums1:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    total_count = 0\n    for num in nums2:\n        if num in count_dict:\n            total_count += count_dict[num]\n            count_dict[num] -= 1\n    \n    return total_count\n",
    "MbppEval/721": "def maxAverageOfPath(cost):\n    n = len(cost)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Base case: the average for the top-left cell is the cost of that cell\n    dp[0][0] = cost[0][0]\n    \n    # Fill in the first row and first column\n    for i in range(1, n):\n        dp[i][0] = (dp[i-1][0] * i + cost[i][0]) / (i + 1)\n        dp[0][i] = (dp[0][i-1] * i + cost[0][i]) / (i + 1)\n    \n    # Fill in the rest of the matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            # The maximum average for the current cell is the maximum of\n            # the average of the path coming from the left and the average\n            # of the path coming from above\n            dp[i][j] = max((dp[i-1][j] * i + cost[i][j]) / (i + 1),\n                          (dp[i][j-1] * j + cost[i][j]) / (j + 1))\n    \n    # The maximum average is the value in the bottom-right cell\n    return dp[n-1][n-1]\n",
    "MbppEval/732": "import re\n\ndef replace_specialchar(text):\n    return re.sub(r'[ ,\\.]', ':', text)\n",
    "MbppEval/631": "def replace_spaces(text):\n    return text.replace(\" \", \"_\").replace(\"_\", \" \")\n",
    "MbppEval/630": "def adjac(ele, sub=None):\n    if sub is None:\n        sub = []\n\n    x, y = ele\n\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            new_x = x + dx\n            new_y = y + dy\n            if new_x >= 0 and new_y >= 0:\n                sub.append([new_x, new_y])\n\n    return sub\n",
    "MbppEval/640": "import re\n\ndef remove_parenthesis(items):\n    result = []\n    for item in items:\n        cleaned_item = re.sub(r'\\([^)]*\\)', '', item)\n        result.append(cleaned_item.strip())\n    return result\n",
    "MbppEval/734": "def sum_Of_Subarray_Prod(arr):\n    n = len(arr)\n    dp = [[0] * n for _ in range(n)]\n    total_sum = 0\n\n    for i in range(n):\n        dp[i][i] = arr[i]\n        total_sum += dp[i][i]\n\n    for length in range(2, n+1):\n        for i in range(n-length+1):\n            j = i + length - 1\n            dp[i][j] = dp[i][j-1] * arr[j]\n            total_sum += dp[i][j]\n\n    return total_sum\n",
    "MbppEval/627": "def find_First_Missing(array, start=0, end=None):\n    if not array:\n        return 0\n\n    if array[0] != 0:\n        return 0\n\n    if end is None:\n        end = len(array) - 1\n\n    if array[end] == end:\n        return end + 1\n\n    for i in range(start, end + 1):\n        if array[i] != i:\n            return i\n\n    return len(array)\n",
    "MbppEval/725": "import re\n\ndef extract_quotation(text1):\n    extracted_values = []\n    matches = re.findall(r'\"(.*?)\"', text1)\n    extracted_values.extend(matches)\n    return extracted_values\n",
    "MbppEval/728": "def sum_list(lst1, lst2):\n    if not lst1 or not lst2:\n        return []\n\n    max_length = max(len(lst1), len(lst2))\n    lst1 = lst1 + [0] * (max_length - len(lst1))\n    lst2 = lst2 + [0] * (max_length - len(lst2))\n\n    return [a + b for a, b in zip(lst1, lst2)]\n",
    "MbppEval/643": "import re\n\ndef text_match_wordz_middle(text):\n    pattern = r'\\b\\w*z\\w*\\b'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
    "MbppEval/736": "import bisect\n\ndef left_insertion(a, x):\n    return bisect.bisect_left(a, x)\n",
    "MbppEval/722": "def filter_data(students, h, w):\n    filtered_students = {}\n    \n    for student, stats in students.items():\n        student_height, student_weight = stats\n        if student_height >= h and student_weight >= w:\n            filtered_students[student] = stats\n    \n    return filtered_students\n",
    "MbppEval/738": "def geometric_sum(n):\n    total = 0\n    for i in range(n):\n        total += 1 / (2 ** i)\n    return total\n",
    "MbppEval/737": "import re\n\nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\n\ndef check_str(string):\n    if re.match(regex, string):\n        return 'Valid'\n    else:\n        return 'Invalid'\n",
    "MbppEval/574": "import math\n\ndef surfacearea_cylinder(r, h):\n    \"\"\"\n    Write a function to find the surface area of a cylinder.\n\n    Examples:\n    surfacearea_cylinder(10, 5) == 942.45\n    surfacearea_cylinder(4, 5) == 226.18\n    surfacearea_cylinder(4, 10) == 351.85\n    \"\"\"\n    surface_area = 2 * math.pi * r * (r + h)\n    return round(surface_area, 2)\n",
    "MbppEval/731": "import math\n\ndef lateralsurface_cone(r, h):\n    l = math.sqrt(r ** 2 + h ** 2)\n    lateral_surface_area = math.pi * r * l\n    return lateral_surface_area\n",
    "MbppEval/740": "def tuple_to_dict(test_tup):\n    result = {}\n    for i in range(0, len(test_tup), 2):\n        result[test_tup[i]] = test_tup[i+1]\n    return result\n",
    "MbppEval/730": "from itertools import groupby\n\ndef consecutive_duplicates(nums):\n    result = []\n    for _, group in groupby(nums):\n        result.append(next(group))\n    return result\n",
    "MbppEval/608": "def bell_Number(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n\n    bell_numbers = [1, 1]\n    for i in range(2, n+1):\n        bell_num = sum(bell_numbers[j] * bell_numbers[i-j-1] for j in range(i))\n        bell_numbers.append(bell_num)\n\n    return bell_numbers[n]\n",
    "MbppEval/742": "import math\n\ndef area_tetrahedron(side):\n    return (math.sqrt(3) * side**2) / 4\n",
    "MbppEval/739": "import math\n\ndef find_Index(n):\n    index = 1\n    triangular_num = 1\n    while len(str(triangular_num)) < n:\n        index += 1\n        triangular_num = (index * (index + 1)) // 2\n    return index\n",
    "MbppEval/741": "def all_Characters_Same(s):\n    \"\"\"\n    Write a python function to check whether all the characters are same or not.\n\n    Examples:\n    all_Characters_Same(\"python\") == False\n    all_Characters_Same(\"aaa\") == True\n    all_Characters_Same(\"data\") == False\n    \"\"\"\n    if not s:\n        return True\n    \n    first_char = s[0]\n    for char in s[1:]:\n        if char != first_char:\n            return False\n    \n    return True\n",
    "MbppEval/743": "def rotate_right(lst, m, n):\n    \"\"\"\n    Rotates a list to the right by m positions, n times.\n    \"\"\"\n    for _ in range(n):\n        last_m = lst[-m:]\n        rest = lst[:-m]\n        lst = last_m + rest\n    return lst\n",
    "MbppEval/735": "def set_middle_bits(n):\n    if n in (0, 1):\n        return n\n    num_bits = len(bin(n)) - 2\n    mask = (1 << num_bits) - 2\n    return n ^ mask\n",
    "MbppEval/744": "def check_none(test_tup):\n    has_none = False\n    for element in test_tup:\n        if element is None:\n            has_none = True\n            break\n    return has_none\n",
    "MbppEval/733": "def find_first_occurrence(A, x):\n    left = 0\n    right = len(A) - 1\n    \n    while left <= right:\n        middle = (left + right) // 2\n        \n        if A[middle] == x:\n            if middle == 0 or A[middle-1] != x:\n                return middle\n            else:\n                right = middle - 1\n        elif A[middle] < x:\n            left = middle + 1\n        else:\n            right = middle - 1\n    \n    return -1\n",
    "MbppEval/754": "def extract_index_list(l1, l2, l3):\n    if len(l1) != len(l2) or len(l2) != len(l3):\n        return []\n\n    common_list = []\n\n    for i in range(len(l1)):\n        if l1[i] == l2[i] == l3[i]:\n            common_list.append(i)\n\n    return common_list\n",
    "MbppEval/745": "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum+1):\n        is_divisible = True\n        for digit in str(num):\n            if digit == '0' or num % int(digit) != 0:\n                is_divisible = False\n                break\n        if is_divisible:\n            result.append(num)\n    return result\n",
    "MbppEval/555": "def difference(n):\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    sum_of_numbers = sum(range(1, n+1))\n    return sum_of_cubes - sum_of_numbers\n",
    "MbppEval/753": "def min_k(test_list, K):\n    return sorted(test_list, key=lambda x: x[1])[:K]\n",
    "MbppEval/752": "def jacobsthal_num(n):\n    \"\"\"\n    Find the nth Jacobsthal number.\n    \n    Args:\n        n (int): The index of the Jacobsthal number to find.\n    \n    Returns:\n        int: The nth Jacobsthal number.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return jacobsthal_num(n-1) + 2 * jacobsthal_num(n-2)\n",
    "MbppEval/759": "def is_decimal(num):\n    \"\"\"\n    Write a function to check whether a given string is a decimal number with a precision of 2.\n\n    Examples:\n    is_decimal('123.11') == True\n    is_decimal('e666.86') == False\n    is_decimal('3.124587') == False\n    \"\"\"\n    if '.' not in num:\n        return False\n\n    parts = num.split('.')\n\n    if not parts[0].isdigit():\n        return False\n\n    if len(parts[1]) != 2:\n        return False\n\n    return True\n",
    "MbppEval/746": "import math\n\ndef sector_area(r, a):\n    \"\"\"\n    Write a function to find the area of a sector. The function takes the radius and angle as inputs. The function should return None if the angle is larger than 360 degrees.\n\n    Examples:\n    sector_area(4, 45) == 6.285714285714286\n    sector_area(9, 45) == 31.82142857142857\n    sector_area(9, 360) == None\n    \"\"\"\n    if a > 360:\n        return None\n    \n    area = (r ** 2 * a * math.pi) / 360\n    return area\n",
    "MbppEval/603": "def get_ludic(n):\n    ludic_numbers = []\n    for i in range(1, n+1):\n        if is_ludic(i):\n            ludic_numbers.append(i)\n    return ludic_numbers\n\ndef is_ludic(num):\n    if num == 1:\n        return True\n    \n    curr = 1\n    while curr < num:\n        curr = 2 * curr + 1\n    \n    return curr == num\n",
    "MbppEval/764": "def number_ctr(str):\n    count = 0\n    for char in str:\n        if char.isdigit():\n            count += 1\n    return count\n",
    "MbppEval/766": "def pair_wise(l1):\n    pairs = []\n    for i in range(len(l1) - 1):\n        pairs.append((l1[i], l1[i+1]))\n    return pairs\n",
    "MbppEval/757": "def count_reverse_pairs(test_list):\n    count = 0\n    for word in test_list:\n        reverse_word = word[::-1]\n        if reverse_word in test_list:\n            count += 1\n    return str(count // 2)\n",
    "MbppEval/758": "def unique_sublists(list1):\n    count_dict = {}\n    for sublist in list1:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    return count_dict\n",
    "MbppEval/573": "def unique_product(list_data):\n    unique_nums = set()\n    for num in list_data:\n        unique_nums.add(num)\n    \n    product = 1\n    for num in unique_nums:\n        product *= num\n    \n    return product\n",
    "MbppEval/756": "import re\n\ndef text_match_zero_one(text):\n    pattern = r'ab+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
    "MbppEval/755": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None\n\n    smallest = numbers[0]\n    second_smallest = float('inf')\n\n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest:\n            second_smallest = num\n\n    return second_smallest\n",
    "MbppEval/771": "from collections import deque\n\ndef check_expression(exp):\n    \"\"\"\n    Write a function to check if the given expression is balanced or not.\n    \"\"\"\n    brackets = {\n        \"(\": \")\",\n        \"[\": \"]\",\n        \"{\": \"}\"\n    }\n    stack = deque()\n\n    for char in exp:\n        if char in brackets:\n            stack.append(char)\n        elif char in brackets.values():\n            if not stack or brackets[stack.pop()] != char:\n                return False\n\n    return len(stack) == 0\n",
    "MbppEval/772": "def remove_length(test_str, K):\n    words = test_str.split()\n    new_words = [word for word in words if len(word) != K]\n    return ' '.join(new_words)\n",
    "MbppEval/615": "def average_tuple(nums):\n    averages = []\n    for num_tuple in nums:\n        avg = sum(num_tuple) / len(num_tuple)\n        averages.append(avg)\n    return averages\n",
    "MbppEval/773": "import re\n\ndef occurance_substring(text, pattern):\n    \"\"\"\n    Write a function to find the occurrence and position of the substrings within a string. Return None if there is no match.\n\n    Examples:\n    occurance_substring('python programming, python language','python') == ('python', 0, 6)\n    occurance_substring('python programming,programming language','programming') == ('programming', 7, 18)\n    occurance_substring('python programming,programming language','language') == ('language', 31, 39)\n    \"\"\"\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return None\n",
    "MbppEval/776": "def count_vowels(test_str):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    \n    for i in range(len(test_str)):\n        if test_str[i] in vowels:\n            if (i > 0 and test_str[i-1] in vowels) or (i < len(test_str)-1 and test_str[i+1] in vowels):\n                count += 1\n    \n    return count\n",
    "MbppEval/747": "def lcs_of_three(X, Y, Z):\n    m, n, o = len(X), len(Y), len(Z)\n    dp = [[[0] * (o+1) for _ in range(n+1)] for _ in range(m+1)]\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            for k in range(1, o+1):\n                if X[i-1] == Y[j-1] == Z[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])\n\n    return dp[m][n][o]\n",
    "MbppEval/749": "def sort_numeric_strings(nums_str):\n    nums_int = [int(num) for num in nums_str]\n    nums_int.sort()\n    sorted_nums_str = [str(num) for num in nums_int]\n    return sorted_nums_str\n",
    "MbppEval/751": "def check_min_heap_helper(arr, i):\n    left_child_idx = 2 * i + 1\n    right_child_idx = 2 * i + 2\n\n    # Check if the left child exists and if the node at index i is greater than the left child\n    if left_child_idx < len(arr) and arr[i] > arr[left_child_idx]:\n        return False\n\n    # Check if the right child exists and if the node at index i is greater than the right child\n    if right_child_idx < len(arr) and arr[i] > arr[right_child_idx]:\n        return False\n\n    # Recursively check the left and right subtrees\n    if left_child_idx < len(arr):\n        if not check_min_heap_helper(arr, left_child_idx):\n            return False\n    if right_child_idx < len(arr):\n        if not check_min_heap_helper(arr, right_child_idx):\n            return False\n\n    # If all checks pass, the subtree rooted at index i is a min-heap\n    return True\n",
    "MbppEval/767": "def get_pairs_count(arr, target_sum):\n    count = 0\n    seen = {}\n\n    for num in arr:\n        complement = target_sum - num\n        if complement in seen:\n            count += seen[complement]\n        seen[num] = seen.get(num, 0) + 1\n\n    return count\n",
    "MbppEval/777": "def find_sum(arr):\n    unique_set = set(arr)\n    total_sum = sum(unique_set)\n    return total_sum\n",
    "MbppEval/765": "import math\n\ndef is_polite(n):\n    count = 0\n    i = 1\n    while count < n:\n        if is_power_of_2(i) or is_sum_of_distinct_powers_of_2(i):\n            count += 1\n        i += 1\n    return i - 1\n\ndef is_power_of_2(x):\n    return (x & (x - 1)) == 0\n\ndef is_sum_of_distinct_powers_of_2(x):\n    temp = x\n    while temp > 0:\n        if (temp & 1) == 1 and (temp & (temp - 1)) != 0:\n            return False\n        temp >>= 1\n    return True\n",
    "MbppEval/779": "def unique_sublists(list1):\n    \"\"\"\n    Write a function to count the number of lists within a list. The function should return a dictionary, where every list is turned to a tuple, and the value of the tuple is the number of its occurrences.\n    \"\"\"\n    sublists_count = {}\n    for sublist in list1:\n        sublist_tuple = tuple(sublist)\n        sublists_count[sublist_tuple] = sublists_count.get(sublist_tuple, 0) + 1\n    return sublists_count\n",
    "MbppEval/778": "from itertools import groupby\n\ndef pack_consecutive_duplicates(list1):\n    result = []\n    for _, group in groupby(list1):\n        result.append(list(group))\n    return result\n",
    "MbppEval/780": "from itertools import combinations\n\ndef find_combinations(test_list):\n    return [(a[0] + b[0], a[1] + b[1]) for a, b in combinations(test_list, 2)]\n",
    "MbppEval/769": "def Diff(li1, li2):\n    set1 = set(li1)\n    set2 = set(li2)\n    diff_set = set1.symmetric_difference(set2)\n    return list(diff_set)\n",
    "MbppEval/785": "def tuple_str_int(test_str):\n    str_elements = test_str[1:-1]\n    elements = str_elements.split(\", \")\n    return tuple(int(elem) for elem in elements)\n",
    "MbppEval/458": "def rectangle_area(l, b):\n    return l * b\n",
    "MbppEval/788": "def new_tuple(test_list, test_str):\n    return (*test_list, test_str)\n",
    "MbppEval/781": "import math\n\ndef is_even_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of a number n is even.\n    \"\"\"\n    # Find the prime factorization of n\n    prime_factors = []\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            prime_factors.append(i)\n            n //= i\n        else:\n            i += 1\n    if n > 2:\n        prime_factors.append(n)\n\n    # Calculate the number of divisors\n    num_divisors = 1\n    for factor in prime_factors:\n        num_divisors *= (factor + 1)\n\n    # Determine if the number of divisors is even or odd\n    if num_divisors % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n",
    "MbppEval/790": "def even_position(nums):\n    result = True\n    for i in range(0, len(nums), 2):\n        if nums[i] % 2 != 0:\n            result = False\n            break\n    return result\n",
    "MbppEval/786": "import bisect\n\ndef right_insertion(a, x):\n    return bisect.bisect_right(a, x)\n",
    "MbppEval/791": "def remove_nested(test_tup):\n    result = []\n    for item in test_tup:\n        if not isinstance(item, tuple):\n            result.append(item)\n    return tuple(result)\n",
    "MbppEval/793": "def last(arr, x):\n    last_index = -1\n    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == x:\n            last_index = i\n            break\n    return last_index\n",
    "MbppEval/797": "def sum_odd(l, r):\n    sum = 0\n    for num in range(l, r + 1):\n        if num % 2 != 0:\n            sum += num\n    return sum\n",
    "MbppEval/794": "import re\n\ndef text_starta_endb(text):\n    pattern = r'^a.*b$'\n    if re.search(pattern, text):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n",
    "MbppEval/800": "import re\n\ndef remove_all_spaces(text):\n    return re.sub(r'\\s+', '', text)\n",
    "MbppEval/72": "import math\n\ndef dif_Square(n):\n    \"\"\"\n    Check whether the given number can be represented as the difference of two squares.\n    \n    Args:\n        n (int): The number to be checked.\n    \n    Returns:\n        bool: True if n can be represented as the difference of two squares, False otherwise.\n    \"\"\"\n    sqrt_n = int(math.sqrt(n))\n    for x in range(sqrt_n + 1):\n        if n == x**2 - (x+1)**2:\n            return True\n    return False\n",
    "MbppEval/787": "import re\n\ndef text_match_three(text):\n    pattern = r'a...b'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n",
    "MbppEval/784": "def find_first_even_odd(list1):\n    first_even = None\n    first_odd = None\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    return first_even, first_odd\n\ndef multiply_first_even_odd(even_num, odd_num):\n    if even_num is None or odd_num is None:\n        raise ValueError(\"Both even and odd numbers must be provided.\")\n    return even_num * odd_num\n\ndef mul_even_odd(list1):\n    first_even, first_odd = find_first_even_odd(list1)\n    return multiply_first_even_odd(first_even, first_odd)\n",
    "MbppEval/805": "def max_sum_list(lists):\n    max_sum = 0\n    max_list = []\n    \n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list\n",
    "MbppEval/807": "def first_odd(nums):\n    first_odd_num = None\n    for num in nums:\n        if num % 2 != 0:\n            first_odd_num = num\n            break\n    return first_odd_num\n",
    "MbppEval/798": "def _sum(arr):\n    total = 0\n    for num in arr:\n        total += num\n    return total\n",
    "MbppEval/799": "def left_rotate(n, d):\n    n &= 0xFFFFFFFF\n    return (n << d) | (n >> (32 - d))\n",
    "MbppEval/809": "def check_smaller(test_tup1, test_tup2):\n    result = True\n    for i in range(len(test_tup1)):\n        if test_tup2[i] >= test_tup1[i]:\n            result = False\n            break\n    return result\n",
    "MbppEval/801": "def test_three_equal(x, y, z):\n    unique_values = len(set([x, y, z]))\n    return 3 - unique_values\n",
    "MbppEval/783": "def rgb_to_hsv(r, g, b):\n    \"\"\"\n    Convert RGB color to HSV color.\n\n    Args:\n        r (int): The red value in the range [0, 255].\n        g (int): The green value in the range [0, 255].\n        b (int): The blue value in the range [0, 255].\n\n    Returns:\n        tuple: The HSV values as a tuple (h, s, v), where:\n            h is the hue in the range [0, 360),\n            s is the saturation in the range [0, 100],\n            v is the value in the range [0, 100].\n    \"\"\"\n    # Normalize the RGB values to the range [0, 1]\n    r, g, b = r/255, g/255, b/255\n\n    # Calculate the maximum and minimum of the RGB values\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n\n    # Calculate the hue (H)\n    if mx == mn:\n        h = 0\n    elif mx == r:\n        h = (60 * ((g-b)/(mx-mn)) + 360) % 360\n    elif mx == g:\n        h = (60 * ((b-r)/(mx-mn)) + 120) % 360\n    elif mx == b:\n        h = (60 * ((r-g)/(mx-mn)) + 240) % 360\n\n    # Calculate the saturation (S)\n    if mx == 0:\n        s = 0\n    else:\n        s = (1 - mn/mx) * 100\n\n    # Calculate the value (V)\n    v = mx * 100\n\n    return h, s, v\n",
    "MbppEval/748": "def capital_words_spaces(str1):\n    words = str1.split()\n    result = []\n    for word in words:\n        if word[0].isupper():\n            result.append(' ' + word)\n        else:\n            result.append(word)\n    return ''.join(result).strip()\n",
    "MbppEval/802": "def count_rotation(arr, n):\n    left = 0\n    right = n - 1\n\n    while left < right:\n        mid = (left + right) // 2\n\n        if arr[mid] > arr[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n",
    "MbppEval/806": "def max_run_uppercase(test_str):\n    max_run = 0\n    current_run = 0\n\n    for char in test_str:\n        if char.isupper():\n            current_run += 1\n        else:\n            current_run = 0\n\n        if current_run > max_run:\n            max_run = current_run\n\n    return max_run\n",
    "MbppEval/762": "def check_monthnumber_number(monthnum3):\n    thirty_day_months = [4, 6, 9, 11]\n    return monthnum3 in thirty_day_months\n",
    "MbppEval/782": "def odd_length_sum(arr):\n    total_sum = 0\n    prefix_sum = [0] * (len(arr) + 1)\n    \n    for i in range(1, len(arr) + 1):\n        prefix_sum[i] = prefix_sum[i-1] + arr[i-1]\n    \n    for i in range(1, len(arr) + 1):\n        odd_length_subarrays = (i + 1) // 2\n        total_sum += odd_length_subarrays * arr[i-1]\n    \n    return total_sum\n",
    "MbppEval/763": "def find_min_diff(arr, n):\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i-1])\n    return min_diff\n",
    "MbppEval/803": "import math\n\ndef is_perfect_square(n):\n    \"\"\"\n    Check whether the given number is a perfect square or not.\n    \n    Args:\n        n (int): The number to be checked.\n    \n    Returns:\n        bool: True if the input number is a perfect square, False otherwise.\n    \"\"\"\n    sqrt = math.sqrt(n)\n    return sqrt.is_integer()\n",
    "MbppEval/557": "def toggle_string(string):\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char.lower()\n        else:\n            result += char.upper()\n    return result\n",
    "MbppEval/808": "def check_K(test_tup, K):\n    contains_K = False\n    for element in test_tup:\n        if element == K:\n            contains_K = True\n            break\n    return contains_K\n",
    "MbppEval/796": "def return_sum(dict_input):\n    total_sum = 0\n    for value in dict_input.values():\n        total_sum += value\n    return total_sum\n",
    "MbppEval/792": "def count_list(input_list):\n    \"\"\"\n    Write a python function to count the number of lists in a given number of lists.\n\n    Examples:\n    count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4\n    count_list([[1,2],[2,3],[4,5]]) == 3\n    count_list([[1,0],[2,0]]) == 2\n    \"\"\"\n    return sum(1 for element in input_list if isinstance(element, list))\n",
    "MbppEval/9": "def find_Rotations(str):\n    return len(str) if str * 2 == str * 2 + str else 1\n",
    "MbppEval/775": "def odd_position(nums):\n    is_odd_position = True\n    for i in range(len(nums)):\n        if i % 2 == 1 and nums[i] % 2 == 0:\n            is_odd_position = False\n            break\n    return is_odd_position\n",
    "MbppEval/724": "def power_base_sum(base, power):\n    result = base ** power\n    total_sum = 0\n    \n    while result > 0:\n        total_sum += result % 10\n        result //= 10\n    \n    return total_sum\n",
    "MbppEval/770": "def odd_num_sum(n):\n    sum = 0\n    for i in range(1, 2*n, 2):\n        sum += i**4\n    return sum\n",
    "MbppEval/409": "def min_product_tuple(list1):\n    min_product = float('inf')\n    \n    for a, b in list1:\n        product = a * b\n        if product < min_product:\n            min_product = product\n    \n    return min_product\n",
    "MbppEval/720": "def add_dict_to_tuple(test_tup, test_dict):\n    return test_tup + (test_dict,)\n",
    "MbppEval/58": "def opposite_Signs(x, y):\n    return x * y < 0\n",
    "MbppEval/639": "def sample_nam(sample_names):\n    total_length = 0\n    for name in sample_names:\n        if name[0].isupper():\n            total_length += len(name)\n    return total_length\n",
    "MbppEval/562": "def Find_Max_Length(lst):\n    max_length = 0\n    for sublst in lst:\n        current_length = len(sublst)\n        if current_length > max_length:\n            max_length = current_length\n    return max_length\n",
    "MbppEval/281": "def all_unique(test_list):\n    unique_set = set(test_list)\n    return len(test_list) == len(unique_set)\n",
    "MbppEval/760": "def unique_Element(arr):\n    if not arr:\n        return 'YES'\n    \n    unique_elements = set(arr)\n    if len(unique_elements) == 1:\n        return 'YES'\n    else:\n        return 'NO'\n",
    "MbppEval/108": "import heapq\n\ndef merge_sorted_list(num1, num2, num3):\n    return list(heapq.merge(num1, num2, num3))\n",
    "MbppEval/104": "def sort_sublists(input_list):\n    return [sorted(sublist) for sublist in input_list]\n",
    "MbppEval/299": "from collections import defaultdict\n\ndef max_aggregate(stdata):\n    agg_scores = defaultdict(int)\n    for name, score in stdata:\n        agg_scores[name] += score\n    max_person, max_score = max(agg_scores.items(), key=lambda x: x[1])\n    return (max_person, max_score)\n",
    "MbppEval/161": "def remove_elements(list1, list2):\n    result = []\n    list2_set = set(list2)\n    for item in list1:\n        if item not in list2_set:\n            result.append(item)\n    return result\n",
    "MbppEval/74": "def is_samepatterns(colors, patterns):\n    if len(colors) != len(patterns):\n        return False\n\n    color_to_pattern = {}\n    for i in range(len(colors)):\n        color = colors[i]\n        pattern = patterns[i]\n\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n\n    return True\n",
    "MbppEval/129": "def magic_square_test(my_matrix):\n    \"\"\"\n    Write a function to calculate whether the matrix is a magic square.\n\n    Examples:\n    magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == True\n    magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) == True\n    magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 7]]) == False\n    \"\"\"\n    # Step 3: Calculate the expected sum for each row, column, and diagonal\n    magic_sum = sum(my_matrix[0])\n\n    # Step 4: Check if the sum of each row is equal to the magic_sum\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Step 5: Check if the sum of each column is equal to the magic_sum\n    for i in range(len(my_matrix[0])):\n        column_sum = 0\n        for row in my_matrix:\n            column_sum += row[i]\n        if column_sum != magic_sum:\n            return False\n\n    # Step 6: Check if the sum of the main diagonal is equal to the magic_sum\n    main_diagonal_sum = 0\n    for i in range(len(my_matrix)):\n        main_diagonal_sum += my_matrix[i][i]\n    if main_diagonal_sum != magic_sum:\n        return False\n\n    # Step 7: Check if the sum of the secondary diagonal is equal to the magic_sum\n    secondary_diagonal_sum = 0\n    for i in range(len(my_matrix)):\n        secondary_diagonal_sum += my_matrix[i][len(my_matrix[0]) - 1 - i]\n    if secondary_diagonal_sum != magic_sum:\n        return False\n\n    # Step 8: If all the checks pass, return True\n    return True\n",
    "MbppEval/59": "def is_octagonal(n):\n    return n * (3 * n - 2)\n",
    "MbppEval/565": "def split(word):\n    characters = []\n    for char in word:\n        characters.append(char)\n    return characters\n",
    "MbppEval/641": "def get_nth_nonagonal(n):\n    \"\"\"\n    Calculate the nth nonagonal number.\n\n    Args:\n        n (int): A positive integer representing the index of the nonagonal number.\n\n    Returns:\n        int: The nth nonagonal number.\n\n    Raises:\n        ValueError: If `n` is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (7 * n - 5) // 2\n",
    "MbppEval/235": "def even_bit_set_number(n):\n    mask = 0b10101010101010101010101010101010\n    result = n | mask\n    return result\n",
    "MbppEval/66": "def pos_count(lst):\n    count = 0\n    for num in lst:\n        if num > 0:\n            count += 1\n    return count\n",
    "MbppEval/429": "def and_tuples(test_tup1, test_tup2):\n    result = tuple(a & b for a, b in zip(test_tup1, test_tup2))\n    return result\n",
    "MbppEval/572": "def two_unique_nums(nums):\n    return list(set(nums))\n",
    "MbppEval/69": "def is_sublist(l, s):\n    return s in l\n",
    "MbppEval/400": "def extract_freq(test_list):\n    \"\"\"\n    Write a function to extract the number of unique tuples in the given list.\n\n    Examples:\n    extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)]) == 3\n    extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)]) == 4\n    extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)]) == 4\n    \"\"\"\n    unique_tuples = set()\n    for tuple_item in test_list:\n        unique_tuples.add(tuple_item)\n    return len(unique_tuples)\n",
    "MbppEval/82": "import math\n\ndef volume_sphere(r):\n    return (4/3) * math.pi * r**3\n",
    "MbppEval/581": "def surface_Area(b, s):\n    base_area = b ** 2\n    slant_area = 0.5 * b * s\n    surface_area = base_area + 4 * slant_area\n    return surface_area\n",
    "MbppEval/750": "def add_tuple(test_list, test_tup):\n    return test_list + list(test_tup)\n",
    "MbppEval/433": "def check_greater(arr, number):\n    is_greater = True\n    for element in arr:\n        if number <= element:\n            is_greater = False\n            break\n    if is_greater:\n        return \"Yes, the entered number is greater than those in the array\"\n    else:\n        return \"No, entered number is less than those in the array\"\n",
    "MbppEval/804": "def is_product_even(arr):\n    product = 1\n    for num in arr:\n        product *= num\n    return product % 2 == 0\n",
    "MbppEval/453": "import math\n\ndef sumofFactors(n):\n    \"\"\"\n    Write a python function to find the sum of even factors of a number.\n\n    Examples:\n    sumofFactors(18) == 26\n    sumofFactors(30) == 48\n    sumofFactors(6) == 8\n    \"\"\"\n    sum = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                sum += i\n            if (n // i) % 2 == 0 and (n // i) != i:\n                sum += n // i\n    if int(math.sqrt(n)) ** 2 == n:\n        sum += int(math.sqrt(n))\n    return sum\n",
    "MbppEval/238": "def number_of_substrings(s):\n    count = 0\n    for i in range(len(s)):\n        count += len(s) - i\n    return count\n",
    "MbppEval/614": "def cummulative_sum(test_list):\n    total_sum = 0\n    for tup in test_list:\n        for value in tup:\n            total_sum += value\n    return total_sum\n",
    "MbppEval/617": "import math\n\ndef min_Jumps(steps, d):\n    if d == 0:\n        return 0\n\n    jumps = math.ceil(d / (math.sqrt(2) * steps))\n    return jumps\n",
    "MbppEval/616": "def tuple_modulo(test_tup1, test_tup2):\n    if len(test_tup1) != len(test_tup2):\n        return \"Error: Tuples must be of the same length.\"\n    return tuple(a % b for a, b in zip(test_tup1, test_tup2))\n",
    "MbppEval/135": "def hexagonal_num(n):\n    return n * (2 * n - 1)\n"
}
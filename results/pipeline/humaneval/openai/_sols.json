{
    "HumanEval/0": [
        "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    \n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n\n    return False\n",
        "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < threshold:\n                return True\n    return False\n",
        "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Step 0: Sort the list of numbers\n    for i in range(len(numbers) - 1):  # Step 1: Iterate through the sorted list\n        if abs(numbers[i] - numbers[i + 1]) < threshold:  # Check for closeness within the threshold\n            return True\n    return False\n",
        "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < threshold:\n                return True\n    \n    return False\n",
        "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n"
    ],
    "HumanEval/1": [
        "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(\" \", \"\")\n    separated_groups = []\n    left = 0\n    right = 0\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            left += 1\n        elif char == ')':\n            right += 1\n        \n        if left == right:\n            separated_groups.append(paren_string[start:(i+1)])\n            start = i + 1\n    \n    return separated_groups\n",
        "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    \"\"\"\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    groups = []\n    counter = 0\n    current_group = ''\n\n    for char in paren_string:\n        if char == '(':\n            counter += 1\n            current_group += char\n        if char == ')' and counter > 0:\n            counter -= 1\n            current_group += char\n            if counter == 0:\n                groups.append(current_group)\n                current_group = ''\n\n    return groups\n",
        "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(\" \", \"\")\n    separate_groups = []\n    open_paren_count = 0\n    temp_group = \"\"\n\n    for char in paren_string:\n        temp_group += char\n        if char == '(':\n            open_paren_count += 1\n        elif char == ')':\n            open_paren_count -= 1\n            if open_paren_count == 0:\n                separate_groups.append(temp_group)\n                temp_group = \"\"\n\n    return separate_groups\n",
        "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    separate_groups = []\n    stack = []\n    open_index = -1\n    \n    paren_string = paren_string.replace(\" \", \"\")\n    \n    for i, char in enumerate(paren_string):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            open_index = stack.pop()\n            group = paren_string[open_index:i + 1]\n            separate_groups.append(group)\n    \n    return separate_groups\n",
        "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(\" \", \"\")\n    separate_groups = []\n    current_group = \"\"\n\n    for char in paren_string:\n        if char == \"(\":\n            current_group += char\n        elif char == \")\":\n            current_group += char\n            separate_groups.append(current_group)\n            current_group = \"\"\n\n    return separate_groups\n"
    ],
    "HumanEval/2": [
        "def truncate_number(number: float) -> float:\n    int_part = int(number)\n    decimal_part = number - int_part\n    return decimal_part\n",
        "def truncate_number(number: float) -> float:\n    integer_part = int(number)\n    return number - integer_part\n",
        "def truncate_number(number: float) -> float:\n    decimal_part = number - int(number)\n    return decimal_part\n",
        "def truncate_number(number: float) -> float:\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n",
        "def truncate_number(number: float) -> float:\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n"
    ],
    "HumanEval/3": [
        "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n\n    for operation in operations:\n        balance += operation\n        \n        if balance < 0:\n            return True\n\n    return False\n",
        "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    \n    for operation in operations:\n        balance += operation\n        \n        if balance < 0:\n            return True\n    \n    return False\n",
        "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        \n        if balance < 0:\n            return True\n    \n    return False\n",
        "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    \"\"\"\n    \n    balance = 0\n    \n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n        \n    return False\n",
        "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False\n"
    ],
    "HumanEval/4": [
        "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    \n    absolute_diff = [abs(num - mean) for num in numbers]\n    \n    mean_abs_dev = sum(absolute_diff) / len(numbers)\n    return mean_abs_dev\n",
        "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    differences = [abs(num - mean) for num in numbers]\n    mad = sum(differences) / len(differences)\n    return mad\n",
        "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        return 0.0\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute difference of each number from the mean\n    absolute_diff = [abs(num - mean) for num in numbers]\n    \n    # Calculate the average of these absolute differences\n    mean_absolute_dev = sum(absolute_diff) / len(absolute_diff)\n    return mean_absolute_dev\n",
        "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    # Step 1: Calculate the mean of the input list\n    mean = sum(numbers) / len(numbers)\n    \n    # Step 2: Calculate the absolute differences between each element and the mean\n    absolute_diffs = [abs(number - mean) for number in numbers]\n    \n    # Step 3: Calculate the Mean Absolute Deviation (MAD) by averaging the absolute differences\n    mad = sum(absolute_diffs) / len(absolute_diffs)\n    \n    # Step 4: Return the Mean Absolute Deviation (MAD)\n    return mad\n",
        "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    # Step 0: Calculate the mean of the input list\n    mean = sum(numbers) / len(numbers)\n    \n    # Step 1: Calculate the absolute deviation for each element\n    absolute_deviations = [abs(num - mean) for num in numbers]\n    \n    # Step 2: Calculate the mean of the absolute deviations\n    mean_absolute_deviation = sum(absolute_deviations) / len(absolute_deviations)\n    \n    return mean_absolute_deviation\n"
    ],
    "HumanEval/5": [
        "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    \n    for i, num in enumerate(numbers):\n        result.append(num)\n        \n        if i != len(numbers) - 1:\n            result.append(delimiter)\n    \n    return result\n",
        "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"Insert a number 'delimiter' between every two consecutive elements of input list `numbers`.\"\"\"\n    result = []\n    for num in numbers[:-1]:\n        result.extend([num, delimiter])\n    result.append(numbers[-1])  # Append the last number without delimiter\n    return result\n",
        "from typing import List\n\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result\n",
        "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    \n    for i, num in enumerate(numbers):\n        result.append(num)  # Step 3: Append the current number\n        if i != len(numbers) - 1:  # Check if it's not the last number\n            result.append(delimiter)  # Step 4: Append the delimiter\n    \n    return result\n",
        "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:  # Check if num is not the last element\n            result.append(delimiter)\n    return result\n"
    ],
    "HumanEval/6": [
        "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    groups = paren_string.split()\n    result = []\n    \n    for group in groups:\n        max_count = 0\n        open_count = 0\n        \n        for char in group:\n            if char == '(':\n                open_count += 1\n                if open_count > max_count:\n                    max_count = open_count\n            elif char == ')':\n                open_count -= 1\n        \n        result.append(max_count)\n    \n    return result\n",
        "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    groups = paren_string.split()\n    \n    depths = []\n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        \n        depths.append(max_depth)\n    \n    return depths\n",
        "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    groups = paren_string.split()\n\n    def max_nesting_level(parentheses: str) -> int:\n        max_depth = 0\n        current_depth = 0\n        for char in parentheses:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        return max_depth\n\n    return [max_nesting_level(group) for group in groups]\n",
        "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n    max_nesting_levels = []\n    for group in paren_groups:\n        max_nesting = 0\n        current_level = 0\n        for char in group:\n            if char == '(':\n                current_level += 1\n                max_nesting = max(max_nesting, current_level)\n            elif char == ')':\n                current_level -= 1\n        max_nesting_levels.append(max_nesting)\n    \n    return max_nesting_levels\n",
        "from typing import List\n\n\ndef max_nesting_level(group: str) -> int:\n    max_depth = 0\n    depth = 0\n\n    for char in group:\n        if char == '(':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ')':\n            depth -= 1\n\n    return max_depth\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    groups = paren_string.split()\n    nesting_levels = [max_nesting_level(group) for group in groups]\n    return nesting_levels\n"
    ],
    "HumanEval/7": [
        "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    filtered_strings = []\n    \n    for string in strings:\n        if substring in string:\n            filtered_strings.append(string)\n    \n    return filtered_strings\n",
        "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    filtered_strings = []\n    \n    for string in strings:\n        if substring in string:\n            filtered_strings.append(string)\n        \n    return filtered_strings\n",
        "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    result = []\n    \n    for string in strings:\n        if substring in string:\n            result.append(string)\n    \n    return result\n",
        "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    result = []\n    \n    for string in strings:\n        if substring in string:\n            result.append(string)\n    \n    return result\n",
        "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    filtered_strings = []\n    for string in strings:\n        if substring in string:\n            filtered_strings.append(string)\n    return filtered_strings\n"
    ],
    "HumanEval/8": [
        "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_result = 0\n    product_result = 1\n\n    if not numbers:\n        return sum_result, product_result\n\n    for num in numbers:\n        sum_result += num\n        product_result *= num\n\n    return sum_result, product_result\n",
        "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_result = 0\n    product_result = 1\n    \n    sum_result = sum(numbers) if numbers else 0\n    product_result = 1 if numbers else 1\n    for num in numbers:\n        product_result *= num\n\n    return sum_result, product_result\n",
        "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:  # Check if numbers list is empty\n        return (0, 1)\n    \n    # Calculate sum and product of numbers in the list\n    numbers_sum = sum(numbers)\n    numbers_product = 1\n    for num in numbers:\n        numbers_product *= num\n    \n    return (numbers_sum, numbers_product)\n",
        "return total_sum, total_product\n",
        "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return 0, 1\n    else:\n        num_sum = sum(numbers)\n        product = 1\n        for num in numbers:\n            product *= num\n        return num_sum, product\n"
    ],
    "HumanEval/9": [
        "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    rolling_max_list = []\n    max_val = float('-inf')\n    \n    for num in numbers:\n        max_val = max(max_val, num)\n        rolling_max_list.append(max_val)\n    \n    return rolling_max_list\n",
        "from typing import List, Tuple\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    rolling_max_vals = []  # Step 0\n\n    max_val = float('-inf')\n    for num in numbers:\n        max_val = max(max_val, num)  # Update rolling maximum\n        rolling_max_vals.append(max_val)  # Append to result list\n\n    return rolling_max_vals\n",
        "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    rolling_max_list = []\n    \n    for i in range(len(numbers)):\n        if i == 0:\n            rolling_max_list.append(numbers[i])\n        else:\n            max_val = max(numbers[:i+1])\n            rolling_max_list.append(max_val)\n\n    return rolling_max_list\n",
        "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    result = []\n    \n    for i in range(len(numbers)):\n        current_max = max(numbers[:i + 1])\n        result.append(current_max)\n\n    return result\n",
        "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n    \n    for num in numbers:\n        current_max = max(current_max, num)\n        rolling_max_list.append(current_max)\n    \n    return rolling_max_list\n"
    ],
    "HumanEval/10": [
        "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n\n    if is_palindrome(string):\n        return string\n\n    for i in range(len(string) - 1, -1, -1):\n        if is_palindrome(string[i:]):\n            return string + string[:i-1][::-1]\n",
        "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    if is_palindrome(string):\n        return string + string[::-1]\n\n    for i in range(len(string), 0, -1):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n\n    return string + string[:-1][::-1]\n",
        "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string. \"\"\"\n    def longest_postfix_palindrome(s: str) -> str:\n        \"\"\" Find the longest postfix of the supplied string that is a palindrome. \"\"\"\n        for i in range(len(s), 0, -1):\n            if s[:i] == s[:i][::-1]:\n                return s[i:]\n        return s  # If the whole string is a palindrome\n\n    longest_palindrome_postfix = longest_postfix_palindrome(string)\n    prefix = string[:-len(longest_palindrome_postfix)]\n    reversed_prefix = prefix[::-1]  # Reverse the prefix\n    return string + reversed_prefix\n\n# Testing the function\n\n",
        "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    if not string:\n        return ''\n\n    for i in range(len(string), 0, -1):\n        suffix = string[:i]\n        if is_palindrome(suffix):\n            return string + string[:i-1][::-1]\n\n    return ''  # Return empty string if no palindromic suffix is found\n",
        "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string. \"\"\"\n    \n    # Step 1: Find the longest palindromic suffix\n    def longest_palindromic_suffix(s):\n        for i in range(len(s), 0, -1):\n            if is_palindrome(s[-i:]):\n                return s[-i:]\n        return ''\n    \n    palindromic_suffix = longest_palindromic_suffix(string)\n    \n    # Step 2: Append the reverse of the prefix before the palindromic suffix\n    return string + string[:len(string) - len(palindromic_suffix)][::-1]\n"
    ],
    "HumanEval/11": [
        "from typing import List\n\ndef string_xor(a: str, b: str) -> str:\n    int_a = int(a, 2)\n    int_b = int(b, 2)\n    \n    xor_result = int_a ^ int_b\n    \n    xor_result_str = bin(xor_result)[2:]\n\n    return xor_result_str\n",
        "from typing import List\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    if len(a) != len(b):\n        return \"Error: Inputs should be of the same length.\"\n\n    result = ''\n    \n    for char_a, char_b in zip(a, b):\n        # XOR operation for binary strings\n        result += str(int(char_a) ^ int(char_b))\n    \n    return result\n",
        "from typing import List\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            result += \"1\"\n        else:\n            result += \"0\"\n    \n    return result\n",
        "def string_xor(a: str, b: str) -> str:\n    result = \"\"\n    for i in range(min(len(a), len(b))):  # iterating over the indices of the smaller string\n        result += str(int(a[i]) ^ int(b[i]))  # performing XOR operation on the characters\n    return result\n",
        "def string_xor(a: str, b: str) -> str:\n    # Input Validation\n    if not all(char in '01' for char in a) or not all(char in '01' for char in b):\n        raise ValueError(\"Inputs should consist only of 1s and 0s.\")\n\n    # Pad the shorter string with zeros\n    max_len = max(len(a), len(b))\n    a = a.zfill(max_len)\n    b = b.zfill(max_len)\n\n    # Perform XOR operation\n    result = ''.join(str(int(char_a) ^ int(char_b)) for char_a, char_b in zip(a, b))\n    return result\n"
    ],
    "HumanEval/12": [
        "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n\n    max_length = 0\n    longest_string = None\n\n    for string in strings:\n        if len(string) > max_length:\n            max_length = len(string)\n            longest_string = string\n\n    return longest_string\n",
        "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    \n    max_len = 0\n    longest_str = None\n    \n    for string in strings:\n        if len(string) > max_len:\n            max_len = len(string)\n            longest_str = string\n        elif len(string) == max_len and longest_str is None:\n            longest_str = string\n\n    return longest_str\n",
        "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    \"\"\"\n    if not strings:\n        return None\n    \n    longest_string = strings[0]\n    max_length = len(strings[0])\n\n    for string in strings[1:]:\n        if len(string) > max_length:\n            longest_string = string\n            max_length = len(string)\n    \n    return longest_string\n",
        "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    \n    Args:\n        strings (List[str]): List of strings\n    \n    Returns:\n        Optional[str]: The longest string in the input list or None if the list is empty\n    \"\"\"\n    \n    if not strings:\n        return None\n    \n    max_length_str = strings[0]\n    \n    for string in strings:\n        if len(string) > len(max_length_str):\n            max_length_str = string\n    \n    return max_length_str\n",
        "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    \n    longest_string = strings[0]\n    \n    for string in strings[1:]:\n        if len(string) > len(longest_string):\n            longest_string = string\n    \n    return longest_string\n"
    ],
    "HumanEval/13": [
        "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    gcd = None\n    \n    while b != 0:\n        a, b = b, a % b\n    \n    return a\n\n# Testing the function with example test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n",
        "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Return the greatest common divisor of two integers a and b\n    \n    Parameters:\n    a (int): The first integer\n    b (int): The second integer\n    \n    Returns:\n    int: The greatest common divisor of a and b\n    \n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    while b:\n        a, b = b, a % b\n        \n    return a\n",
        "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b \"\"\"\n    smallest = min(a, b)\n    for i in range(smallest, 0, -1):\n        if a % i == 0 and b % i == 0:\n            return i\n    return 1  # Default return if no common divisor found\n",
        "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b \"\"\"\n    if b == 0:\n        return a\n    else:\n        return greatest_common_divisor(b, a % b)\n",
        "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    if b == 0:\n        return a\n"
    ],
    "HumanEval/14": [
        "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    prefixes = []\n    \n    for i in range(len(string)):\n        prefix = string[:i+1]\n        prefixes.append(prefix)\n        \n    return prefixes\n",
        "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    prefixes = []\n    for i in range(len(string)):\n        prefix = string[:i+1]\n        prefixes.append(prefix)\n\n    return prefixes\n",
        "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    prefixes = []\n    # Step 2\n    for i in range(len(string)):\n        prefix = string[:i+1]\n        # Step 4\n        prefixes.append(prefix)\n    return prefixes\n",
        "def all_prefixes(string: str) -> List[str]:\n    prefixes = []\n    \n    for char in string:\n        prefixes.append(char)\n        \n    for i in range(1, len(string)):\n        prefixes.append(string[:i+1])\n",
        "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    prefixes = []\n    \n    for i in range(1, len(string)+1):\n        prefix = string[:i]\n        prefixes.append(prefix)\n    \n    return prefixes\n"
    ],
    "HumanEval/15": [
        "def string_sequence(n: int) -> str:\n    seq = \"0\"  # Step 1: Initialize the sequence string starting from 0\n    \n    # Step 2: Loop through numbers from 1 to n inclusive\n    for i in range(1, n + 1):\n        seq += \" \" + str(i)  # Append each number with a space delimiter\n    \n    return seq  # Step 3: Return the final sequence string\n",
        "def string_sequence(n: int) -> str:\n    sequence = ''\n    \n    for num in range(n + 1):\n        sequence += str(num) + ' '\n    \n    sequence = sequence.strip()\n    \n    return sequence\n",
        "def string_sequence(n: int) -> str:\n    result = ''\n    for i in range(n + 1):\n        result += str(i)\n        if i < n:\n            result += ' '\n    \n    return result.strip()\n",
        "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 up to n inclusive. \"\"\"\n    \n    numbers = []\n    \n    for num in range(n + 1):\n        numbers.append(str(num))\n        \n    return ' '.join(numbers)\n",
        "def string_sequence(n: int) -> str:\n    numbers = []\n    \n    for i in range(n + 1):\n        numbers.append(str(i))\n    \n    return ' '.join(numbers)\n"
    ],
    "HumanEval/16": [
        "def count_distinct_characters(string: str) -> int:\n    unique_chars = set()\n    lowercase_string = string.lower()\n    \n    for char in lowercase_string:\n        if char.isalpha():\n            unique_chars.add(char)\n    \n    return len(unique_chars)\n",
        "def count_distinct_characters(string: str) -> int:\n    distinct_chars = set()\n    \n    for char in string:\n        lowercase_char = char.lower()\n        distinct_chars.add(lowercase_char)\n    \n    return len(distinct_chars)\n",
        "def count_distinct_characters(string: str) -> int:\n    distinct_chars = set()\n\n    for char in string:\n        char_lower = char.lower()\n        distinct_chars.add(char_lower)\n\n    return len(distinct_chars)\n",
        "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n\n    # Convert the input string to lowercase\n    lowercase_string = string.lower()\n    \n    # Iterate through each character in the lowercase string\n    for char in lowercase_string:\n        # Check if the character is a letter and add it to the set\n        if char.isalpha():\n            distinct_chars.add(char)\n\n    # Return the length of the set containing unique characters\n    return len(distinct_chars)\n",
        "def count_distinct_characters(string: str) -> int:\n    unique_chars = set()\n    \n    string = string.lower()\n    \n    for char in string:\n        if char.isalpha():\n            unique_chars.add(char)\n    \n    return len(unique_chars)\n"
    ],
    "HumanEval/17": [
        "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    notes = music_string.split()\n    beats = []\n    for note in notes:\n        if note == 'o':\n            beats.append(4)\n        elif note == 'o|':\n            beats.append(2)\n        elif note == '.|':\n            beats.append(1)\n        else:\n            beats.extend([4 if n == 'o' else 2 if n == 'o|' else 1 for n in note.split('|')])    \n    return beats\n\n# Test the function with an example\nresult = parse_music('o o| .| o| o| .| .| .| .| o o')\n\n",
        "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    notes = music_string.split()\n\n    beat_values = {'o': 4, 'o|': 2, '.|': 1}\n    beats = [beat_values[note] for note in notes]\n\n    return beats\n",
        "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    notes = music_string.split()\n    \n    beat_duration = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    \n    beat_durations = []\n    for note in notes:\n        if note in beat_duration:\n            beat_durations.append(beat_duration[note])\n    \n    return beat_durations\n",
        "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    notes_list = music_string.split()\n    durations = []\n\n    for note in notes_list:\n        if note == 'o':\n            durations.append(4)\n        elif note == 'o|':\n            durations.append(2)\n        elif note == '.|':\n            durations.append(1)\n    \n    return durations\n",
        "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    notes = music_string.split()\n    \n    beat_values = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n\n    beats = [beat_values[note] for note in notes]\n\n    return beats\n"
    ],
    "HumanEval/18": [
        "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlapping cases.\"\"\"\n    \n    # Handle corner case when input string is empty\n    if not string:\n        return 0\n    \n    count = 0\n    substr_len = len(substring)\n    \n    # Count the number of occurrences of the substring in the string\n    for i in range(len(string) - substr_len + 1):\n        if string[i:i+substr_len] == substring:\n            count += 1\n            \n    return count\n",
        "def how_many_times(string: str, substring: str) -> int:\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i + len(substring)] == substring:\n            count += 1\n    return count\n",
        "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    \n    count = 0\n    \n    for i in range(len(string) - len(substring) + 1):\n        window = string[i:i + len(substring)]\n        if window == substring:\n            count += 1\n    \n    return count\n",
        "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlapping cases. \"\"\"\n    count = 0\n    \n    if string == '' or substring == '' or len(substring) > len(string):\n        return 0\n    \n    for i in range(len(string)):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    \n    return count\n\n# Testing the function\n\n\n\n\n# Additional test cases\n\n\n\n",
        "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlapping cases.\n    \"\"\"\n    count = 0\n    \n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i + len(substring)] == substring:\n            count += 1\n    \n    return count\n"
    ],
    "HumanEval/19": [
        "def sort_numbers(numbers: str) -> str:\n    number_words = numbers.split()\n    \n    number_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    \n    sorted_number_words = sorted(number_words, key=lambda x: number_map[x])\n    sorted_numbers_str = ' '.join(sorted_number_words)\n    \n    return sorted_numbers_str\n",
        "def sort_numbers(numbers: str) -> str:\n    number_words = numbers.split()\n    \n    word_to_num = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    \n    sorted_numbers = sorted(number_words, key=lambda x: word_to_num[x])\n    \n    sorted_string = ' '.join(sorted_numbers)\n    \n    return sorted_string\n",
        "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    number_list = numbers.split()\n\n    num_to_int = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n\n    int_list = [num_to_int[num] for num in number_list]\n    sorted_int_list = sorted(int_list)\n\n    int_to_num = {value: key for key, value in num_to_int.items()}\n    sorted_number_list = [int_to_num[num] for num in sorted_int_list]\n\n    sorted_numbers = ' '.join(sorted_number_list)\n\n    return sorted_numbers\n",
        "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n    number_list = numbers.split()\n\n    number_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n\n    numerical_values = [number_map[num] for num in number_list]\n    sorted_numerical_values = sorted(numerical_values)\n\n    sorted_numbers = [key for key, value in number_map.items() if value in sorted_numerical_values]\n    return ' '.join(sorted_numbers)\n",
        "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    numbers_dict = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,\n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9\n    }\n    \n    numbers_list = numbers.split()\n    sorted_numbers = sorted([numbers_dict[num] for num in numbers_list])\n    sorted_number_strings = [key for key, value in numbers_dict.items() if value in sorted_numbers]\n    \n    return ' '.join(sorted_number_strings)\n"
    ],
    "HumanEval/20": [
        "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must have at least two elements.\")\n\n    sorted_numbers = sorted(numbers)\n\n    closest_pair = None\n    closest_distance = float('inf')\n\n    for i in range(len(sorted_numbers) - 1):\n        distance = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair\n",
        "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two numbers.\")\n    \n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    for i in range(len(numbers) - 1):\n        diff = abs(numbers[i] - numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair\n",
        "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers\")\n\n    closest_pair = None\n    min_diff = float('inf')\n\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (numbers[i], numbers[j])\n\n    return tuple(sorted(closest_pair))\n",
        "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    sorted_numbers = sorted(numbers)\n    \n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    for i in range(len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i+1] - sorted_numbers[i])\n        \n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    return closest_pair\n",
        "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    \n    min_diff = float('inf')  # Initialize the smallest difference variable\n    closest_pair = ()  # Initialize the pair of closest elements\n    \n    for i in range(len(numbers) - 1):\n        num1, num2 = numbers[i], numbers[i + 1]\n        diff = abs(num1 - num2)\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (num1, num2)\n    \n    return closest_pair\n"
    ],
    "HumanEval/21": [
        "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    range_nums = max_num - min_num\n\n    rescaled_nums = [(num - min_num) / range_nums for num in numbers]\n    \n    return rescaled_nums\n",
        "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two numbers.\")\n        \n    min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n\n    rescaled_list = [(num - min_val) / range_val for num in numbers]\n\n    return rescaled_list\n",
        "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    range_values = max_num - min_num\n    rescaled_numbers = [(num - min_num) / range_values for num in numbers]\n    \n    return rescaled_numbers\n",
        "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    range_nums = max_num - min_num\n    scaled_values = [(num - min_num) / range_nums for num in numbers]\n    return scaled_values\n",
        "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    \n    rescaled = [(num - min_val) / range_val for num in numbers]\n\n    return rescaled\n"
    ],
    "HumanEval/22": [
        "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    filtered_integers = []\n    \n    for value in values:\n        if isinstance(value, int):\n            filtered_integers.append(value)\n    \n    return filtered_integers\n",
        "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    filtered_integers = []\n    \n    for value in values:\n        if isinstance(value, int):\n            filtered_integers.append(value)\n    \n    return filtered_integers\n",
        "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    integers_only = []\n    for value in values:\n        if isinstance(value, int):\n            integers_only.append(value)\n    return integers_only\n",
        "def filter_integers(values: List[Any]) -> List[int]:\n    integers = []\n    for value in values:\n        if isinstance(value, int):\n            integers.append(value)\n    return integers\n",
        "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"Filter given list of any python values only for integers\"\"\"\n    \n    filtered_integers = []\n    \n    for value in values:\n        if isinstance(value, int):\n            filtered_integers.append(value)\n    \n    return filtered_integers\n"
    ],
    "HumanEval/23": [
        "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return len(string)\n",
        "def strlen(string: str) -> int:\n    return len(string)\n",
        "def strlen(string: str) -> int:\n    return len(string)\n",
        "def strlen(string: str) -> int:\n    \"\"\"Return length of given string\"\"\"\n    return len(string)\n",
        "def strlen(string: str) -> int:\n    \"\"\"\n    Return length of given string\n    \n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return len(string)\n"
    ],
    "HumanEval/24": [
        "def largest_divisor(n: int) -> int:\n    largest_div = 1\n    for i in range(2, n):\n        if n % i == 0:\n            if i > largest_div:\n                largest_div = i\n    return largest_div\n",
        "def largest_divisor(n: int) -> int:\n    largest_divisor = 1\n\n    for i in range(2, n):\n        if n % i == 0:\n            largest_divisor = i\n\n    return largest_divisor\n",
        "def largest_divisor(n: int) -> int:\n    divisor = 1\n    \n    for i in range(2, n // 2 + 1):\n        if n % i == 0:\n            divisor = i\n    \n    return divisor\n",
        "def largest_divisor(n: int) -> int:\n    largest = 1\n  \n    for i in range(2, n // 2 + 2):\n        if n % i == 0:\n            largest = i\n\n    return largest\n",
        "def largest_divisor(n: int) -> int:\n    largest = 0\n    \n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            largest = i\n            break\n    \n    return largest\n"
    ],
    "HumanEval/25": [
        "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    factors = []\n    divisor = 2\n    \n    while n > 1:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += 1\n    \n    return factors\n",
        "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    factors = []\n    \n    # Step 1: Check for factor 2\n    while n % 2 == 0:\n        factors.append(2)\n        n //= 2\n\n    # Step 2: Check for odd primes\n    p = 3\n    while p*p <= n:\n        if n % p == 0:\n            factors.append(p)\n            n //= p\n        else:\n            p += 2\n\n    # Step 3: Add the remaining prime factor if n is not 1\n    if n > 1:\n        factors.append(n)\n\n    return factors\n",
        "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    prime_factors = []\n    \n    for i in range(2, int(n**0.5) + 1):\n        while n % i == 0:\n            prime_factors.append(i)\n            n //= i\n    \n    if n > 1:\n        prime_factors.append(n)\n    \n    return prime_factors\n",
        "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    factors = []\n    divisor = 2\n    \n    while n > 1:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += 1\n        \n    return factors\n",
        "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    factors = []  # Step 0\n    \n    p = 2  # Step 1\n\n    while p <= n**0.5:  # Step 2\n        if n % p == 0:  # Step 3\n            factors.append(p)  # Step 3\n            n //= p  # Step 3\n        else:\n            p += 1  # Step 3\n            \n    if n > 1:  # Step 4\n        factors.append(n)  # Step 4\n\n    return factors  # Step 4\n"
    ],
    "HumanEval/26": [
        "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    unique_numbers = []\n    \n    for num in numbers:\n        if num not in unique_numbers:\n            unique_numbers.append(num)\n    \n    return unique_numbers\n",
        "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    unique_numbers = []\n\n    for num in numbers:\n        if num not in unique_numbers:\n            unique_numbers.append(num)\n\n    return unique_numbers\n",
        "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    counts = {}  # Step 0: Create an empty dictionary to store the frequency of each element\n    for num in numbers:  # Step 1: Iterate through the input list and update the frequency of each element in the dictionary\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n            \n    unique_numbers = []  # Step 2: Create a new list to store the unique elements\n    for num in numbers:  # Step 3: Create a list to store elements that occur only once\n        if counts[num] == 1:\n            unique_numbers.append(num)\n            \n    return unique_numbers  # Step 4: Return the new list containing only unique elements\n",
        "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    result = []\n    seen = set()\n    \n    for num in numbers:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n    \n    return result\n",
        "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    unique_numbers = []\n    \n    for num in numbers:\n        if num not in unique_numbers:\n            unique_numbers.append(num)\n        \n    return unique_numbers\n"
    ],
    "HumanEval/27": [
        "def flip_case(string: str) -> str:\n    result = \"\"\n    for char in string:\n        if char.islower():\n            result += char.upper()\n        elif char.isupper():\n            result += char.lower()\n        else:\n            result += char\n    return result\n",
        "def flip_case(string: str) -> str:\n    flipped_string = ''\n    for char in string:\n        if char.isupper():\n            flipped_string += char.lower()\n        elif char.islower():\n            flipped_string += char.upper()\n    return flipped_string\n\n\n",
        "def flip_case(string: str) -> str:\n    flipped_string = \"\"\n    for char in string:\n        if char.isupper():\n            flipped_string += char.lower()\n        elif char.islower():\n            flipped_string += char.upper()\n    return flipped_string\n",
        "def flip_case(string: str) -> str:\n    new_string = \"\"\n    for char in string:\n        if char.islower():\n            new_string += char.upper()\n        elif char.isupper():\n            new_string += char.lower()\n        else:\n            new_string += char\n    return new_string\n",
        "def flip_case(string: str) -> str:\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char.lower()\n        elif char.islower():\n            result += char.upper()\n        else:\n            result += char\n    return result\n"
    ],
    "HumanEval/28": [
        "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    result = ''\n    for string in strings:\n        result += string\n    return result\n",
        "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    concatenated_string = ''\n    \n    for string in strings:\n        concatenated_string += string\n    \n    return concatenated_string\n",
        "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    result = ''\n    \n    for string in strings:\n        result += string\n        \n    return result\n",
        "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    result = \"\"\n    for s in strings:\n        result += s\n    return result\n",
        "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    result = \"\"\n    for s in strings:\n        result += s\n    return result\n"
    ],
    "HumanEval/29": [
        "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    result = []\n    for string in strings:\n        if string.startswith(prefix):\n            result.append(string)\n    return result\n",
        "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    filtered_strings = []\n    \n    for string in strings:\n        if string.startswith(prefix):\n            filtered_strings.append(string)\n    \n    return filtered_strings\n",
        "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    result = []\n    \n    for string in strings:\n        if string.startswith(prefix):\n            result.append(string)\n    \n    return result\n",
        "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    filtered_strings = []\n    \n    for string in strings:\n        if string.startswith(prefix):\n            filtered_strings.append(string)\n    \n    return filtered_strings\n",
        "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    result = []\n    \n    for string in strings:\n        if string.startswith(prefix):\n            result.append(string)\n    \n    return result\n"
    ],
    "HumanEval/30": [
        "def get_positive(l: list):\n    pos_nums = []\n    \n    # Iterate through the input list.\n    for num in l:\n        # Check if the number is positive.\n        if num > 0:\n            # If it is positive, add it to the new list.\n            pos_nums.append(num)\n    \n    return pos_nums\n",
        "def get_positive(l: list):\n    positive_numbers = []\n\n    for num in l:\n        if num > 0:\n            positive_numbers.append(num)\n\n    return positive_numbers\n",
        "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\"\"\"\n    \n    positive_nums = []\n    \n    for num in l:\n        if num > 0:\n            positive_nums.append(num)\n        \n    return positive_nums\n",
        "def get_positive(l: list):\n    positive_numbers = []\n\n    for num in l:\n        if num > 0:\n            positive_numbers.append(num)\n\n    return positive_numbers\n",
        "def get_positive(l: list):\n    pos_numbers = []\n    \n    for num in l:\n        if num > 0:\n            pos_numbers.append(num)\n    \n    return pos_numbers\n"
    ],
    "HumanEval/31": [
        "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n        \n    for i in range(2, math.isqrt(n) + 1):\n        if n % i == 0:\n            return False\n            \n    return True\n",
        "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    \n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    \n    return True\n",
        "import math\n\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n < 2:\n        return False\n    \n    max_divisor = math.isqrt(n) + 1\n    \n    for i in range(2, max_divisor):\n        if n % i == 0:\n            return False\n    \n    return True\n",
        "import math\n\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    \n    if n == 1:\n        return False\n    \n    if n < 2:\n        return False\n    \n    sqrt_n = int(math.sqrt(n)) + 1\n    \n    for i in range(2, sqrt_n):\n        if n % i == 0:\n            return False\n    \n    return True\n",
        "def is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\"\"\"\n    \n    if n < 2:\n        return False\n        \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True\n"
    ],
    "HumanEval/32": [
        "    if len(xs) % 2 != 0 or xs[-1] == 0:\n        raise ValueError(\"Input list xs must have an even number of coefficients \"\n                         \"and the largest non-zero coefficient.\")\n\n    degree = len(xs) // 2\n",
        "def find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero finds x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non-zero coefficient as it guarantees a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n\n    result = None\n\n    for x in range(-1000, 1001, 1):\n        x /= 10  # Adjust to step size of 0.1\n        value = poly(xs, x)\n        if abs(value) < 0.0001:\n            result = x\n            break\n\n    return result\n",
        "import math\nimport numpy as np\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef find_zero(xs: list):\n    \"\"\"\n    xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n    if len(xs) % 2 != 0 or len(xs) == 0:\n        return None\n\n    largest_non_zero_coeff = max(filter(lambda x: x != 0, xs), key=abs)\n\n    normalized_xs = [coeff / largest_non_zero_coeff for coeff in xs]\n\n    roots = np.roots(normalized_xs)\n\n    real_root = next((root for root in roots if np.isreal(root)), None)\n\n    return real_root.real if real_root else None\n",
        "import math\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef find_zero(xs: list):\n    if len(xs) % 2 != 0:\n        raise ValueError(\"List 'xs' should have an even number of coefficients.\")\n    \n    largest_non_zero = max(filter(lambda x: x != 0, xs))  # Extract largest non-zero coefficient\n    \n    # Create a new list of coefficients for a shifted polynomial\n    shifted_xs = [i / largest_non_zero for i in xs]\n    \n    for i in range(1, len(shifted_xs)):\n        if shifted_xs[-1] % i == 0:\n            factor = shifted_xs[-1] / i\n            if poly(shifted_xs, factor) == 0:\n                return factor\n",
        "import math\n\ndef find_zero(xs: list):\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The number of coefficients must be even.\")\n    if xs[-1] == 0:\n        raise ValueError(\"The largest non-zero coefficient must not be zero.\")\n    \n    def poly(x):\n        return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n    x0 = 0  # Initial guess for the zero\n    tolerance = 1e-8  # Tolerance for convergence\n    max_iterations = 100  # Maximum number of iterations\n    i = 0\n    while i < max_iterations:\n        fx0 = poly(x0)\n        if abs(fx0) < tolerance:\n            return x0\n        dfx0 = sum([i * coeff * math.pow(x0, i - 1) for i, coeff in enumerate(xs) if i > 0])\n        x0 = x0 - fx0 / dfx0\n        i += 1\n\n    raise ValueError(\"Could not find a zero within the maximum number of iterations.\")\n"
    ],
    "HumanEval/33": [
        "def sort_third(l: list):\n    result = []\n    to_sort = []\n    \n    for i, val in enumerate(l):\n        if i % 3 == 0:\n            to_sort.append(val)\n            result.append(None)  # Placeholder for values to be sorted later\n        else:\n            result.append(val)\n\n    indices_to_sort = [i for i in range(len(l)) if i % 3 == 0]\n    sorted_values = sorted(to_sort)\n\n    for i, sorted_val in zip(indices_to_sort, sorted_values):\n        result[i] = sorted_val\n\n    final_result = [result[i] if i in indices_to_sort else val for i, val in enumerate(l)]\n\n    return final_result\n",
        "def sort_third(l: list):\n    sorted_list = l.copy()\n    indices_divisible_by_three = []\n\n    for i in range(len(l)):\n        if i % 3 == 0:\n            indices_divisible_by_three.append(i)\n\n    for index in indices_divisible_by_three:\n        sorted_list[index] = sorted(l[index])\n\n    return sorted_list\n",
        "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    result = []\n    \n    for index, value in enumerate(l):\n        if index % 3 == 0:\n            sorted_value = sorted(l[index])\n            result.append(sorted_value)\n        else:\n            result.append(value)\n    \n    return result\n",
        "def sort_third(l: list):\n    sorted_list = []\n    \n    for i in range(len(l)):\n        if i % 3 == 0:\n            sorted_list.append(l[i])\n        else:\n            sorted_list.append(l[i])\n\n    return sorted_list\n",
        "def sort_third(l: list):\n    result = []\n    \n    for index, value in enumerate(l):\n        if index % 3 == 0:\n            sorted_value = sorted(l[index])\n            result.append(sorted_value)\n        else:\n            result.append(value)\n            \n    return result\n"
    ],
    "HumanEval/34": [
        "def unique(l: list):\n    unique_set = set(l)\n    unique_list = list(unique_set)\n    return sorted(unique_list)\n",
        "def unique(l: list):\n    unique_set = set(l)\n    unique_sorted = sorted(unique_set)\n    return unique_sorted\n",
        "def unique(l: list):\n    unique_set = set(l)\n    unique_list = list(unique_set)\n    unique_list.sort()\n    return unique_list\n",
        "def unique(l: list):\n    unique_set = set(l)\n    unique_list = list(unique_set)\n    unique_list.sort()\n    return unique_list\n",
        "def unique(l: list):\n    unique_elements = set(l)\n    unique_elements_sorted = sorted(unique_elements)\n    return unique_elements_sorted\n"
    ],
    "HumanEval/35": [
        "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    \n    max_num = l[0]\n    \n    for num in l[1:]:\n        if num > max_num:\n            max_num = num\n    \n    return max_num\n",
        "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\"\"\"\n    \n    if not l:\n        return None\n    \n    max_elem = l[0]\n    \n    for elem in l[1:]:\n        if elem > max_elem:\n            max_elem = elem\n    \n    return max_elem\n",
        "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\"\"\"\n    max_num = l[0]\n    \n    for num in l[1:]:\n        if num > max_num:\n            max_num = num\n    \n    return max_num\n",
        "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\"\"\"\n    if not l:\n        return None  # return None for an empty list\n    \n    max_num = l[0]\n    for num in l[1:]:\n        if num > max_num:\n            max_num = num\n    \n    return max_num\n",
        "def max_element(l: list):\n    max_val = l[0]\n    \n    for val in l[1:]:\n        if val > max_val:\n            max_val = val\n    \n    return max_val\n"
    ],
    "HumanEval/36": [
        "def fizz_buzz(n: int):\n    count = 0\n    \n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            if '7' in str(i):\n                count += 1\n                \n    return count\n",
        "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            if '7' in str(i):\n                count += 1\n    return count\n",
        "def fizz_buzz(n: int):\n    count = 0  # Step 0\n    \n    for num in range(1, n):  # Step 1\n        if num % 11 == 0 or num % 13 == 0:  # Step 2\n            if '7' in str(num):  # Step 3\n                count += 1  # Step 4\n    \n    return count  # Step 6\n",
        "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    \n    def contains_digit_7(number: int) -> bool:\n        return '7' in str(number)\n\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            if contains_digit_7(num):\n                count += 1\n\n    return count\n",
        "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count\n"
    ],
    "HumanEval/37": [
        "def sort_even(l: list):\n    l_sorted = l.copy()\n    even_values = sorted(l_sorted[::2])\n    l_sorted[::2] = even_values\n    return l_sorted\n",
        "def sort_even(l: list):\n    sorted_even_elements = []  # Step 0: Create a new list to store the sorted even elements\n    \n    for index, element in enumerate(l):  # Step 1: Iterate over the indices and elements of the original list\n        if index % 2 == 0:  # Step 2: If the index is even\n            sorted_even_elements.append(element)  # Add the element to the sorted_even_elements list\n    \n    sorted_even_elements.sort()  # Step 3: Sort the elements in the sorted_even_elements list\n\n    index_sorted = 0\n    for index, element in enumerate(l):  # Iterating over the indices and elements of the original list again\n        if index % 2 == 0:  # If the index is even\n            l[index] = sorted_even_elements[index_sorted]  # Replace the element with the sorted element\n            index_sorted += 1\n\n    return l  # Step 5: Return the modified list\n\n# Testing the final implementation\n\n\n",
        "def sort_even(l: list):\n    odd_indices = l[::2]\n    even_indices = sorted(l[1::2])\n    return [val for pair in zip(odd_indices, even_indices) for val in pair]\n",
        "def sort_even(l: list):\n    sorted_even_vals = []  # Step 0\n\n    for idx, val in enumerate(l):  # Step 1\n        if idx % 2 == 1:  # Step 2\n            sorted_even_vals.append(val)  # Step 2\n        else:  # Step 3\n            sorted_even_vals.append(sorted(l[:idx+1]))  # Step 3\n\n    return sorted_even_vals  # Step 4\n",
        "def sort_even(l: list):\n    l_copy = l.copy()\n\n    even_indices = [l_copy[i] for i in range(0, len(l_copy), 2)]\n    even_indices.sort()\n\n    for i in range(0, len(l_copy), 2):\n        l_copy[i] = even_indices[i // 2]\n\n    return l_copy\n"
    ],
    "HumanEval/38": [
        "def decode_cyclic(s: str):\n    \"\"\"\n    Takes an input string encoded with encode_cyclic function and returns the decoded string.\n    \n    Parameters:\n    s (str): The encoded string to be decoded.\n    \n    Returns:\n    str: The decoded string.\n    \"\"\"\n    \n    groups = [s[i:i+3] for i in range(0, len(s), 3)]\n    decoded_groups = [(group[2] + group[:2]) if len(group) == 3 else group for group in groups]\n    return \"\".join(decoded_groups)\n",
        "def decode_cyclic(s: str):\n    groups = [s[i:i+3] for i in range(0, len(s), 3]\n    \n    decoded_groups = [(group[-1] + group[:2]) if len(group) == 3 else group for group in groups]\n    \n    decoded_string = \"\".join(decoded_groups)\n    \n    return decoded_string\n",
        "def encode_cyclic(s: str):\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\ndef decode_cyclic(s: str):\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    decoded_groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(decoded_groups)\n",
        "def decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    # Split the input string into groups of three characters\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n\n    # Reverse the cyclic operation for each group to decode it\n    decoded_groups = [''.join([group[2], group[0], group[1]]) if len(group) == 3 else group for group in groups]\n\n    # Join the decoded groups to form the decoded string\n    decoded_string = ''.join(decoded_groups)\n    \n    return decoded_string\n",
        "def decode_cyclic(s: str):\n    \"\"\"\n    Takes as input a string encoded with encode_cyclic function. Returns the decoded string.\n    \"\"\"\n    groups = [s[i:i+3] for i in range(0, len(s), 3)]\n    decoded_groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    decoded_string = \"\".join(decoded_groups)\n    return decoded_string\n"
    ],
    "HumanEval/39": [
        "def is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    def generate_fibonacci():\n        a, b = 0, 1\n        yield a\n        yield b\n        while True:\n            a, b = b, a + b\n            yield b\n\n    fibonacci_gen = generate_fibonacci()\n    count = 0\n    while count < n:\n        fib_num = next(fibonacci_gen)\n        if is_prime(fib_num):\n            count += 1\n\n    return fib_num\n",
        "def is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef generate_fibonacci(n: int) -> int:\n    if n <= 0:\n        return 0\n    a, b = 0, 1\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b\n\ndef prime_fib(n: int) -> int:\n    count = 0\n    num = 1\n    while count < n:\n        num += 1\n        if is_prime(num) and generate_fibonacci(num) == num:\n            count += 1\n    return num\n",
        "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int):\n    count = 0\n    a, b = 0, 1\n    while count < n:\n        a, b = b, a + b\n        if is_prime(a):\n            count += 1\n    return a\n",
        "def is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef generate_fibonacci(limit: int):\n    fibonacci = [0, 1]\n    while fibonacci[-1] + fibonacci[-2] < limit:\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    return fibonacci\n",
        "import math\n\ndef is_prime(n):\n    \"\"\"\n    Check if a number is prime.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n"
    ],
    "HumanEval/40": [
        "def triples_sum_to_zero(l: list):\n    sorted_list = sorted(l)\n    \n    for i in range(len(sorted_list)):\n        left = i + 1\n        right = len(sorted_list) - 1\n        \n        while left < right:\n            current_sum = sorted_list[i] + sorted_list[left] + sorted_list[right]\n            if current_sum == 0:\n                return True\n            elif current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n    \n    return False\n",
        "def triples_sum_to_zero(l: list):\n    l.sort()\n    n = len(l)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            total = l[i] + l[left] + l[right]\n            if total == 0:\n                return True\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return False\n",
        "def triples_sum_to_zero(l: list):\n    n = len(l)\n\n    l.sort()\n\n    for i in range(n):\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            if l[i] + l[left] + l[right] == 0:\n                return True\n            elif l[i] + l[left] + l[right] < 0:\n                left += 1\n            else:\n                right -= 1\n\n    return False\n",
        "def triples_sum_to_zero(l: list):\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                elem1 = l[i]\n                elem2 = l[j]\n                elem3 = l[k]\n                if elem1 + elem2 + elem3 == 0:\n                    return True\n    return False\n",
        "def triples_sum_to_zero(l: list):\n    from itertools import combinations\n    \n    for triple in combinations(l, 3):\n        if len(set(triple)) == 3 and sum(triple) == 0:\n            return True\n    \n    return False\n"
    ],
    "HumanEval/41": [
        "return collisions\n",
        "def car_race_collision(n: int):\n    left_to_right = [i for i in range(n)]  # Initialize positions of cars moving left to right\n    right_to_left = [i for i in range(2 * n - 1, n - 1, -1)]  # Initialize positions of cars moving right to left\n    collisions = 0  # Initialize collision counter\n\n    for pos_lr, pos_rl in zip(left_to_right, right_to_left):\n        if pos_lr >= pos_rl:  # Check for overlap of car positions\n            collisions += 1  # Increment collision counter if a collision occurs\n\n    return collisions  # Return the total number of collisions\n",
        "def car_race_collision(n: int):\n    total_collisions = n * n\n    return total_collisions\n",
        "def car_race_collision(n: int):\n    total_collisions = n * (n - 1) // 2\n    return total_collisions\n",
        "def car_race_collision(n: int):\n    collision_count = 0\n\n    for i in range(1, n + 1):\n        collision_count += i\n        \n    return collision_count\n"
    ],
    "HumanEval/42": [
        "def incr_list(l: list):\n    result = []\n    \n    for num in l:\n        result.append(num + 1)\n    \n    return result\n",
        "def incr_list(l: list):\n    new_list = []\n\n    for num in l:\n        new_list.append(num + 1)\n    \n    return new_list\n",
        "def incr_list(l: list):\n    result = []\n    \n    for num in l:\n        result.append(num + 1)\n    \n    return result\n",
        "def incr_list(l: list):\n    result = []\n\n    for num in l:\n        result.append(num + 1)\n    \n    return result\n",
        "def incr_list(l: list):\n    result = []\n    \n    for num in l:\n        result.append(num + 1)\n        \n    return result\n"
    ],
    "HumanEval/43": [
        "def pairs_sum_to_zero(l):\n    seen_numbers = set()\n\n    for num in l:\n        if -num in seen_numbers:\n            return True\n        seen_numbers.add(num)\n\n    return False\n",
        "def pairs_sum_to_zero(l):\n    seen_numbers = set()\n\n    for num in l:\n        if -num in seen_numbers:\n            return True\n        seen_numbers.add(num)\n\n    return False\n",
        "def pairs_sum_to_zero(l):\n    seen = set()\n    \n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    \n    return False\n",
        "def pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    \"\"\"\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False\n",
        "def pairs_sum_to_zero(l):\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False\n"
    ],
    "HumanEval/44": [
        "def change_base(x: int, base: int):\n    \"\"\"\n    Change numerical base of input number x to base.\n    Return string representation after the conversion.\n    Base numbers are less than 10.\n    \"\"\"\n    result = \"\"\n    while x > 0:\n        remainder = x % base\n        result = str(remainder) + result\n        x //= base\n    return result\n",
        "def change_base(x: int, base: int):\n    if x == 0:\n        return '0'\n    \n    result = ''\n    while x > 0:\n        remainder = x % base\n        result = str(remainder) + result\n        x = x // base\n    \n    return result\n",
        "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n    # Step 0: Validate base\n    if base >= 10:\n        return \"Base should be less than 10.\"\n\n    # Step 1: Initialize an empty string to store the converted result\n    result = \"\"\n    \n    # Step 2: Convert the number to the new base\n    while x > 0:\n        remainder = x % base\n        result = str(remainder) + result  # Build the converted number in reverse order\n        x //= base\n\n    return result\n",
        "def change_base(x: int, base: int):\n    if base >= 10:\n        return \"Base must be less than 10.\"\n    \n    result = \"\"\n    \n    while x > 0:\n        remainder = x % base\n        x = x // base\n        \n        result = str(remainder) + result\n    \n    return result\n",
        "def change_base(x: int, base: int):\n    if base >= 10:\n        raise ValueError(\"Base should be less than 10\")\n\n    result = \"\"\n    while x > 0:\n        remainder = x % base\n        result += str(remainder)\n        x = x // base\n\n    return result[::-1]\n"
    ],
    "HumanEval/45": [
        "def triangle_area(a, h):\n    \"\"\"Given length of a side and height, return the area of a triangle.\"\"\"\n    \n    # Calculate the area of the triangle\n    area = (a * h) / 2\n    \n    return area\n",
        "def triangle_area(a, h):\n    \"\"\"\n    Given length of a side and height, return the area of a triangle.\n\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    area = 0.5 * a * h\n    return area\n",
        "def triangle_area(a, h):\n    return 0.5 * a * h\n\n# Testing the function\n\n",
        "def triangle_area(a, h):\n    # Step 1: Calculate the area of the triangle\n    area = 0.5 * a * h\n    return area\n",
        "def triangle_area(a, h):\n    return 0.5 * a * h\n"
    ],
    "HumanEval/46": [
        "def fib4(n: int):\n    fib4_nums = [0, 0, 2, 0]\n    \n    for i in range(4, n):\n        next_num = sum(fib4_nums)\n        fib4_nums.append(next_num)\n    \n    return fib4_nums[n-1]\n",
        "    return fib4_sequence[n]\n",
        "def fib4(n: int):\n    if n < 4:\n        return 0\n    else:\n        fib4_sequence = [0, 0, 2, 0]  # Initial sequence\n\n        for i in range(4, n+1):\n            next_element = fib4_sequence[-1] + fib4_sequence[-2] + fib4_sequence[-3] + fib4_sequence[-4]\n            fib4_sequence = fib4_sequence[1:] + [next_element]\n\n        return fib4_sequence[-1]\n",
        "return fib4_sequence[n]\n",
        "def fib4(n: int):\n    # Step 1: Initialize the list to store the first 4 elements of the Fib4 sequence\n    fib4_list = [0, 0, 2, 0]\n\n    # Step 2: Loop to compute the next elements of the Fib4 sequence\n    for i in range(4, n + 1):\n        fib4_next = fib4_list[i-1] + fib4_list[i-2] + fib4_list[i-3] + fib4_list[i-4]\n        fib4_list.append(fib4_next)\n\n    # Step 3: Return the n-th element of the Fib4 sequence\n    return fib4_list[n]\n\n# Test cases\n\n\n\n"
    ],
    "HumanEval/47": [
        "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    l.sort()\n    length = len(l)\n    is_odd = length % 2 != 0\n    \n    if is_odd:\n        return l[length // 2]\n",
        "def median(l: list):\n    if not l:\n        return None\n    \n    l.sort()\n    n = len(l)\n    \n    if n % 2 == 1:\n        return l[n // 2]\n    else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2\n",
        "def median(l: list):\n    if not l:  # Check if the list is empty\n        return None\n    \n    sorted_list = sorted(l)  # Sort the list\n    \n    n = len(sorted_list)\n    if n % 2 != 0:  # If the length of the list is odd\n        return sorted_list[n // 2]\n    # If the length of the list is even\n    return (sorted_list[n // 2 - 1] + sorted_list[n // 2]) / 2\n",
        "def median(l: list) -> float:\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    sorted_list = sorted(l)\n    length = len(sorted_list)\n    \n    if length % 2 == 1:\n        return sorted_list[length // 2]\n    else:\n        mid1 = sorted_list[length // 2 - 1]\n        mid2 = sorted_list[length // 2]\n        return (mid1 + mid2) / 2\n",
        "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    l.sort()\n        \n    n = len(l)\n    is_even = (n % 2 == 0)\n    \n    if is_even:\n        mid1 = l[n // 2]\n        mid2 = l[n // 2 - 1]\n        return (mid1 + mid2) / 2\n    else:\n        return l[n // 2]\n"
    ],
    "HumanEval/48": [
        "def is_palindrome(text: str):\n    if len(text) <= 1:\n        return True\n    \n    if text == text[::-1]:\n        return True\n    else:\n        return False\n",
        "def is_palindrome(text: str):\n    return text == text[::-1]\n",
        "def is_palindrome(text: str):\n    pointer1 = 0\n    pointer2 = len(text) - 1\n\n    while pointer1 < pointer2:\n        if text[pointer1] != text[pointer2]:\n            return False\n        \n        pointer1 += 1\n        pointer2 -= 1\n    \n    return True\n",
        "def is_palindrome(text: str):\n    text = text.replace(\" \", \"\")\n    text = text.lower()\n    return text == text[::-1]\n",
        "def is_palindrome(text: str):\n    if not text:\n        return True\n    return text == text[::-1]\n"
    ],
    "HumanEval/49": [
        "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    result = pow(2, n)\n    \n    return result % p\n",
        "def modp(n: int, p: int):\n    return pow(2, n) % p\n",
        "def modp(n: int, p: int):\n    power_of_2 = 2 ** n\n    result = power_of_2 % p\n    return result\n",
        "def modp(n: int, p: int):\n    power = 2 ** n\n    result = power % p\n    return result\n",
        "def modp(n: int, p: int):\n    result = 2**n\n    return result % p\n"
    ],
    "HumanEval/50": [
        "def encode_shift(s: str):\n    \"\"\"\n    Returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr((ord(ch) - ord(\"a\") - 5) % 26 + ord(\"a\") if ch.islower() else ch for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    Takes as input a string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    decoded_chars = []\n    \n    for ch in s:\n        original_ch = chr((ord(ch) + 5 - ord(\"a\")) % 26 + ord(\"a\") if ch.islower() else ch)\n        decoded_chars.append(original_ch)\n    \n    return \"\".join(decoded_chars)\n",
        "def encode_shift(s: str):\n    \"\"\"\n    Returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([shift_char(ch, 5) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    Takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([shift_char(ch, -5) for ch in s])\n",
        "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    decoded_str = \"\"\n    for ch in s:\n        if ch.isalpha():\n            decoded_char = chr((ord(ch) - ord(\"a\") - 5) % 26 + ord(\"a\"))\n            decoded_str += decoded_char\n        else:\n            decoded_str += ch\n    return decoded_str\n",
        "def decode_shift(s: str):\n    decoded = \"\"\n    for ch in s:\n        decoded += chr(((ord(ch) - 5 - ord('a') + 26) % 26) + ord('a'))\n    \n    return decoded\n",
        "def decode_shift(s: str):\n    \"\"\"\n    Decodes a string encoded by shifting every character by 5 in the alphabet.\n    \"\"\"\n    decoded_str = \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n    return decoded_str\n"
    ],
    "HumanEval/51": [
        "def remove_vowels(text):\n    result = ''\n    \n    if not text:\n        return result\n    \n    vowels = 'aeiouAEIOU'\n    \n    for char in text:\n        if char not in vowels:\n            result += char\n    \n    return result\n",
        "def remove_vowels(text):\n    result = \"\"\n    for char in text:\n        if char.lower() not in 'aeiou':\n            result += char\n    return result\n",
        "def remove_vowels(text):\n    result = \"\"\n    for char in text:\n        if char.lower() not in ['a', 'e', 'i', 'o', 'u']:\n            result += char\n    return result\n",
        "def remove_vowels(text):\n    result = \"\"\n    vowels = 'aeiouAEIOU'\n    \n    for char in text:\n        if char not in vowels:\n            result += char\n    \n    return result\n",
        "def remove_vowels(text):\n    result = ''\n    vowels = 'aeiouAEIOU'\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result\n"
    ],
    "HumanEval/52": [
        "def below_threshold(l: list, t: int):\n    for num in l:\n        if num >= t:\n            return False\n    return True\n",
        "def below_threshold(l: list, t: int):\n    for num in l:\n        if num >= t:\n            return False\n    return True\n",
        "def below_threshold(l: list, t: int):\n    for num in l:\n        if num >= t:\n            return False\n    return True\n",
        "def below_threshold(l: list, t: int):\n    for num in l:\n        if num > t:\n            return False\n    return True\n",
        "def below_threshold(l: list, t: int):\n    for num in l:\n        if num >= t:\n            return False\n    return True\n"
    ],
    "HumanEval/53": [
        "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    \"\"\"\n    return x + y\n",
        "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\n",
        "def add(x: int, y: int):\n    return x + y\n",
        "def add(x: int, y: int):\n    return x + y\n\n# Doctests\n\"\"\"\n>>> add(2, 3)\n5\n>>> add(5, 7)\n12\n\"\"\"\n",
        "def add(x: int, y: int):\n    return x + y\n"
    ],
    "HumanEval/54": [
        "def same_chars(s0: str, s1: str):\n    if len(s0) != len(s1):\n        return False\n    \n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    return set_s0 == set_s1\n",
        "def same_chars(s0: str, s1: str):\n    return sorted(set(s0)) == sorted(set(s1))\n",
        "def same_chars(s0: str, s1: str):\n    s0 = ''.join([char for char in s0 if char.isalpha()])\n    s1 = ''.join([char for char in s1 if char.isalpha()])\n    \n    sorted_s0 = sorted(s0)\n    sorted_s1 = sorted(s1)\n    \n    return sorted_s0 == sorted_s1\n",
        "def same_chars(s0: str, s1: str):\n    return set(s0) == set(s1)\n",
        "def same_chars(s0: str, s1: str):\n    char_count_s0 = {}\n    char_count_s1 = {}\n    \n    for char in s0:\n        char_count_s0[char] = char_count_s0.get(char, 0) + 1\n    \n    for char in s1:\n        char_count_s1[char] = char_count_s1.get(char, 0) + 1\n        \n    return char_count_s0 == char_count_s1\n"
    ],
    "HumanEval/55": [
        "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 0 or n == 1:\n        return n\n    \n    a, b = 0, 1\n    \n    for _ in range(2, n + 1):\n        a, b = b, a + b\n        \n    return b\n",
        "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n in (0, 1):\n        return n\n\n    a, b = 0, 1\n\n    for _ in range(2, n):\n        temp = a + b\n        a = b\n        b = temp\n\n    return b\n",
        "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n in (0, 1):\n        return n\n    \n    a, b = 0, 1\n    \n    for _ in range(2, n):\n        a, b = b, a + b\n        \n    return b\n",
        "def fib(n: int):\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    \n    for _ in range(2, n + 1):\n        a, b = b, a + b\n        \n    return b\n",
        "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    a, b = 0, 1\n\n    for _ in range(n - 1):\n        a, b = b, a + b\n\n    return b\n"
    ],
    "HumanEval/56": [
        "def correct_bracketing(brackets: str):\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack:\n                return False\n            stack.pop()\n\n    return not stack\n",
        "def correct_bracketing(brackets: str):\n    opening_count = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            opening_count += 1\n        elif bracket == \">\":\n            opening_count -= 1\n        if opening_count < 0:\n            return False\n    \n    return opening_count == 0\n",
        "def correct_bracketing(brackets: str):\n    balance = 0\n   \n    for bracket in brackets:\n        if bracket == \"<\":\n            balance += 1\n        elif bracket == \">\":\n            balance -= 1\n            if balance < 0:\n                return False\n\n    return balance == 0\n",
        "def correct_bracketing(brackets: str):\n    count = 0\n    \n    for bracket in brackets:\n        if bracket == '<':\n            count += 1\n        elif bracket == '>':\n            if count <= 0:\n                return False\n            count -= 1\n    \n    return count == 0\n",
        "def correct_bracketing(brackets: str):\n    count = 0\n    \n    for bracket in brackets:\n        if bracket == '<':\n            count += 1\n        elif bracket == '>':\n            count -= 1\n            if count < 0:\n                return False\n    \n    return count == 0\n"
    ],
    "HumanEval/57": [
        "def monotonic(l: list):\n    increasing = True\n    decreasing = True\n    \n    for i in range(1, len(l)):\n        if l[i] <= l[i-1]:\n            increasing = False\n        if l[i] >= l[i-1]:\n            decreasing = False\n    \n    return increasing or decreasing\n",
        "def monotonic(l: list):\n    is_increasing = all(l[i] <= l[i+1] for i in range(len(l) - 1))\n    is_decreasing = all(l[i] >= l[i+1] for i in range(len(l) - 1))\n\n    return is_increasing or is_decreasing\n",
        "def monotonic(l: list):\n    increasing = all(l[i] <= l[i + 1] for i in range(len(l) - 1))\n    decreasing = all(l[i] >= l[i + 1] for i in range(len(l) - 1))\n    \n    if increasing or decreasing:\n        return True\n    return False\n",
        "def monotonic(l: list):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\"\"\"\n    \n    # Step 0: Check if the list is empty\n    if not l:\n        return True\n    \n    # Step 1.1: Check if the list is strictly sorted in increasing order\n    is_increasing = all(l[i] < l[i+1] for i in range(len(l) - 1))\n    \n    # Step 1.2: Check if the list is strictly sorted in decreasing order\n    is_decreasing = all(l[i] > l[i+1] for i in range(len(l) - 1))\n\n    # Step 2: Return True if either strictly increasing or strictly decreasing\n    return is_increasing or is_decreasing\n",
        "def monotonic(lst: list):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\"\"\"\n    return all(lst[i] <= lst[i + 1] for i in range(len(lst) - 1)) or all(lst[i] >= lst[i + 1] for i in range(len(lst) - 1)\n"
    ],
    "HumanEval/58": [
        "def common(l1: list, l2: list):\n    common_elements = set(l1) & set(l2)\n    unique_sorted_common_elements = sorted(list(common_elements))\n    return unique_sorted_common_elements\n",
        "def common(l1: list, l2: list):\n    unique_set1 = set(l1)\n    unique_set2 = set(l2)\n    \n    common_elements = unique_set1.intersection(unique_set2)\n    sorted_common_elements = sorted(common_elements)\n    \n    return sorted_common_elements\n",
        "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    \n    result = []\n    \n    for el in l1:\n        if el in l2 and el not in result:\n            result.append(el)\n    \n    return sorted(result)\n",
        "def common(l1: list, l2: list):\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    common_elements = set1.intersection(set2)\n    \n    result = sorted(list(common_elements))\n    \n    return result\n",
        "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n\n    set1 = set(l1)\n    set2 = set(l2)\n\n    common_elements = sorted(list(set1.intersection(set2)))\n\n    return common_elements\n"
    ],
    "HumanEval/59": [
        "#!/usr/bin/env python3\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef largest_prime_factor(n: int):\n    largest_prime = 2\n    i = 2\n    while i <= n:\n        if n % i == 0:\n            n //= i\n            if is_prime(n):\n                largest_prime = n\n        else:\n            i += 1\n    return largest_prime\n\n\n\n",
        "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef largest_prime_factor(n: int):\n    largest_prime = 2  # Step 0\n    # Step 1\n    for i in range(2, math.isqrt(n) + 1):  # Step 2 corrected\n        if n % i == 0:\n            # Step 3\n            if is_prime(i):\n                # Step 4\n                largest_prime = i  # Update largest_prime\n    return largest_prime  # Step 5\n",
        "def largest_prime_factor(n: int):\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n\n\n# Test cases\nresult1 = largest_prime_factor(13195)\nresult2 = largest_prime_factor(2048)\n\nresult1, result2\n",
        "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef largest_prime_factor(n: int):\n    prime_factors = []\n    \n    # Iterate from 2 to n // 2\n    for i in range(2, n // 2 + 1):\n        if n % i == 0 and is_prime(i):\n            prime_factors.append(i)\n    \n    # Include n if n is prime\n    if is_prime(n):\n        prime_factors.append(n)\n    \n    # Find the largest prime factor\n    largest_prime = max(prime_factors)\n    \n    return largest_prime\n",
        "def is_prime(number):\n    if number < 2:\n        return False\n    for i in range(2, int(number ** 0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef largest_prime_factor(n: int):\n    factor = 2\n\n    while factor < n:\n        if n % factor == 0:\n            if is_prime(factor):\n                n //= factor\n            else:\n                factor += 1\n        else:\n            factor += 1\n\n    return n\n"
    ],
    "HumanEval/60": [
        "def sum_to_n(n: int):\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\"\"\"\n    sum_numbers = 0\n    \n    for i in range(1, n+1):\n        sum_numbers += i\n        \n    return sum_numbers\n",
        "def sum_to_n(n: int):\n    total = 0\n    for i in range(1, n+1):\n        total += i\n    return total\n",
        "def sum_to_n(n: int):\n    total_sum = 0\n\n    for i in range(1, n+1):\n        total_sum += i\n\n    return total_sum\n",
        "def sum_to_n(n: int):\n    total_sum = 0\n    \n    for i in range(1, n + 1):\n        total_sum += i\n    \n    return total_sum\n",
        "def sum_to_n(n: int):\n    total = 0\n    for i in range(1, n+1):\n        total += i\n    return total\n"
    ],
    "HumanEval/61": [
        "def correct_bracketing(brackets: str):\n    \"\"\"Check if every opening bracket has a corresponding closing bracket.\"\"\"\n    \n    count = 0  # Variable to keep track of the balance of brackets\n\n    for bracket in brackets:  # Iterate over each character in the brackets string\n        if bracket == \"(\":  # If the character is an opening bracket\n            count += 1  # Increment the count by 1\n        else:  # If the character is a closing bracket\n            if count > 0:  # If there are corresponding opening brackets\n                count -= 1  # Decrement the count by 1\n            else:  # If there is a closing bracket without an opening bracket\n                return False  # Return False\n\n    return count == 0\n",
        "def correct_bracketing(brackets: str):\n    stack = []\n    \n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if not stack:\n                return False\n            stack.pop()\n    \n    return not stack\n\n# Testing the function with test cases\n\n\n\n\n",
        "def correct_bracketing(brackets: str):\n    stack = []\n    \n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if not stack:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n",
        "def correct_bracketing(brackets: str):\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append('(')\n        elif bracket == ')' and len(stack) == 0:\n            return False\n        elif bracket == ')' and len(stack) > 0:\n            stack.pop()\n    \n    return len(stack) == 0\n",
        "def correct_bracketing(brackets: str):\n    stack = []\n    \n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                return False\n    \n    return len(stack) == 0\n"
    ],
    "HumanEval/62": [
        "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    derivatives = []\n    for i in range(1, len(xs)):\n        derivatives.append(xs[i] * i)\n\n    return derivatives\n",
        "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    derivative_coeffs = []\n    \n    for i in range(1, len(xs)):\n        derivative_coeffs.append(xs[i] * i)\n        \n    return derivative_coeffs\n",
        "def derivative(xs: list):\n    \"\"\" \n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    \n    derivative_coeffs = []\n\n    for power, coefficient in enumerate(xs[1:], start=1):\n        derivative_coeffs.append(coefficient * power)\n\n    return derivative_coeffs\n",
        "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n\n    deriv_coefficients = []\n    \n    for i in range(1, len(xs)):\n        derivative_coefficient = i * xs[i]\n        deriv_coefficients.append(derivative_coefficient)\n    \n    return deriv_coefficients\n",
        "def derivative(xs: list):\n    derivative_xs = []\n    for i in range(1, len(xs)):\n        derivative_coefficient = xs[i] * i\n        derivative_xs.append(derivative_coefficient)\n    return derivative_xs\n"
    ],
    "HumanEval/63": [
        "def fibfib(n: int):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n",
        "def fibfib(n: int):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n",
        "def fibfib(n: int):\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n",
        "def fibfib(n: int):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    n_minus_3, n_minus_2, n_minus_1 = 0, 0, 1\n\n    if n in [0, 1, 2]:\n        return n_minus_1\n\n    for i in range(3, n + 1):\n        fib_n = n_minus_1 + n_minus_2 + n_minus_3\n        n_minus_3, n_minus_2, n_minus_1 = n_minus_2, n_minus_1, fib_n\n\n    return fib_n\n",
        "# Function for calculating the FibFib number sequence\ndef fibfib(n: int):\n    # Base cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n\n    # Recursive step\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n"
    ],
    "HumanEval/64": [
        "def vowels_count(s):\n    count = 0\n\n    for char in s:\n        if char.lower() in ['a', 'e', 'i', 'o', 'u']:\n            count += 1\n        elif char.lower() == 'y' and s[-1].lower() == 'y':\n            count += 1\n\n    return count\n",
        "def vowels_count(s):\n    count = 0\n    for i, char in enumerate(s):\n        if char in ['a', 'e', 'i', 'o', 'u']:\n            count += 1\n        if char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count\n",
        "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. \n    Here, 'y' is also a vowel, but only when it is at the end of the given word.\n    \n    :param s: A string representing a word.\n    :return: The number of vowels in the given word.\n    \"\"\"\n    vowel_count = 0\n    \n    for char in s:\n        if char.lower() in ['a', 'e', 'i', 'o', 'u']:\n            vowel_count += 1\n\n    return vowel_count\n",
        "def vowels_count(s):\n    vowels = set('aeiou')\n    count = 0\n    for i, char in enumerate(s):\n        if char.lower() in vowels or (char.lower() == 'y' and i == len(s) - 1):\n            count += 1\n    return count\n",
        "def vowels_count(s):\n    count = 0\n    \n    for i, char in enumerate(s):\n        if char.lower() in ['a', 'e', 'i', 'o', 'u']:\n            \n            if char.lower() == 'y' and i == len(s) - 1:\n                count += 1\n            elif char.lower() != 'y':\n                count += 1\n    \n    return count\n"
    ],
    "HumanEval/65": [
        "def circular_shift(x, shift):\n    x_str = str(x)\n    num_digits = len(x_str)\n    effective_shift = shift % num_digits\n    shifted_num = x_str[-effective_shift:] + x_str[:-effective_shift]\n    \n    if effective_shift == 0 or effective_shift == num_digits:\n        return x_str[::-1]\n    else:\n        return shifted_num\n",
        "def circular_shift(x, shift):\n    x_str = str(x)\n    num_digits = len(x_str)\n    \n    if shift > num_digits:\n        return x_str[::-1]\n    \n    return x_str[num_digits - shift:] + x_str[:num_digits - shift]\n\n# Test the implementation\n\n\n",
        "def circular_shift(x, shift):\n    x_str = str(x)\n    num_digits = len(x_str)\n    \n    if shift > num_digits:\n        return x_str[::-1]\n    \n    rotated_str = x_str[num_digits - shift:] + x_str[:num_digits - shift]\n    return rotated_str\n",
        "def circular_shift(x, shift):\n    x_str = str(x)\n    num_digits = len(x_str)\n    effective_shift = shift % num_digits\n    \n    if effective_shift == 0:\n        return x_str\n\n    new_str = x_str[-effective_shift:] + x_str[:-effective_shift]\n    return new_str\n",
        "def circular_shift(x, shift):\n    x_str = str(x)\n    length_of_string = len(x_str)\n    \n    if shift == length_of_string:\n        return x_str[::-1]\n    \n    # Continue with the remaining steps...\n"
    ],
    "HumanEval/66": [
        "def digitSum(s):\n    total_sum = 0\n    \n    for char in s:\n        if char.isupper():\n            total_sum += ord(char)\n    \n    return total_sum\n",
        "def digitSum(s):\n    total_sum = 0\n    \n    for char in s:\n        if char.isupper():\n            total_sum += ord(char)\n            \n    return total_sum\n",
        "def digitSum(s):\n    total_sum = 0\n    for char in s:\n        if char.isupper():\n            total_sum += ord(char)\n    return total_sum\n",
        "def digitSum(s):\n    total_sum = 0\n\n    for char in s:\n        if char.isupper():\n            total_sum += ord(char)\n\n    return total_sum\n",
        "def digitSum(s):\n    sum_ascii = 0\n\n    for char in s:\n        if char.isupper():\n            sum_ascii += ord(char)\n\n    return sum_ascii\n"
    ],
    "HumanEval/67": [
        "def fruit_distribution(s, n):\n    # Step 1: Parse the input string to extract the number of apples and oranges\n    apples_str, oranges_str = s.split(\" and \")\n    apples_count = int(apples_str.split()[0])\n    oranges_count = int(oranges_str.split()[0])\n    \n    # Step 2: Calculate the number of mango fruits\n    mango_count = n - apples_count - oranges_count\n    \n    return mango_count\n",
        "def fruit_distribution(s, n):\n    numbers = [int(num) for num in s.split() if num.isdigit()]\n    apples = numbers[0]\n    oranges = numbers[1]\n    \n    mango = n - apples - oranges\n    \n    if mango < 0:\n        mango = 0\n\n    return mango\n",
        "def fruit_distribution(s, n):\n    nums = [int(word) for word in s.split() if word.isdigit()]\n    apples = nums[0] if \"apples\" in s else 0\n    oranges = nums[1] if \"oranges\" in s else 0\n    mango = n - apples - oranges\n    \n    return mango\n",
        "def fruit_distribution(s, n):\n    apple_str = ''\n    orange_str = ''\n    for char in s:\n        if char.isnumeric():\n            if not orange_str:\n                apple_str += char\n            else:\n                orange_str += char\n    apples = int(apple_str)\n    oranges = int(orange_str)\n    \n    mango = n - apples - oranges\n    return mango\n",
        "def fruit_distribution(s, n):\n    # Step 0: Extract the number of apples and oranges from the input string\n    s = s.split()\n    apples = int(s[0])\n    oranges = int(s[3])\n\n    # Step 1: Calculate the number of mango fruits by subtracting total apples and oranges from total fruits\n    mangoes = n - apples - oranges\n    return mangoes\n"
    ],
    "HumanEval/68": [
        "def pluck(arr):\n    smallest_even_value = None\n    smallest_even_index = None\n    \n    for i in range(len(arr)):\n        if arr[i] % 2 == 0:  # Check if the number is even\n            if smallest_even_value is None:  # If the smallest even value variable is None\n                smallest_even_value = arr[i]\n                smallest_even_index = i\n            elif arr[i] < smallest_even_value:  # If current element is smaller than smallest even value\n                smallest_even_value = arr[i]\n                smallest_even_index = i\n    \n    if smallest_even_value is not None:\n        return [smallest_even_value, smallest_even_index]\n    else:\n        return []\n",
        "def pluck(arr):\n    smallest_even_value = None\n    smallest_even_index = None\n    \n    for index, node in enumerate(arr):\n        if node % 2 == 0:\n            if smallest_even_value is None or node < smallest_even_value or (node == smallest_even_value and index < smallest_even_index):\n                smallest_even_value = node\n                smallest_even_index = index\n    \n    if smallest_even_value is not None:\n        return [smallest_even_value, smallest_even_index]\n    else:\n        return []\n",
        "def pluck(arr):\n    min_even = None\n    min_even_index = None\n\n    for index, node in enumerate(arr):\n        if node % 2 == 0:  # Check if the node is even\n            if min_even is None or (node < min_even):\n                min_even = node\n                min_even_index = index\n\n    if min_even is None:\n        return []\n\n    return [min_even, min_even_index]\n",
        "def pluck(arr):\n    min_even_value = None\n    min_index = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0:  # Check if the value is even\n            if min_even_value is None or value < min_even_value or (value == min_even_value and index < min_index): # Compare with current min_even_value\n                min_even_value = value\n                min_index = index\n\n    if min_even_value is None:\n        return []\n    \n    return [min_even_value, min_index]\n",
        "return [smallest_even_node, smallest_even_index]\n"
    ],
    "HumanEval/69": [
        "def search(lst):\n    freq_dict = {}\n    \n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    \n    result = -1\n    \n    for num, freq in freq_dict.items():\n        if num > 0 and freq >= num:\n            result = max(result, num)\n    \n    return result\n",
        "def search(lst):\n    element_frequency = {}  # Step 0\n    for elem in lst:\n        if elem in element_frequency:\n            element_frequency[elem] += 1\n        else:\n            element_frequency[elem] = 1\n    \n    for key, value in element_frequency.items():  # Step 1\n        if key > 0 and value >= key:\n            return key\n            \n    return -1\n",
        "def search(lst):\n    freq_dict = {}\n    \n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    \n    max_num = -1\n    \n    for num, freq in freq_dict.items():\n        if num > freq and num > 0:\n            if freq >= max_num:\n                max_num = num\n    \n    return max_num\n",
        "def search(lst):\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    \n    greatest_integer = -1\n    for num, freq in freq_dict.items():\n        if freq >= num:\n            greatest_integer = max(greatest_integer, num)\n    \n    return greatest_integer\n",
        "def search(lst):\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    \n    result = -1\n    for num, freq in freq_dict.items():\n        if num > 0 and freq >= num:\n            result = max(result, num)\n    \n    return result\n"
    ],
    "HumanEval/70": [
        "def strange_sort_list(lst):\n    if not lst:\n        return []\n\n    result = []\n    while lst:\n        min_val = min(lst)\n        lst.remove(min_val)\n        result.append(min_val)\n\n        if lst:\n            max_val = max(lst)\n            lst.remove(max_val)\n            result.append(max_val)\n\n    return result\n",
        "def strange_sort_list(lst):\n    if len(lst) == 0:\n        return []\n    \n    result = [] \n    sorted_lst = sorted(lst)\n    \n    for i in range(0, len(sorted_lst)//2, 2):\n        result.append(sorted_lst[i])\n        result.append(sorted_lst[-(i+1)])\n    \n    if len(sorted_lst) % 2 != 0:\n        result.append(sorted_lst[len(sorted_lst)//2])\n\n    return result\n",
        "def strange_sort_list(lst):\n    if not lst:\n        return []\n\n    result = []\n    while lst:\n        min_val = min(lst)\n        result.append(min_val)\n        lst.remove(min_val)\n\n        if lst:\n            max_val = max(lst)\n            result.append(max_val)\n            lst.remove(max_val)\n\n    return result\n",
        "def strange_sort_list(lst):\n    if not lst:\n        return []\n\n    output = []\n    while lst:\n        min_val = min(lst)\n        output.append(min_val)\n        lst.remove(min_val)\n        \n        if not lst:\n            break\n        \n        max_val = max(lst)\n        output.append(max_val)\n        lst.remove(max_val)\n    \n    return output\n",
        "def strange_sort_list(lst):\n    sorted_lst = []\n    if not lst:\n        return sorted_lst\n    \n    length = len(lst)\n    \n    sorted_list = sorted(lst)\n    \n    for i in range(length // 2):\n        sorted_lst.append(sorted_list[i]) # Append minimum value\n        sorted_lst.append(sorted_list[length - 1 - i]) # Append maximum value\n        \n    if length % 2 == 1:\n        sorted_lst.append(sorted_list[length // 2])  # Append middle value\n\n    return sorted_lst\n"
    ],
    "HumanEval/71": [
        "import math\n\ndef triangle_area(a, b, c):\n    def is_valid_triangle(x, y, z):\n        return x + y > z and x + z > y and y + z > x\n\n    if is_valid_triangle(a, b, c):\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1\n",
        "import math\n\ndef triangle_area(a, b, c):\n    if a + b > c and b + c > a and a + c > b:\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1\n",
        "import math\n\ndef triangle_area(a, b, c):\n    if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1\n",
        "import math\n\ndef triangle_area(a, b, c):\n    def is_valid_triangle(a, b, c):\n        return a + b > c and a + c > b and b + c > a\n\n    if not is_valid_triangle(a, b, c):\n        return -1\n\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    rounded_area = round(area, 2)\n    \n    return rounded_area\n",
        "import math\n\ndef triangle_area(a, b, c):\n    if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1\n"
    ],
    "HumanEval/72": [
        "def will_it_fly(q, w):\n    def is_palindrome(lst):\n        return lst == lst[::-1]\n\n    def sum_elements(lst):\n        return sum(lst)\n\n    if is_palindrome(q) and sum_elements(q) <= w:\n        return True\n    else:\n        return False\n",
        "def will_it_fly(q, w):\n    def is_palindromic_list(lst):\n        return lst == lst[::-1]\n    \n    is_balanced = is_palindromic_list(q)\n    sum_of_elements = sum(q)\n    is_under_weight = sum_of_elements <= w\n    \n    return is_balanced and is_under_weight\n",
        "def will_it_fly(q, w):\n    is_palindromic = q == q[::-1]\n    total_weight = sum(q)\n    return is_palindromic and total_weight <= w\n",
        "def is_palindromic(lst):\n    return lst == lst[::-1]\n\ndef will_it_fly(q, w):\n    if not is_palindromic(q):\n        return False\n    \n    sum_elements = sum(q)\n    \n    if sum_elements <= w:\n        return True\n    else:\n        return False\n",
        "def will_it_fly(q, w):\n    if q != q[::-1]:\n        return False\n\n    if sum(q) > w:\n        return False\n    \n    return True\n"
    ],
    "HumanEval/73": [
        "def smallest_change(arr):\n    n = len(arr)\n    mid = n // 2\n    changes = 0\n\n    for i in range(mid):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n        \n    total_changes = max(changes, 1)\n        \n    return total_changes\n",
        "def smallest_change(arr):\n    if arr == arr[::-1]:\n        return 0\n    \n    count = 0\n    length = len(arr)\n    \n    for i in range(length // 2):\n        if arr[i] != arr[length - i - 1]:\n            count += 1\n    \n    return count\n",
        "def smallest_change(arr):\n    # Step 1: Identify indices where elements need to be changed\n    n = len(arr)\n    change_indices = [i for i in range(n // 2) if arr[i] != arr[n - i - 1]]\n    \n    # Step 2: Initialize variable count to 0\n    count = 0\n    \n    # Step 3: Iterate through the change_indices list\n    for index in change_indices:\n        # Step 4: Find the minimum change required at the current index\n        count += min(abs(arr[index] - arr[n - index - 1]), 26 - abs(arr[index] - arr[n - index - 1]))\n        \n    return count\n",
        "def smallest_change(arr):\n    length = len(arr)\n    changes_needed = 0\n    left = 0\n    right = length - 1\n\n    while left < right:\n        if arr[left] != arr[right]:\n            changes_needed += abs(arr[left] - arr[right])\n        left += 1\n        right -= 1\n\n    return changes_needed\n",
        "def is_palindrome(arr):\n    return arr == arr[::-1]\n\ndef smallest_change(arr):\n    min_changes = float('inf) \n\n    if is_palindrome(arr):\n        return 0\n\n    for i in range(len(arr)):\n        changes = sum(1 for j in range(len(arr)//2) if arr[j] != arr[len(arr)-j-1])\n        min_changes = min(min_changes, changes)\n\n    return min_changes\n"
    ],
    "HumanEval/74": [
        "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    return lst2\n",
        "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n    \n    # Compare the total number of characters in both lists and return accordingly\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1\n",
        "def total_match(lst1, lst2):\n    def total_chars_in_list(lst):\n        return sum(len(s) for s in lst)\n\n    total_chars_lst1 = total_chars_in_list(lst1)\n    total_chars_lst2 = total_chars_in_list(lst2)\n\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1  # If total characters are equal, return lst1\n",
        "def total_match(lst1, lst2):\n    def calculate_chars(lst):\n        return sum(len(s) for s in lst)\n\n    if len(lst1) == len(lst2):\n        total_chars_lst1 = calculate_chars(lst1)\n        total_chars_lst2 = calculate_chars(lst2)\n\n        if total_chars_lst1 < total_chars_lst2:\n            return lst1\n        else:\n            return lst2\n    elif len(lst1) < len(lst2):\n        return lst1\n    else:\n        return lst2\n",
        "def total_match(lst1, lst2):\n    total_chars_lst1 = sum([len(s) for s in lst1])\n    total_chars_lst2 = sum([len(s) for s in lst2])\n    \n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1\n"
    ],
    "HumanEval/75": [
        "def is_multiply_prime(a):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    for i in range(2, a):\n        if is_prime(i):\n            for j in range(i, a):\n                if is_prime(j):\n                    for k in range(j, a):\n                        if is_prime(k) and i * j * k == a:\n                            return True\n    return False\n",
        "from sympy import isprime\n\ndef is_multiply_prime(a):\n    \n    if a >= 100:\n        return False\n    \n    factors = []\n    \n    for i in range(2, a):\n        if isprime(i) and a % i == 0:\n            factors.append(i)\n    \n    return len(factors) == 3\n",
        "from itertools import combinations\n\ndef is_multiply_prime(a):\n    if a >= 100:\n        return False\n\n    def is_prime(x):\n        if x < 2:\n            return False\n        for i in range(2, int(x ** 0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    prime_factors = [i for i in range(2, a) if is_prime(i) and a % i == 0]\n\n    for combo in combinations(prime_factors, 3):\n        if combo[0] * combo[1] * combo[2] == a:\n            return True\n\n    return False\n",
        "def is_multiply_prime(a):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    primes = [num for num in range(2, 100) if is_prime(num)]\n\n    products = []\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                products.append(primes[i] * primes[j] * primes[k])\n\n    return a in products\n",
        "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a):\n    count = 0\n    for i in range(2, a):\n        if is_prime(i) and a % i == 0:\n            count += 1\n    return count == 3\n\n# Test cases\n\n\n"
    ],
    "HumanEval/76": [
        "def is_simple_power(x, n):\n    if x == 1:\n        return n == 1\n    if n == 1:\n        return False\n    if x == n:\n        return True\n\n    power = 1\n    while power < x:\n        power *= n\n    return power == x\n",
        "def is_simple_power(x, n):\n    if x == 1 and n == 1:\n        return True\n    if x != 1 and n == 1:\n        return False\n\n    power = 1\n\n    while n ** power <= x:\n        if n ** power == x:\n            return True\n        power += 1\n\n    return False\n",
        "def is_simple_power(x, n):\n    if x == 1:\n        return False\n    elif n == 1:\n        return True\n    else:\n        result = math.log(x, n)\n        return result.is_integer()\n",
        "import math\n\ndef is_simple_power(x, n):\n    if x == 1:\n        return n == 1\n    \n    if x == n:\n        return True\n\n    sqrt_x = math.isqrt(x)\n    for i in range(2, sqrt_x + 1):\n        if n**i == x:\n            return True\n\n    return False\n",
        "# Step 3\npower = n\n"
    ],
    "HumanEval/77": [
        "def iscube(a):\n    def is_perfect_cube(num):\n        return round(num ** (1/3)) ** 3 == num\n    \n    if a >= 0:\n        return is_perfect_cube(a)\n    else:\n        return is_perfect_cube(-a)\n",
        "import math\n\ndef iscube(a):\n    cube_root = round(math.pow(abs(a), 1/3))\n    return cube_root ** 3 == abs(a)\n",
        "# Step 3: Find the cube root of the number and check if it is an integer\n\ndef iscube(a):\n    if a < 0:\n        a = abs(a)\n    \n    cube_root = a**(1/3)\n    \n    # Step 4: If the cube root is an integer, return True; otherwise, return False.\n    return cube_root.is_integer()\n",
        "import math\n\ndef iscube(a):\n    if a < 0:\n        return False\n    cube_root = a ** (1/3)\n    if cube_root.is_integer() and int(cube_root) ** 3 == a:\n        return True\n    return False\n",
        "def iscube(a):\n    return (a**(1/3)).is_integer() if a >= 0 else False\n"
    ],
    "HumanEval/78": [
        "def hex_key(num):\n    prime_digits = ['2', '3', '5', '7', 'B', 'D']\n    count = 0\n    \n    for digit in num:\n        if digit in prime_digits:\n            count += 1\n    \n    return count\n",
        "def hex_key(num):\n    prime_digits_count = 0\n    prime_hex_digits = {\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"}\n    \n    for digit in num:\n        if digit in prime_hex_digits:\n            prime_digits_count += 1\n    \n    return prime_digits_count\n",
        "def hex_key(num):\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in prime_digits:\n            count += 1\n    return count\n",
        "def hex_key(num):\n    count = 0\n    primes = ['2', '3', '5', '7', 'B', 'D']\n    for digit in num:\n        if digit in primes:\n            count += 1\n    return count\n",
        "def hex_key(num):\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    \n    for digit in num:\n        if digit in prime_digits:\n            count += 1\n    \n    return count\n"
    ],
    "HumanEval/79": [
        "def decimal_to_binary(decimal):\n    binary_digits = bin(decimal)[2:]\n    binary_string = 'db' + binary_digits + 'db'\n    return binary_string\n",
        "def decimal_to_binary(decimal):\n    binary_rep = bin(decimal)[2:]  # Convert decimal to binary representation\n    binary_str = 'db' + binary_rep + 'db'  # Add 'db' prefix and suffix\n    return binary_str\n",
        "def decimal_to_binary(decimal):\n    if not isinstance(decimal, int) or decimal < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    binary = bin(decimal)[2:]  # Convert decimal to binary and remove the '0b' prefix\n    binary = '0' * (8 - len(binary) % 8) + binary if len(binary) % 8 != 0 else binary  # Pad with zeros to make it a multiple of 8\n    \n    binary = 'db' + binary + 'db'  # Add 'db' at the beginning and end\n    \n    return binary\n",
        "def decimal_to_binary(decimal):\n    binary = bin(decimal)[2:]\n    binary = \"db\" + binary + \"db\"\n    return binary\n",
        "def decimal_to_binary(decimal):\n    binary = bin(decimal)[2:]  # Convert decimal to binary and remove the prefix '0b'\n    binary_formatted = \"db\" + binary + \"db\"  # Add 'db' prefix and suffix to the binary representation\n    return binary_formatted\n"
    ],
    "HumanEval/80": [
        "def is_happy(s):\n    if len(s) < 3:\n        return False\n\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n\n    return True\n",
        "def is_happy(s):\n    if len(s) < 3:\n        return False\n    \n    for i in range(len(s) - 2):\n        if len(set(s[i:i+3])) != 3:\n            return False\n    return True\n",
        "def is_happy(s):\n    if len(s) < 3:\n        return False\n    \n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n            \n    return True\n",
        "def is_happy(s):\n    if len(s) < 3:\n        return False\n    \n    for i in range(len(s) - 2):\n        sub_str = s[i:i+3]\n        \n        if len(set(sub_str)) < 3:\n            return False\n    \n    return True\n",
        "def is_happy(s):\n    if len(s) < 3:\n        return False\n    \n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    \n    return True\n"
    ],
    "HumanEval/81": [
        "def numerical_letter_grade(grades):\n    letter_grades = []\n\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa >= 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n\n    return letter_grades\n",
        "def numerical_letter_grade(grades):\n    \"\"\"Convert a list of GPAs to a list of corresponding letter grades.\"\"\"\n    letter_grades = []  # Create an empty list to store the letter grades\n\n    for grade in grades:\n        if grade == 4.0:\n          letter_grades.append('A+')\n        elif grade > 3.7:\n          letter_grades.append('A')\n        elif grade > 3.3:\n          letter_grades.append('A-')\n        elif grade > 3.0:\n          letter_grades.append('B+')\n        elif grade > 2.7:\n          letter_grades.append('B')\n        elif grade > 2.3:\n          letter_grades.append('B-')\n        elif grade > 2.0:\n          letter_grades.append('C+')\n        elif grade > 1.7:\n          letter_grades.append('C')\n        elif grade > 1.3:\n          letter_grades.append('C-')\n        elif grade > 1.0:\n          letter_grades.append('D+')\n        elif grade > 0.7:\n          letter_grades.append('D')\n        elif grade >= 0.0:\n          letter_grades.append('D-')\n        else:\n          letter_grades.append('E')\n\n    return letter_grades\n\n# Testing the function with example input\ngrades = [4.0, 3, 1.7, 2, 3.5]\n\n",
        "def numerical_letter_grade(grades):\n    \"\"\"\n    It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write\n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A\n            > 3.3                A-\n            > 3.0                B+\n            > 2.7                B\n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+\n            > 0.7                D\n            > 0.0                D-\n              0.0                E\n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'A', 'C', 'B', 'A-']\n    \"\"\"\n    letter_grades = []  # Step 1: Create an empty list to store the letter grades\n\n    # Step 2: Iterate over each GPA and calculate the corresponding letter grade\n    for gpa in grades:\n        if 0.0 <= gpa <= 4.0:  # Check if GPA is within valid range\n            if gpa == 4.0:\n                letter_grades.append('A+')\n            elif 3.7 < gpa <= 4.0:\n                letter_grades.append('A')\n            elif 3.3 < gpa <= 3.7:\n                letter_grades.append('A-')\n            elif 3.0 < gpa <= 3.3:\n                letter_grades.append('B+')\n            elif 2.7 < gpa <= 3.0:\n                letter_grades.append('B')\n            elif 2.3 < gpa <= 2.7:\n                letter_grades.append('B-')\n            elif 2.0 < gpa <= 2.3:\n                letter_grades.append('C+')\n            elif 1.7 < gpa <= 2.0:\n                letter_grades.append('C')\n            elif 1.3 < gpa <= 1.7:\n                letter_grades.append('C-')\n            elif 1.0 < gpa <= 1.3:\n                letter_grades.append('D+')\n            elif 0.7 < gpa <= 1.0:\n                letter_grades.append('D')\n            elif 0.0 < gpa <= 0.7:\n                letter_grades.append('D-')\n        else:\n            letter_grades.append('Invalid GPA')  # Handle invalid GPA case\n    \n    return letter_grades  # Step 5: Return the list of calculated letter grades\n",
        "def numerical_letter_grade(grades):\n    letter_grades = []\n    \n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade = 'A+'\n        elif gpa > 3.7:\n            letter_grade = 'A'\n        elif gpa > 3.3:\n            letter_grade = 'A-'\n        elif gpa > 3.0:\n            letter_grade = 'B+'\n        elif gpa > 2.7:\n            letter_grade = 'B'\n        elif gpa > 2.3:\n            letter_grade = 'B-'\n        elif gpa > 2.0:\n            letter_grade = 'C+'\n        elif gpa > 1.7:\n            letter_grade = 'C'\n        elif gpa > 1.3:\n            letter_grade = 'C-'\n        elif gpa > 1.0:\n            letter_grade = 'D+'\n        elif gpa > 0.7:\n            letter_grade = 'D'\n        elif gpa > 0.0:\n            letter_grade = 'D-'\n        else:\n            letter_grade = 'E'\n        \n        letter_grades.append(letter_grade)\n    \n    return letter_grades\n",
        "def numerical_letter_grade(grades):\n    letter_grades = []\n    \n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa >= 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    \n    return letter_grades\n"
    ],
    "HumanEval/82": [
        "def prime_length(string):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    string_length = len(string)\n    return is_prime(string_length)\n",
        "import math\n\ndef prime_length(string):\n    if len(string) < 2:\n        return False\n\n    for i in range(2, int(math.sqrt(len(string)))+1):\n        if len(string) % i == 0:\n            return False\n    return True\n",
        "import math\n\ndef prime_length(string):\n    if len(string) < 2:\n        return False\n    \n    sqrt_len = int(math.sqrt(len(string)))\n    \n    for i in range(2, sqrt_len + 1):\n        if len(string) % i == 0:\n            return False\n    \n    return True\n",
        "def prime_length(string):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    string_length = len(string)\n    return is_prime(string_length)\n",
        "def prime_length(string):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    str_length = len(string)\n    \n    return is_prime(str_length)\n"
    ],
    "HumanEval/83": [
        "def starts_one_ends(n):\n    count = 0\n    for i in range(10**(n-1), 10**n):\n        if str(i)[0] == '1':\n            count += 1\n        if str(i)[-1] == '1':\n            count += 1\n    return count\n",
        "def starts_one_ends(n):\n    count = 0\n    for i in range(10 ** (n - 1), 10 ** n):\n        if str(i)[0] == '1' or str(i)[-1] == '1':\n            count += 1\n    return count\n",
        "    return count\n",
        "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    \n    # Step 0: Check if the input n is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        return \"Input must be a positive integer.\"\n    \n    count = 0\n    \n    # Step 2: Iterate through all n-digit positive integers\n    for i in range(10**(n-1), 10**n):\n        if str(i)[0] == '1' or str(i)[-1] == '1':\n            count += 1\n\n    return count\n",
        "def starts_one_ends(n):\n    count = 0\n    for i in range(10 ** (n - 1), 10 ** n):\n        number_str = str(i)\n        if number_str[0] == '1' or number_str[-1] == '1':\n            count += 1\n    return count\n"
    ],
    "HumanEval/84": [
        "def solve(N):\n    binary_str = bin(N)[2:]\n    binary_list = list(map(int, binary_str))\n    sum_digits = sum(binary_list)\n    binary_sum = bin(sum_digits)[2:]\n    return binary_sum\n",
        "def solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    total = 0\n    binary_str = bin(N)[2:]\n    for digit in binary_str:\n        total += int(digit)\n    binary_total = bin(total)\n    return binary_total[2:]\n\n\n# Test the function with the provided examples\n\n\n\n",
        "def solve(N):\n    binary_str = bin(N)[2:]  # Convert N to binary string and remove the '0b' prefix\n    digit_sum = sum(int(digit) for digit in binary_str)\n    return bin(digit_sum)[2:]\n\n# Test the final implementation\n\n\n\n",
        "def solve(N):\n    N_str = str(N)\n    total_sum = sum(int(digit) for digit in N_str)\n    binary_sum = bin(total_sum)[2:]\n    return binary_sum\n",
        "def solve(N):\n    total_sum = 0\n    N_str = str(N)\n\n    for digit in N_str:\n        total_sum += int(digit)\n\n    return bin(total_sum)[2:]\n"
    ],
    "HumanEval/85": [
        "def add(lst):\n    sum_of_even_at_odd_indices = 0\n    \n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum_of_even_at_odd_indices += lst[i]\n    \n    return sum_of_even_at_odd_indices\n",
        "def add(lst):\n    total = 0\n    for idx in range(1, len(lst), 2):\n        if lst[idx] % 2 == 0:\n            total += lst[idx]\n    return total\n\n\n",
        "def add(lst):\n    total_sum = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total_sum += lst[i]\n    return total_sum\n",
        "def add(lst):\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total\n\n# Testing the function\n\n",
        "def add(lst):\n    sum_even = 0\n    \n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            sum_even += lst[index]\n    \n    return sum_even\n"
    ],
    "HumanEval/86": [
        "def anti_shuffle(s):\n    words = s.split()\n    sorted_words = [''.join(sorted(word, key=lambda x: ord(x))) for word in words]\n    return ' '.join(sorted_words)\n",
        "def anti_shuffle(s):\n    words = s.split()\n    sorted_words = [''.join(sorted(word, key=lambda x: ord(x))) for word in words]\n    return ' '.join(sorted_words)\n",
        "def anti_shuffle(s):\n    words = s.split()\n    ordered_words = []\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        ordered_words.append(sorted_word)\n    \n    ordered_string = ' '.join(ordered_words)\n    \n    return ordered_string\n",
        "import re\n\ndef sort_word(word):\n    return ''.join(sorted(word, key=lambda c: ord(c)))\n\ndef anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of a string is a string where all words are replaced by a new word \n    with characters arranged in ascending order of ascii value.\n    \n    Args:\n    - s: input string\n    \n    Returns:\n    - Ordered version of the input string\n    \"\"\"\n    words = re.findall(r'\\S+|\\s+', s)\n    ordered_words = [sort_word(word) if word.strip() else ' ' for word in words]\n    ordered_string = ''.join(ordered_words)\n    return ordered_string\n",
        "def anti_shuffle(s):\n    words = s.split(' ')\n    \n    # Sort the characters in each word based on ASCII values\n    sorted_words = [''.join(sorted(word, key=lambda x: ord(x))) for word in words]\n    \n    # Join the modified words back together along with the blank spaces\n    ordered_string = ' '.join(sorted_words)\n    \n    return ordered_string\n"
    ],
    "HumanEval/87": [
        "def get_row(lst, x):\n    coordinates = []\n\n    for row_index, row in enumerate(lst):\n        if x in row:\n            column_index = row.index(x)\n            coordinates.append((row_index, column_index))\n\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n\n    return sorted_coordinates\n",
        "def get_row(lst, x):\n    rows_with_x = []\n    for i, row in enumerate(lst):\n        column_indices = [idx for idx, val in enumerate(row) if val == x]\n        for col_index in column_indices:\n            rows_with_x.append((i, col_index))\n    \n    rows_with_x.sort(key=lambda coord: (coord[0], -coord[1]))  # Sort by row index in ascending order, then by column index in descending order\n    return rows_with_x\n",
        "def get_row(lst, x):\n    coordinates = []\n    \n    for i, row in enumerate(lst):\n        if x in row:\n            indices = [j for j, val in enumerate(row) if val == x]\n            for j in indices:\n                coordinates.append((i, j))\n    \n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n",
        "def get_row(lst, x):\n    coordinates = []\n    \n    for i, row in enumerate(lst):\n        if x in row:\n            j = row.index(x)\n            coordinates.append((i, j))\n    \n    coordinates.sort(key=lambda coord: coord[0])  # Step 2\n    coordinates.sort(key=lambda coord: coord[1], reverse=True)  # Step 3\n    \n    return coordinates\n",
        "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        if x in row:\n            j = row.index(x)\n            coordinates.append((i, j))\n    \n    return sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n"
    ],
    "HumanEval/88": [
        "def sort_array(array):\n    if not array:\n        return []  # Return an empty array if the input array is empty\n    \n    first_element = array[0]\n    last_element = array[-1]\n\n    array_sum = first_element + last_element\n\n    if array_sum % 2 == 1:  # Check if the sum is odd\n        # Sort the array in ascending order\n        sorted_array = sorted(array)\n    else:\n        # Sort the array in descending order\n        sorted_array = sorted(array, reverse=True)\n\n    return sorted_array\n",
        "def sort_array(array):\n    if len(array) == 0:\n        return []\n    \n    first_last_sum = array[0] + array[-1]\n    if first_last_sum % 2 == 1:  # Sum is odd\n        return sorted(array)\n    else:  # Sum is even\n        return sorted(array, reverse=True)\n",
        "def sort_array(array):\n    if not array:  # Check if the array is empty\n        return []\n    \n    first_element = array[0]\n    last_element = array[-1]\n    sum_first_last = first_element + last_element\n    \n    if sum_first_last % 2 == 0:\n        sorted_array = sorted(array, reverse=True)\n    else:\n        sorted_array = sorted(array)\n    \n    return sorted_array\n",
        "def sort_array(array):\n    if not array:\n        return array\n    \n    first_element = array[0]\n    last_element = array[-1]\n    \n    sum_first_last = first_element + last_element\n    \n    if sum_first_last % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)\n",
        "        return sorted(array, reverse=True)  # Sort in descending order\n"
    ],
    "HumanEval/89": [
        "def encrypt(s):\n    encrypted_text = \"\"\n    shift = 2 * 2  # Shifting alphabet down by two multiplied to two places\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    \n    for char in s:\n        if char.islower():\n            index = alphabet.index(char)\n            new_index = (index + shift) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n        else:\n            encrypted_text += char\n    \n    return encrypted_text\n",
        "def encrypt(s):\n    result = \"\"\n    \n    for c in s:\n        if c.isalpha():\n            shift = 2\n            if c.islower():\n                new_char = chr((ord(c) - ord('a') + shift*2) % 26 + ord('a'))\n            else:\n                new_char = chr((ord(c) - ord('A') + shift*2) % 26 + ord('A'))\n            result += new_char\n        else:\n            result += c\n\n    return result\n",
        "def encrypt(s):\n    result = \"\"\n    \n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2  # Shifting down by two multiplied to two places\n            shifted_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a')) if char.islower() else chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            result += shifted_char\n        else:\n            result += char\n        \n    return result\n",
        "def encrypt(s):\n    encrypted_text = \"\"\n    \n    for c in s:\n        if c.isalpha():\n            rotated_char = chr(((ord(c) - ord('a') + 2 * 2) % 26) + ord('a')) if c.islower() else chr(((ord(c) - ord('A') + 2 * 2) % 26) + ord('A'))\n            encrypted_text += rotated_char\n        else:\n            encrypted_text += c\n    \n    return encrypted_text\n",
        "def encrypt(s):\n    result = \"\"\n    \n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            ascii_offset = 97 if char.islower() else 65\n            encrypted_char = chr((ord(char) + shift - ascii_offset) % 26 + ascii_offset)\n            result += encrypted_char\n        else:\n            result += char\n    \n    return result\n"
    ],
    "HumanEval/90": [
        "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    \n    unique_elements = list(set(lst))\n    \n    if len(unique_elements) < 2:\n        return None\n    \n    sorted_elements = sorted(unique_elements)\n    \n    if len(sorted_elements) < 2:\n        return None\n    \n    return sorted_elements[1]\n",
        "def next_smallest(lst):\n    if not lst:\n        return None\n    \n    unique_elements = list(set(lst))\n    unique_elements.sort()\n    \n    if len(unique_elements) < 2:\n        return None\n    \n    return unique_elements[1]\n",
        "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = list(set(lst))\n    \n    if len(unique_lst) < 2:\n        return None\n    \n    unique_lst.sort()\n    \n    return unique_lst[1]\n",
        "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    \n    lst.sort()\n    \n    return lst[1] if len(lst) > 1 else None\n",
        "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    \n    lst = list(set(lst))\n    lst.sort()\n    \n    if len(lst) >= 2:\n        return lst[1]\n    else:\n        return None\n"
    ],
    "HumanEval/91": [
        "def is_bored(S):\n    words = S.split()\n    sentences = []\n    current_sentence = []\n    \n    for word in words:\n        current_sentence.append(word)\n        if word.endswith('.') or word.endswith('?') or word.endswith('!'):\n            sentence = ' '.join(current_sentence)\n            sentences.append(sentence)\n            current_sentence = []\n    \n    count = sum(1 for sentence in sentences if sentence.startswith('I'))\n    return count\n",
        "def is_bored(S):\n    sentences = []\n    for delimiter in ['.', '?', '!']:\n        sentences += S.split(delimiter)\n    \n    sentences = [sentence.strip() for sentence in sentences if len(sentence.strip()) > 0]\n    \n    boredoms = sum(1 for sentence in sentences if sentence.startswith(\"I \"))\n    \n    return boredoms\n",
        "import re\n\ndef is_bored(S):\n    sentences = [sentence.strip() for sentence in re.split(r'[.!?]', S)]\n    bored_count = sum(1 for sentence in sentences if sentence.startswith('I'))\n    return bored_count\n",
        "def is_bored(S):\n    sentences = []\n    current_sentence = \"\"\n    for char in S:\n        if char in ['.', '?', '!']:\n            sentences.append(current_sentence.strip())\n            current_sentence = \"\"\n        else:\n            current_sentence += char\n\n    boredom_count = 0\n    for sentence in sentences:\n        if sentence.startswith(\"I \") or sentence.startswith(\"I\" + ' '):  # Check if the sentence starts with \"I \"\n            boredom_count += 1\n\n    return boredom_count\n",
        "import re\n\ndef is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n    \n    sentences = re.split(r'[.?!]', S)  # Split the input string into sentences\n    i_boredom_count = sum([1 for sentence in sentences if sentence.strip().startswith(\"I \")])\n    \n    return i_boredom_count\n"
    ],
    "HumanEval/92": [
        "def any_int(x, y, z):\n    if all(isinstance(num, int) for num in [x, y, z]):  \n        if x == y + z or y == x + z or z == x + y:  \n            return True\n        else:\n            return False\n    else:\n        return False\n",
        "def any_int(x, y, z):\n    # Step 1: Check if all input parameters are integers\n    if all(isinstance(num, int) for num in [x, y, z]):\n        # Step 2: Check if any number is equal to the sum of the other two\n        if x == y + z or y == x + z or z == x + y:\n            return True\n        else:\n            return False\n    else:\n        return False\n",
        "def any_int(x, y, z):\n    if all(isinstance(num, int) for num in [x, y, z]):\n        if x == y + z or y == x + z or z == x + y:\n            return True\n    return False\n",
        "def any_int(x, y, z):\n    if all(isinstance(num, int) for num in [x, y, z]):\n        if any(num == x + y + z for num in [x, y, z]):\n            return True\n        else:\n            return False\n    else:\n        return False\n",
        "def any_int(x, y, z):\n    if not all(isinstance(num, int) for num in [x, y, z]):\n        return False\n    return x == y + z or y == x + z or z == x + y\n"
    ],
    "HumanEval/93": [
        "def encode(message):\n    encoded_message = \"\"\n    \n    for char in message:\n        if char.isalpha():\n            if char.lower() in ['a', 'e', 'i', 'o', 'u']:\n                encoded_message += chr(ord(char) + 2).upper()\n            else:\n                encoded_message += char.swapcase()\n        else:\n            encoded_message += char\n    \n    return encoded_message\n",
        "def encode(message):\n    encoded_message = \"\"\n\n    for char in message:\n        if char.isalpha():\n            if char.islower():\n                char = char.upper()\n            else:\n                char = char.lower()\n            \n            vowels = \"AEIOU\"\n            if char.upper() in vowels:\n                index = (ord(char.upper()) - ord('A') + 2) % 26\n                char = chr(ord('A') + index)\n                \n            encoded_message += char\n        else:\n            encoded_message += char\n\n    return encoded_message\n",
        "def encode(message):\n    vowels_mapping = {\n        'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w',\n        'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'\n    }\n    encoded_message = \"\"\n    \n    for char in message:\n        if char.isalpha():\n            if char.lower() in vowels_mapping:\n                encoded_message += vowels_mapping[char.lower()]\n            else:\n                encoded_message += char.swapcase()\n        else:\n            encoded_message += char\n\n    return encoded_message\n",
        "def encode(message):\n    encoded_message = \"\"\n    \n    for char in message:\n        if char.isalpha():\n            if char.lower() in ['a', 'e', 'i', 'o', 'u']:\n                encoded_message += chr(ord(char) + 2) if char.islower() else chr(ord(char) + 2).upper()\n            else:\n                encoded_message += char.swapcase()\n        else:\n            encoded_message += char\n        \n    return encoded_message\n",
        "def encode(message):\n    encoded_message = \"\"\n\n    for char in message:\n        if char.lower() in ['a', 'e', 'i', 'o', 'u']:\n            # Replace vowels with letters 2 places ahead in the alphabet\n            encoded_message += chr(ord(char) + 2)\n        elif char.isalpha():\n            # Swap the case of letters\n            encoded_message += char.swapcase()\n        else:\n            # Keep other characters as they are\n            encoded_message += char\n\n    return encoded_message\n"
    ],
    "HumanEval/94": [
        "def is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef sum_digits_of_largest_prime(lst):\n    # Step 4: Find the largest prime number in the list and return the sum of its digits\n    largest_prime = None\n    for num in lst:\n        if is_prime(num):\n            if largest_prime is None or num > largest_prime:\n                largest_prime = num\n\n    if largest_prime is None:\n        return 0  # Return 0 if no prime number found\n    return sum(int(digit) for digit in str(largest_prime))\n",
        "import math\n\ndef largest_prime_sum_digits(lst):\n    \"\"\"\n    You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n    \"\"\"\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    largest_prime = 0\n    sum_digits = 0\n    \n    for num in lst:\n        if is_prime(num) and num > largest_prime:\n            largest_prime = num\n        sum_digits += sum(int(digit) for digit in str(num))\n    \n    return sum(int(digit) for digit in str(largest_prime))\n",
        "def skjkasdkd(lst):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_numbers = [num for num in lst if is_prime(num)]\n    if prime_numbers:\n        largest_prime = max(prime_numbers)\n        sum_digits = sum(int(digit) for digit in str(largest_prime))\n        return sum_digits\n    return 0\n",
        "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef find_largest_prime_sum(lst):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n   \n    largest_prime = None\n    for num in lst:\n        if is_prime(num) and (largest_prime is None or num > largest_prime):\n            largest_prime = num\n    \n    if largest_prime is None:\n        return 0\n    \n    return sum_of_digits(largest_prime)\n",
        "def find_largest_prime_sum(lst):\n    largest_prime = None\n    for num in lst:\n        if is_prime(num):\n            if largest_prime is None or num > largest_prime:\n                largest_prime = num\n\n    if largest_prime is None:\n        return 0  # Return 0 if no prime numbers were found\n\n    return sum_digits(largest_prime)\n"
    ],
    "HumanEval/95": [
        "def check_dict_case(dict):\n    if not dict:  # Check if the dictionary is empty\n        return False\n    \n    first_key = next(iter(dict))  # Get the first key in the dictionary\n\n    key_case = first_key.islower()  # Check if the first key is lowercase or not\n    \n    for key in dict.keys():  # Iterate over all keys in the dictionary\n        if key_case != key.islower() and key_case != key.isupper():\n            return False\n    \n    return True  # Return True if all keys meet the condition\n",
        "def check_dict_case(dict):\n    if not dict:\n        return False\n    \n    key_case = set()\n    for key in dict.keys():\n        if key.islower():\n            key_case.add('lower')\n        elif key.isupper():\n            key_case.add('upper')\n        else:\n            return False\n\n    return len(key_case) == 1\n",
        "def check_dict_case(dict):\n    if not dict:\n        return False\n\n    lower = False\n    upper = False\n\n    for key in dict:\n        if isinstance(key, str):\n            if key.islower():\n                lower = True\n            elif key.isupper():\n                upper = True\n        else:\n            return False\n\n    if lower and not upper:\n        return True\n    elif upper and not lower:\n        return True\n    else:\n        return False\n",
        "def check_dict_case(dict):\n    if not dict:  # Check if dictionary is empty\n        return False\n    \n    keys = dict.keys()\n    \n    key_types = [type(key) for key in keys]\n    \n    if all(key_type == str for key_type in key_types):  # Check if all keys are strings\n        if all(key.islower() for key in keys) or all(key.isupper() for key in keys):  # Check if all keys are either all lowercase or all uppercase\n            return True\n    \n    return False\n",
        "def check_dict_case(dictionary):\n    if not dictionary:\n        return False\n    if not all(isinstance(key, str) for key in dictionary.keys()):\n        return False\n\n    is_lower_case = all(key.islower() for key in dictionary.keys())\n    is_upper_case = all(key.isupper() for key in dictionary.keys())\n\n    if is_lower_case or is_upper_case:\n        return True\n\n    return False\n"
    ],
    "HumanEval/96": [
        "def count_up_to(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_numbers = []\n    if n < 2:\n        return prime_numbers\n\n    num = 2\n    result = []\n    while len(result) < n:\n        if is_prime(num):\n            result.append(num)\n        num += 1\n\n    return result\n",
        "def count_up_to(n):\n    if n <= 1:\n        return []\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    primes = []\n\n    for num in range(2, n):\n        if is_prime(num):\n            primes.append(num)\n\n    return primes\n",
        "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_up_to(n):\n    prime_numbers = []\n    count = 0\n    num = 2\n    while count < n:\n        if is_prime(num):\n            prime_numbers.append(num)\n            count += 1\n        num += 1\n        if num >= n:\n            break\n    return prime_numbers\n",
        "import math\n\ndef count_up_to(n):\n    primes_list = []\n    \n    if n <= 1:\n        return primes_list\n    \n    for num in range(2, n):\n        if num == 2 or num == 3:\n            primes_list.append(num)\n            continue\n        if num == 1 or num % 2 == 0:\n            continue\n        \n        is_prime = True\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes_list.append(num)\n            \n    return primes_list\n",
        "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_up_to(n):\n    primes = []\n    \n    if n < 2:\n        return primes\n    if n == 2:\n        return [2]\n    \n    for num in range(2, n):\n        if is_prime(num):\n            primes.append(num)\n\n    return primes\n"
    ],
    "HumanEval/97": [
        "def multiply(a, b):\n    # Step 1: Get the unit digits of a and b\n    a_unit = abs(a) % 10\n    b_unit = abs(b) % 10\n    \n    # Step 2: Multiply the unit digits together\n    product = a_unit * b_unit\n\n    # Step 3: Return the product\n    return product\n",
        "def multiply(a, b):\n    # Step 1: Get the unit digit of the first number 'a'.\n    unit_digit_a = a % 10\n    \n    # Step 1: Get the unit digit of the second number 'b'.\n    unit_digit_b = b % 10\n    \n    # Step 3: Multiply the unit digits obtained in steps 1 and 2.\n    product = unit_digit_a * unit_digit_b\n    \n    # Step 4: Return the result from step 3.\n    return product\n",
        "def multiply(a, b):\n    unit_digit_a = a % 10\n    unit_digit_b = b % 10\n    \n    product = unit_digit_a * unit_digit_b\n    return product\n",
        "def multiply(a, b):\n    return (a % 10) * (b % 10)\n",
        "def multiply(a, b):\n    a_unit = abs(a) % 10\n    b_unit = abs(b) % 10\n    product = a_unit * b_unit\n    return product\n"
    ],
    "HumanEval/98": [
        "def count_upper(s):\n    count = 0\n    vowels = {'A', 'E', 'I', 'O', 'U'}\n    \n    for i, char in enumerate(s):\n        if char.isupper() and i % 2 == 0 and char in vowels:\n            count += 1\n    \n    return count\n",
        "    return count  # Step 5: Return the count after iterating through all characters\n",
        "def count_upper(s):\n    upper_vowel_count = 0\n    \n    for index, char in enumerate(s):\n        if char.upper() in ['A', 'E', 'I', 'O', 'U'] and index % 2 == 0:\n            upper_vowel_count += 1\n    \n    return upper_vowel_count\n",
        "def count_upper(s):\n    count = 0\n    \n    vowels = set('AEIOU')\n    \n    for i in range(len(s)):\n        if i % 2 == 0 and s[i] in vowels:\n            count += 1\n            \n    return count\n",
        "def count_upper(s):\n    count = 0\n    for i in range(0, len(s), 2):\n        char = s[i]\n        if char.upper() in ['A', 'E', 'I', 'O', 'U']:\n            count += 1\n\n    return count\n"
    ],
    "HumanEval/99": [
        "def closest_integer(value):\n    # Step 0: Parse the input string value into a floating-point number\n    value = float(value)\n    \n    # Step 1: Determine the integer floor and integer ceiling of the parsed floating-point number\n    floor_int = int(value)\n    ceil_int = int(value) + 1\n    \n    # Step 2: Calculate the absolute differences between the parsed floating-point number and its integer floor and integer ceiling\n    diff_floor = roundChecksum.round(abs(value - floor_int), 2)\n    diff_ceil = roundChecksum.round(abs(value - ceil_int), 2)\n    \n    # Step 3: Compare the absolute differences and round away from zero if equidistant\n    if diff_floor == diff_ceil:\n        return ceil_int if value > 0 else floor_int\n    else:\n        return ceil_int if diff_floor > diff_ceil else floor_int\n",
        "def closest_integer(value):\n    number = float(value)\n    rounded_number = round(number)\n    \n    if abs(number - rounded_number) == 0.5:\n        if number >= 0:\n            return int(number) + 1\n        else:\n            return int(number) - 1\n\n    return rounded_number\n",
        "def closest_integer(value):\n    value = float(value)\n    floor_value = int(value)\n    ceil_value = int(value) + 1\n    diff_floor = abs(value - floor_value)\n    diff_ceil = abs(value - ceil_value)\n    \n    if diff_floor == diff_ceil:\n        return ceil_value if value > 0 else floor_value\n    \n    return ceil_value if diff_ceil < diff_floor else floor_value\n",
        "def closest_integer(value):\n    value = value.strip()\n    \n    numerical_value = float(value)\n    \n    floor_value = int(numerical_value)\n    ceil_value = int(numerical_value) + 1\n\n    diff_floor = abs(numerical_value - floor_value)\n    diff_ceil = abs(ceil_value - numerical_value)\n    \n    # Decide which integer is closer or return the farthest from zero if equidistant\n    if diff_floor == diff_ceil:\n        if numerical_value < 0:\n            return ceil_value\n        else:\n            return floor_value\n    elif diff_floor < diff_ceil:\n        return floor_value\n    else:\n        return ceil_value\n",
        "import math\n\ndef closest_integer(value):\n    float_value = float(value)\n    floor_value = math.floor(float_value)\n    ceiling_value = math.ceil(float_value)\n    \n    distance_floor = abs(float_value - floor_value)\n    distance_ceiling = abs(ceiling_value - float_value)\n    \n    if distance_floor <= distance_ceiling:\n        return floor_value\n    else:\n        return ceiling_value\n"
    ],
    "HumanEval/100": [
        "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n    \n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n    stones_per_level = [n]  # Store the stones in the first level\n    current_stones = n\n    \n    for i in range(n - 1):  # Iterate n times for n levels of stones\n        if current_stones % 2 == 0:\n            current_stones += 1  # Next odd number of stones for even current stones\n        else:\n            current_stones += 2  # Next even number of stones for odd current stones\n        stones_per_level.append(current_stones)  # Store the stones in the next level\n\n    return stones_per_level\n",
        "def make_a_pile(n):\n    stones_per_level = [n]  # Step 1: Add the initial number of stones (n) to the list\n    \n    stones_count = n\n    for i in range(1, n):\n        if stones_count % 2 == 0:\n            stones_count += 1\n        else:\n            stones_count += 2\n        stones_per_level.append(stones_count)\n\n    return stones_per_level  # Step 3: Return the list containing the number of stones per level\n",
        "def make_a_pile(n):\n    stones_in_each_level = []\n    stones_in_each_level.append(n)\n    \n    current_level_stones = n\n    for _ in range(n - 1):\n        if current_level_stones % 2 == 0:\n            current_level_stones += 1\n        else:\n            current_level_stones += 2\n        stones_in_each_level.append(current_level_stones)\n    \n    return stones_in_each_level\n",
        "def make_a_pile(n):\n    stone_pile = [n]  # Append n to the list, representing the first level\n\n    for i in range(2, n+1):  # Loop from level 2 to n (inclusive)\n        if stone_pile[i-2] % 2 == 0:  # Check if the stones in the previous level are even\n            stone_pile.append(stone_pile[i-2] + 1)  # If even, add the next odd number of stones\n        else:\n            stone_pile.append(stone_pile[i-2] + 2)  # If odd, add the next even number of stones\n\n    return stone_pile\n",
        "def make_a_pile(n):\n    levels = [n]\n    current_stones = n\n    for i in range(1, n):\n        if current_stones % 2 == 0:\n            current_stones += i * 2\n        else:\n            current_stones += i * 2 + 1\n        levels.append(current_stones)\n    return levels\n"
    ],
    "HumanEval/101": [
        "def words_string(s):\n    # Step 1: Split the input string by commas and spaces\n    words = [word.strip() for word in s.replace(\",\", \" \").split() if word.strip()]  # Split by commas and spaces, then remove leading and trailing spaces and empty strings\n\n    return words\n",
        "def words_string(s):\n    words = s.replace(\",\", \" \").split()\n    words = [word for word in words if word != '']\n    return words\n",
        "def words_string(s):\n    words = [word.strip() for word in s.replace(',', ' ').split()]\n    return words\n",
        "def words_string(s):\n    words = s.replace(',', '').split()\n    return words\n",
        "def words_string(s):\n    words = s.replace(\", \", \" \").split()\n    return words\n"
    ],
    "HumanEval/102": [
        "def choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n    \"\"\"\n    max_even = -1\n    \n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    \n    return max_even\n",
        "def choose_num(x, y):\n    max_even = -1\n    largest_even = max(x, y)\n    \n    for num in range(min(x, y), largest_even + 1):\n        if num % 2 == 0 and num > max_even:\n            max_even = num\n\n    if max_even == -1:\n        return -1\n    else:\n        return max_even\n",
        "def choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n\n    max_even_num = -1\n\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            if num > max_even_num:\n                max_even_num = num\n\n    return max_even_num\n",
        "def choose_num(x, y):\n    if x > y:\n        x, y = y, x\n\n    even_number = -1\n    for num in range(y, x + 1):\n        if num % 2 == 0:\n            even_number = num\n            break\n\n    return even_number\n",
        "def choose_num(x, y):\n    if x <= 0 or y <= 0:\n        return -1\n\n    # Step 1: Check if both x and y are positive and even numbers\n    if x % 2 != 0:\n        x += 1  # Make x even if it's not already\n    if y % 2 != 0:\n        y -= 1  # Make y even if it's not already\n\n    # Step 2: Find the biggest even number in the range [x, y]\n    for i in range(y, x - 1, -2):\n        if i % 2 == 0:\n            return i\n\n    return -1  # No even number in the range\n"
    ],
    "HumanEval/103": [
        "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    \n    total_sum = sum(range(n, m + 1))\n    count = m - n + 1\n    average = total_sum / count\n    rounded_avg = round(average)\n    binary_avg = bin(rounded_avg)\n    \n    return binary_avg\n",
        "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    \n    total_sum = sum(range(n, m + 1))\n    average = total_sum / (m - n + 1)\n    rounded_average = round(average)\n    rounded_average_binary = bin(rounded_average)\n    return rounded_average_binary\n",
        "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    \n    avg = (n + m) / 2\n    rounded_avg = round(avg)\n    \n    return bin(rounded_avg)\n",
        "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    \n    # Calculate the sum of numbers from n to m\n    total = 0\n    count = 0\n    for i in range(n, m+1):\n        total += i\n        count += 1\n    \n    # Calculate the average\n    average = total / count\n    \n    # Round the average to the nearest integer and convert to binary\n    rounded_average = round(average)\n    \n    return bin(rounded_average)\n",
        "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    \n    sum_avg = sum(range(n, m + 1))\n    avg = round(sum_avg / (m - n + 1))\n    binary_avg = bin(avg)\n    \n    return binary_avg\n"
    ],
    "HumanEval/104": [
        "def unique_digits(x):\n    unique_list = []\n    sorted_list = sorted(x)\n    \n    for num in sorted_list:\n        all_odd = all(int(digit) % 2 != 0 for digit in str(num))\n        if all_odd:\n            unique_list.append(num)\n    \n    unique_list.sort()\n    \n    return unique_list\n",
        "def unique_digits(x):\n    result = []\n    if not x:\n        return result\n    \n    for num in x:\n        num_str = str(num)\n        \n        if any(int(digit) % 2 == 0 for digit in num_str):\n            continue\n        \n        result.append(num)\n    \n    return sorted(result)\n",
        "def unique_digits(x):\n    result = []\n    \n    for num in x:\n        has_even_digit = any(int(digit) % 2 == 0 for digit in str(num))\n        if not has_even_digit:\n            result.append(num)\n    \n    return sorted(result)\n",
        "def unique_digits(x):\n    result = []\n    \n    for num in x:\n        num_str = str(num)\n        has_even_digit = any(int(digit) % 2 == 0 for digit in num_str)\n        \n        if not has_even_digit:\n            result.append(num)\n    \n    result.sort()\n    \n    return result\n",
        "def unique_digits(x):\n    result = []\n    \n    for num in x:\n        has_even_digit = any(int(digit) % 2 == 0 for digit in str(num))\n        if not has_even_digit:\n            result.append(num)\n    \n    result.sort()\n    \n    return result\n"
    ],
    "HumanEval/105": [
        "def by_length(arr):\n    names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    \n    # Filter and sort the array\n    filtered_arr = sorted([num for num in arr if 1 <= num <= 9])\n    \n    # Reverse sorted array and replace with names\n    result = [names[num-1] for num in filtered_arr[::-1]]\n    \n    return result\n",
        "def by_length(arr):\n    if not arr:\n        return []\n    \n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    sorted_arr = sorted(filtered_arr)\n    reversed_arr = sorted_arr[::-1]\n    \n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    final_arr = [digit_names[num-1] for num in reversed_arr]\n    \n    return final_arr\n",
        "def by_length(arr):\n    if not arr:\n        return []\n    \n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    filtered_arr.sort()\n    filtered_arr.reverse()\n    words = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    result = [words[num] for num in filtered_arr]\n    return result\n",
        "def by_length(arr):\n    # Define a dictionary to map integers to their corresponding names\n    integer_to_name = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Filter out integers between 1 and 9 (inclusive) from the input array and sort these integers\n    filtered_arr = sorted([num for num in arr if 1 <= num <= 9])\n    \n    # Reverse the sorted array of integers\n    reversed_arr = filtered_arr[::-1]\n    \n    # Map each integer in the reversed array to its corresponding name using the dictionary\n    result_arr = [integer_to_name[num] for num in reversed_arr]\n    \n    return result_arr\n",
        "def by_length(arr):\n    num_to_word = {1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    \n    valid_digits = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    filtered_arr = list(filter(lambda x: x in valid_digits, arr))\n    sorted_arr = sorted(filtered_arr)\n    reversed_arr = sorted_arr[::-1]\n    \n    result = [num_to_word[num] for num in reversed_arr]\n    \n    return result\n"
    ],
    "HumanEval/106": [
        "import math\n\ndef f(n):\n    result = []  # Step 0: Create an empty list to store the output\n    \n    for i in range(1, n+1):  # Step 1: Run a loop from 1 to n (inclusive)\n        if i % 2 == 0:  # Step 2: Check if the current index is even\n            result.append(math.factorial(i))  # Step 3: Calculate the factorial of i and append it to the list\n        else:\n            result.append(sum(range(1, i+1)) )  # Step 5: Calculate the sum from 1 to i and append it to the list\n    \n    return result\n",
        "def f(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 != 0:\n            result.append(sum(range(1, i + 1)))\n        else:\n            result.append(factorial(i))\n    return result\n",
        "def f(n):\n    result = []\n    \n    for i in range(1, n+1):\n        if i % 2 == 0:\n            fact = 1\n            for j in range(1, i+1):\n                fact *= j\n            result.append(fact)\n        else:\n            result.append(sum(range(1, i+1)))\n    \n    return result\n",
        "import math\n\ndef f(n):\n    result = []\n    \n    for i in range(1, n+1):\n        if i % 2 == 0:\n            # Calculate and append the factorial of i if i is even\n            result.append(math.factorial(i//2))\n        else:\n            result.append(sum(range(1, i+1)))  # Calculate and append the sum of numbers from 1 to i if i is odd\n    \n    return result\n",
        "def f(n):\n    result = []\n    \n    for i in range(1, n+1):\n        if i % 2 == 0:\n            factorial = 1\n            for j in range(1, i+1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            result.append(sum(range(1, i+1)))\n    \n    return result\n"
    ],
    "HumanEval/107": [
        "def even_odd_palindrome(n: int) -> tuple:\n    def is_palindrome(num: int) -> bool:\n        return str(num) == str(num)[::-1]\n    \n    even_count: int = 0\n    odd_count: int = 0\n\n    for i in range(1, n+1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n                \n    return (even_count, odd_count)\n",
        "def even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n\n    for i in range(1, n+1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)\n",
        "def even_odd_palindrome(n):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)\n",
        "def even_odd_palindrome(n):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    even_count = 0\n    odd_count = 0\n    \n    for i in range(1, n+1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n                \n    return (even_count, odd_count)\n",
        "def even_odd_palindrome(n):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for num in range(1, n+1):\n        if is_palindrome(num):\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)\n"
    ],
    "HumanEval/108": [
        "def count_nums(arr):\n    def get_sum_of_digits(num):\n        return sum(int(digit) for digit in str(abs(num)))\n\n    count = 0\n    for num in arr:\n        if get_sum_of_digits(num) > 0:\n            count += 1\n\n    return count\n",
        "def count_nums(arr):\n    count = 0\n\n    for num in arr:\n        sum_of_digits = 0\n        for digit in str(num):\n            if digit.isdigit():\n                sum_of_digits += int(digit)\n        if sum_of_digits > 0:\n            count += 1\n\n    return count\n",
        "def count_nums(arr):\n    def sum_digits(num):\n        return sum(int(d) for d in str(abs(num)))\n\n    count = 0\n    for num in arr:\n        if sum_digits(num) > 0:\n            count += 1\n\n    return count\n",
        "def count_nums(arr):\n    def get_sum_of_digits(num):\n        abs_num = abs(num)\n        sum_digits = sum(int(digit) for digit in str(abs_num))\n        \n        return sum_digits if num >= 0 else -sum_digits\n\n    count = 0\n    for num in arr:\n        if get_sum_of_digits(num) > 0:\n            count += 1\n\n    return count\n",
        "def sum_of_digits(n):\n    return sum(int(d) for d in str(abs(n)))\n\ndef count_nums(arr):\n    count = 0\n    for num in arr:\n        if sum_of_digits(num) > 0:\n            count += 1\n    \n    return count\n"
    ],
    "HumanEval/109": [
        "def move_one_ball(arr):\n    if not arr:\n        return True\n\n    min_val = min(arr)\n    min_idx = arr.index(min_val)\n    \n    if min_idx == 0:\n        return True\n    \n    shifts_required = len(arr) - min_idx\n\n    sorted_arr = arr[-shifts_required:] + arr[:-shifts_required]\n\n    if sorted_arr == sorted(arr):\n        return True\n    \n    return False\n",
        "def move_one_ball(arr):\n    if not arr:\n        return True\n\n    min_idx = arr.index(min(arr))\n\n    is_sorted = all(arr[i] <= arr[i+1] for i in range(len(arr) - 1))\n    if is_sorted:\n        return True\n\n    if min_idx == len(arr) - 1:\n        return True\n    else:\n        return False\n",
        "def move_one_ball(arr):\n    if not arr:  # Step 0: Check if the input array is empty\n        return True\n    \n    # Step 1: Find the index of the minimum element in the array\n    min_index = arr.index(min(arr))\n    \n    # Step 2: Calculate the number of right shifts needed to bring the minimum element to the first position\n    num_shifts = len(arr) - min_index\n    \n    # Step 4: Create a new array by performing the right shifts\n    new_arr = arr[-min_index:] + arr[:-min_index]\n    \n    # Step 5: Check if the new array is sorted in non-decreasing order\n    is_sorted = all(new_arr[i] <= new_arr[i+1] for i in range(len(new_arr)-1))\n    \n    return is_sorted\n",
        "def move_one_ball(arr):\n    if not arr:\n        return True\n\n    min_index = arr.index(min(arr))\n\n    # Check if the array is already sorted\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i+1]:\n            break\n    else:\n        return True\n    \n    num_shifts = len(arr) - min_index\n    if num_shifts == len(arr):\n        num_shifts = 0\n\n    new_arr = arr[-min_index:] + arr[:-min_index]\n\n    for i in range(len(new_arr) - 1):\n        if new_arr[i] > new_arr[i + 1]:\n            return False\n\n    return True\n",
        "def move_one_ball(arr):\n    # Step 0: Check if the array is already sorted\n    if arr == sorted(arr):\n        return True\n    \n    # Step 1: Find the index of the minimum element in the array\n    min_index = arr.index(min(arr))\n    \n    # Step 2: Handle multiple occurrences of the minimum element\n    next_min_index = arr[min_index+1:].index(min(arr)) + min_index + 1 if min(arr) in arr[min_index+1:] else min_index\n    \n    # Step 3: Check if elements to the left of the minimum element are sorted\n    if arr[:min_index] == sorted(arr[:min_index]):\n        \n        # Step 4: Check if elements to the right of the minimum element are sorted\n        if arr[min_index+1:] == sorted(arr[min_index+1:]):\n            return True\n    \n    return False\n"
    ],
    "HumanEval/110": [
        "def exchange(lst1, lst2):\n    if not lst1 or not lst2:\n        return \"NO\"\n    \n    for num in lst1:\n        if num % 2 != 0:\n            for num2 in lst2:\n                if num2 % 2 == 0:\n                    lst1[lst1.index(num)], lst2[lst2.index(num2)] = num2, num\n                    break\n    \n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    else:\n        return \"NO\"\n",
        "def exchange(lst1, lst2):\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    \n    odd_count = sum(1 for num in lst1 if num % 2 != 0)\n    if odd_count == 0:\n        return \"NO\"\n    \n    even_count = sum(1 for num in lst2 if num % 2 == 0)\n    \n    if odd_count >= even_count:\n        return \"YES\"\n    else:\n        return \"NO\"\n",
        "def exchange(lst1, lst2):\n    if all(x % 2 == 0 for x in lst1):\n        return \"YES\"  # No exchange needed\n\n    odd_count_lst1 = sum(1 for x in lst1 if x % 2 != 0)\n    odd_count_total = odd_count_lst1 + sum(1 for x in lst2 if x % 2 != 0)\n\n    if odd_count_total >= odd_count_lst1:\n        return \"YES\"  # There are enough odd elements in lst2 to exchange with lst1\n    else:\n        return \"NO\"  # Not enough odd elements in lst2 for the exchange\n",
        "def exchange(lst1, lst2):\n    odd_count_lst1 = sum(1 for num in lst1 if num % 2 != 0)\n    odd_count_lst2 = sum(1 for num in lst2 if num % 2 != 0)\n    even_count_lst2 = sum(1 for num in lst2 if num % 2 == 0)\n\n    if odd_count_lst1 <= odd_count_lst2 + even_count_lst2:\n        return \"YES\"\n    else:\n        return \"NO\"\n",
        "def exchange(lst1, lst2):\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    \n    odd_in_lst1 = [num for num in lst1 if num % 2 != 0]\n    even_in_lst2 = [num for num in lst2 if num % 2 == 0]\n\n    if len(odd_in_lst1) > len(even_in_lst2):\n        return \"NO\"\n\n    return \"YES\"\n"
    ],
    "HumanEval/111": [
        "def histogram(test):\n    test = test.replace(\" \", \"\").lower()\n    letter_counts = {}\n    \n    for letter in test:\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n            \n    max_count = max(letter_counts.values()) if letter_counts else 0\n    max_letters = {letter: count for letter, count in letter_counts.items() if count == max_count}\n    \n    return max_letters\n",
        "def histogram(test):\n    \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n    \"\"\"\n    \n    letters = test.split()\n\n    letter_count = {}\n    \n    for letter in letters:\n        if letter in letter_count:\n            letter_count[letter] += 1\n        else:\n            letter_count[letter] = 1\n    \n    max_count = max(letter_count.values()) if letter_count else 0\n    \n    most_repeated_letters = {key: value for key, value in letter_count.items() if value == max_count}\n    \n    return most_repeated_letters\n",
        "def histogram(test):\n    letters = test.split()\n    letter_count = {}\n    \n    for letter in letters:\n        if letter in letter_count:\n            letter_count[letter] += 1\n        else:\n            letter_count[letter] = 1\n    \n    max_count = max(letter_count.values())\n    \n    max_letters = {letter: count for letter, count in letter_count.items() if count == max_count}\n    \n    return max_letters\n",
        "def histogram(test):\n    letter_count = {letter: 0 for letter in set(test.replace(\" \", \"\").lower()) if letter.isalpha()}\n\n    for letter in test.replace(\" \", \"\").lower():\n        if letter in letter_count:\n            letter_count[letter] += 1\n\n    max_count = max(letter_count.values())\n    max_letters = {letter: count for letter, count in letter_count.items() if count == max_count}\n\n    return max_letters\n",
        "def histogram(test):\n    letters = test.split()\n    letter_count = {}\n    for letter in letters:\n        if letter in letter_count:\n            letter_count[letter] += 1\n        else:\n            letter_count[letter] = 1\n    result = {letter: count for letter, count in letter_count.items() if count == max(letter_count.values())}\n    return result\n"
    ],
    "HumanEval/112": [
        "def reverse_delete(s, c):\n    def remove_characters(s, c):\n        return \"\".join(char for char in s if char not in c)\n\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    modified_s = remove_characters(s, c)\n    is_palindrome_result = is_palindrome(modified_s)\n\n    return modified_s, is_palindrome_result\n",
        "def reverse_delete(s, c):\n    filtered_s = ''.join(char for char in s if char not in c)\n    is_palindrome = filtered_s == filtered_s[::-1]\n    return filtered_s, is_palindrome\n",
        "def is_palindrome(s):\n    return s == s[::-1]\n",
        "def reverse_delete(s, c):\n    result_string = ''.join(char for char in s if char not in c)\n    is_palindrome = result_string == result_string[::-1]\n    return result_string, is_palindrome\n",
        "def reverse_delete(s, c):\n    def delete_chars_from_string(s, chars_to_delete):\n        result = \"\"\n        for char in s:\n            if char not in chars_to_delete:\n                result += char\n        return result\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    result_string = delete_chars_from_string(s, c)\n    is_palindrome_result = is_palindrome(result_string)\n\n    return result_string, is_palindrome_result\n"
    ],
    "HumanEval/113": [
        "def odd_count(lst):\n    if not lst or not all(isinstance(x, str) and x.isdigit() for x in lst):\n        return []\n    else:\n        result = []\n        for i in lst:\n            odd_count = sum(int(digit) % 2 != 0 for digit in i)\n            result.append(\"the number of odd elements in the string {} of the input.\".format(odd_count))\n        return result\n",
        "def odd_count(lst):\n    result = []  \n    for num in lst:\n        count = 0  \n        for char in num:\n            if int(char) % 2 != 0:\n                count += 1  \n        result.append(f\"the number of odd elements {count} in the str{count}ng {num} of the {count}nput.\")\n    return result\n",
        "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    results = []\n    \n    for string in lst:\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        result_string = f\"the number of odd elements in the string {odd_count} of the input.\"\n        results.append(result_string)\n    \n    return results\n",
        "def odd_count(lst):\n    result = []  # Initialize an empty list to store the results\n    for string in lst:\n        odd_count = sum(1 for char in string if int(char) % 2 != 0)\n        output_str = f\"the number of odd elements {odd_count}n the str{odd_count}ng {string} of the {odd_count}nput.\"\n        result.append(output_str)  # Append the modified string to the result list\n    return result  # Return the list of modified strings\n",
        "def odd_count(lst):\n    result = []\n    \n    for string in lst:\n        odd_count = len([digit for digit in string if int(digit) % 2 != 0])\n        replaced_sentence = f\"the number of odd elements {odd_count} in the string {odd_count} of the input.\"\n        result.append(replaced_sentence)\n    \n    return result\n"
    ],
    "HumanEval/114": [
        "        min_sum = min(min_sum, current_sum)\n    return min_sum\n",
        "def minSubArraySum(nums):\n    min_sum = float('inf')  # Initialize min_sum to infinity\n    current_sum = 0  # Initialize current_sum to 0\n    \n    for num in nums:\n        current_sum = max(num, num + current_sum)  # Update current_sum\n        min_sum = min(min_sum, current_sum)  # Update min_sum\n        \n    return min_sum  # Return min_sum\n",
        "def minSubArraySum(nums):\n    min_sum = float('inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n        current_sum = max(current_sum, 0)\n\n    return min_sum\n",
        "def minSubArraySum(nums):\n    min_sum = float('inf')\n    \n    cur_sum = 0\n    for num in nums:\n        cur_sum = max(num, cur_sum + num)\n        min_sum = min(min_sum, cur_sum)\n    \n    return min_sum\n",
        "def minSubArraySum(nums):\n    min_sum = float('inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n        current_sum = max(current_sum, 0)\n    \n    return min_sum\n"
    ],
    "HumanEval/115": [
        "def max_fill(grid, capacity):\n    import math\n    \n    total_buckets = 0\n    \n    for well in grid:\n        total_water = sum(well)\n        well_buckets = math.ceil(total_water / capacity)\n        total_buckets += well_buckets\n    \n    return total_buckets\n",
        "def max_fill(grid, capacity):\n    count = 0\n    for row in grid:\n        for well in row:\n            while well > 0:\n                well -= min(capacity, well)\n                count += 1\n    return count\n",
        "def max_fill(grid, capacity):\n    total_operations = 0\n\n    # Iterating over each well in the grid to calculate the total units exceeding the bucket capacity\n    for row in grid:\n        for well in row:\n            if well > 0:\n                total_operations += -(-well // capacity)\n    \n    return total_operations\n",
        "import math\n\ndef max_fill(grid, capacity):\n    total_wells = len(grid)\n    units_per_well = len(grid[0])\n    \n    total_times_fill_needed = 0\n    \n    for col in range(units_per_well):\n        for row in range(total_wells):\n            if grid[row][col] == 1:\n                total_times_fill_needed += 1\n    \n    total_water_to_extract = total_times_fill_needed * capacity\n\n    total_times_bucket_empty = math.ceil(total_water_to_extract / capacity)\n    \n    return total_times_bucket_empty\n",
        "def max_fill(grid, capacity):\n    total_water = sum(sum(row) for row in grid)\n    num_times = total_water // capacity + (1 if total_water % capacity != 0 else 0)\n    return num_times\n"
    ],
    "HumanEval/116": [
        "def sort_array(arr):\n    def count_ones(num):\n        return bin(num).count('1')\n    \n    arr.sort(key=lambda x: (count_ones(x), x))\n    return arr\n",
        "def sort_array(arr):\n    def count_ones(num):\n        return bin(num).count('1')\n\n    def custom_sort_key(num):\n        return count_ones(num), num\n\n    return sorted(arr, key=custom_sort_key)\n",
        "def sort_array(arr):\n    def count_ones(num):\n        return bin(num).count('1')\n\n    arr.sort(key=lambda x: (count_ones(x), x))\n    \n    return arr\n",
        "def sort_array(arr):\n    def count_ones(num):\n        return bin(num).count('1')\n\n    return sorted(arr, key=lambda x: (count_ones(x), x))\n",
        "def sort_array(arr):\n    def custom_sort(num):\n        return bin(num).count('1'), num\n    \n    non_negative_arr = [num for num in arr if num >= 0]\n    sorted_arr = sorted(non_negative_arr, key=custom_sort)\n    \n    return sorted_arr\n"
    ],
    "HumanEval/117": [
        "def select_words(s, n):\n    def count_consonants(word):\n        consonants = \"bcdfghjklmnpqrstvwxyz\"\n        return sum(1 for char in word if char.lower() in consonants)\n\n    words = s.split()\n    consonant_words = [word for word in words if count_consonants(word) == n]\n    return consonant_words\n",
        "def select_words(s, n):\n    words = s.split()\n\n    def count_consonants(word):\n        consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        return sum(1 for letter in word if letter in consonants)\n\n    def has_n_consonants(word, n):\n        return count_consonants(word) == n\n\n    return [word for word in words if has_n_consonants(word, n)]\n",
        "def select_words(s, n):\n    def count_consonants(word):\n        consonants = \"bcdfghjklmnpqrstvwxyz\"\n        return len([letter for letter in word.lower() if letter in consonants])\n\n    words = s.split()  # Step 0: Split the input string into words\n\n    filtered_words = [word for word in words if count_consonants(word) == n]  # Step 2: Filter out words with n consonants\n    return filtered_words\n",
        "def select_words(s, n):\n    words = s.split()\n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    result = []\n  \n    for word in words:\n        count = sum(1 for letter in word if letter in consonants)\n        if count == n:\n            result.append(word)\n    \n    return result\n",
        "def count_consonants(word):\n    return sum(1 for letter in word if letter.isalpha() and letter.lower() not in 'aeiou')\n\n\ndef select_words(s, n):\n    words = s.split()\n    result = []\n\n    for word in words:\n        consonant_count = count_consonants(word)\n        \n        if consonant_count == n:\n            result.append(word)\n    \n    return result\n"
    ],
    "HumanEval/118": [
        "def get_closest_vowel(word):\n    if len(word) < 3:\n        return \"\"\n    \n    vowels = set('aeiouAEIOU')\n\n    for i in range(len(word)-2, 0, -1):\n        if word[i] not in vowels and word[i-1] in vowels and word[i+1] in vowels:\n            return word[i]\n    \n    return \"\"\n",
        "def get_closest_vowel(word):\n    vowels = set('AEIOUaeiou')\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] not in vowels and word[i-1] in vowels and word[i+1] in vowels:\n            return word[i]\n    return \"\"\n",
        "def get_closest_vowel(word):\n    vowels = set(\"aeiouAEIOU\")\n    \n    for i in range(len(word) - 1, 0, -1):  # from the last character (excluding) to the second character\n        if word[i].isalpha() and not word[i].lower() in vowels:  # check for consonant\n            if word[i-1].isalpha() and not word[i-1].lower() in vowels and word[i+1].isalpha() and not word[i+1].lower() in vowels:\n                for v in range(i+1, len(word)):\n                    if word[v].isalpha() and word[v].lower() in vowels:\n                        return word[v]\n    \n    return \"\"\n",
        "def is_consonant(char):\n    return char.isalpha() and char.lower() not in ['a', 'e', 'i', 'o', 'u']\n\ndef get_closest_vowel(word):\n    found_consonant = False\n    closest_vowel = \"\"\n    for char in reversed(word):\n        if is_consonant(char):\n            found_consonant = True\n        elif found_consonant and char.isalpha() and not is_consonant(char):\n            closest_vowel = char\n            break\n\n    return closest_vowel\n",
        "def get_closest_vowel(word):\n    if len(word) < 3:\n        return \"\"\n\n    vowels = set(\"AEIOUaeiou\")\n    \n    for i in range(1, len(word) - 1):\n        if word[i] not in vowels and word[i-1] in vowels and word[i+1] in vowels:\n            return word[i]\n    \n    return \"\"\n"
    ],
    "HumanEval/119": [
        "def match_parens(lst):\n    str1, str2 = lst\n    balance = 0\n\n    for char in str1 + str2:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return 'No'  # Unbalanced parentheses detected\n        \n    return 'Yes' if balance == 0 else 'No'\n",
        "def match_parens(lst):\n    balance = 0\n\n    for s in lst:\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return 'No'\n\n    return 'Yes'\n",
        "def match_parens(lst):\n    concat_string = lst[0] + lst[1]\n    open_count = 0\n\n    for char in concat_string:\n        if char == '(':\n            open_count += 1\n        elif char == ')':\n            open_count -= 1\n            if open_count < 0:\n                return 'No'\n\n    if open_count == 0:\n        return 'Yes'\n    else:\n        return 'No'\n",
        "def match_parens(lst):\n    open_count = close_count = 0\n\n    for string in lst:\n        for char in string:\n            if char == '(':\n                open_count += 1\n            elif char == ')':\n                close_count += 1\n                \n            if close_count > open_count:\n                return 'No'\n    \n    if open_count != close_count:\n        return 'No'\n    else:\n        return 'Yes'\n",
        "def match_parens(lst):\n    open_count = lst[0].count('(') + lst[1].count('(')\n    close_count = lst[0].count(')') + lst[1].count(')')\n    \n    balance_diff = open_count - close_count\n    \n    if balance_diff % 2 == 0:\n        for i in range(len(lst)):\n            if balance_diff == 0:\n                break\n            for j in range(len(lst[i])):\n                if lst[i][j] == '(':\n                    balance_diff -= 1\n                    lst[i] = lst[i][:j] + lst[i][j+1:]\n                    break\n        \n        if balance_diff == 0:\n            for s in lst:\n                for c in s:\n                    if c == ')':\n                        return 'No'\n            return 'Yes'\n    \n    return 'No'\n\n# Test the function with examples\n\n\n"
    ],
    "HumanEval/120": [
        "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return arr[:k]\n",
        "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    arr.sort()\n    return arr[-k:]\n",
        "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    max_numbers = []\n    arr.sort(reverse=True)\n    max_numbers = arr[:k]\n    return max_numbers\n",
        "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return arr[:k]\n",
        "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return arr[:k]\n"
    ],
    "HumanEval/121": [
        "def solution(lst):\n    sum_of_odd_at_even_positions = 0\n    \n    if not lst:\n        return 0\n    \n    for index, num in enumerate(lst):\n        if index % 2 == 0 and num % 2 != 0:\n            sum_of_odd_at_even_positions += num\n    \n    return sum_of_odd_at_even_positions\n",
        "def solution(lst):\n    total_sum = 0\n    \n    for i in range(len(lst)):\n        if lst[i] % 2 != 0 and i % 2 == 0:\n            total_sum += lst[i]\n    \n    return total_sum\n",
        "def solution(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 != 0)\n",
        "def solution(lst):\n    odd_elements_sum = 0\n    for index, num in enumerate(lst):\n        if num % 2 != 0 and index % 2 == 0:  # Check if the element is odd and the index is even\n            odd_elements_sum += num  # Add the odd element to the sum\n\n    return odd_elements_sum\n",
        "def solution(lst):\n    total_sum = 0\n    \n    for i in range(len(lst)):\n        if lst[i] % 2 != 0 and i % 2 == 0:\n            total_sum += lst[i]\n    \n    return total_sum\n"
    ],
    "HumanEval/122": [
        "def add_elements(arr, k):\n    if len(arr) < 1 or k < 1 or k > len(arr):\n        return \"Invalid input\"\n\n    sum_elements = 0\n\n    for i in range(k):\n        if arr[i] >= 10 and arr[i] <= 99:\n            sum_elements += arr[i]\n\n    return sum_elements\n",
        "    return sum_two_digits\n",
        "def add_elements(arr, k):\n    sum_two_digits = 0\n    for i in range(k):\n        if 10 <= abs(arr[i]) < 100:\n            sum_two_digits += arr[i]\n    return sum_two_digits\n",
        "    return sum_two_digits\n",
        "def add_elements(arr, k):\n    total = 0\n    \n    for i in range(k):\n        element = arr[i]\n        if 10 <= abs(element) < 100:\n            total += element\n            \n    return total\n"
    ],
    "HumanEval/123": [
        "def get_odd_collatz(n):\n    odd_numbers = []\n\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            odd_numbers.append(n)\n            n = 3*n + 1\n\n    if n % 2 != 0:  # Check if the last number is odd\n        odd_numbers.append(n)\n\n    return sorted(odd_numbers)\n",
        "def get_odd_collatz(n):\n    odd_numbers = []\n    collatz_seq = [n]\n    \n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_seq.append(n)\n        \n    for num in collatz_seq:\n        if num % 2 != 0 and num != 1:\n            odd_numbers.append(num)\n    \n    odd_numbers.sort()\n    \n    return odd_numbers\n",
        "def get_odd_collatz(n):\n    odd_collatz_list = []\n    \n    while n != 1:\n        if n % 2 == 1:\n            odd_collatz_list.append(n)\n        \n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    \n    if n % 2 == 1:  # Add n when n reaches 1\n        odd_collatz_list.append(n)\n    \n    odd_collatz_list.sort()\n    return odd_collatz_list\n\n# Test the function\n\n",
        "def get_odd_collatz(n):\n    if not isinstance(n, int) or n <= 0:\n        return []\n\n    odd_collatz = []\n    \n    while n != 1:\n        if n % 2 != 0:\n            odd_collatz.append(n)\n        \n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n\n    if n % 2 != 0:\n        odd_collatz.append(n)\n    \n    return sorted(odd_collatz)\n",
        "def get_odd_collatz(n):\n    collatz_sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_sequence.append(n)\n    return sorted(filter(lambda x: x % 2 != 0, collatz_sequence))\n"
    ],
    "HumanEval/124": [
        "def valid_date(date):\n    if date == '':\n        return False\n    else:\n        date_parts = date.split('-')\n        if len(date_parts) != 3:\n            return False\n        else:\n            month = int(date_parts[0])\n            day = int(date_parts[1])\n            year = int(date_parts[2])\n\n            if month < 1 or month > 12:\n                return False\n            else:\n                if month in [1, 3, 5, 7, 8, 10, 12]:\n                    if day < 1 or day > 31:\n                        return False\n                elif month in [4, 6, 9, 11]:\n                    if day < 1 or day > 30:\n                        return False\n                elif month == 2:\n                    if day < 1 or day > 29:\n                        return False\n\n            return True\n",
        "def valid_date(date):\n    if not date:\n        return False\n        \n    date_parts = date.split(\"-\")\n    if len(date_parts) != 3:\n        return False\n    \n    month, day, year = date_parts\n    \n    try:\n        month = int(month)\n        day = int(day)\n        year = int(year)\n    except ValueError:\n        return False\n    \n    if not(1 <= month <= 12):\n        return False\n    \n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        max_days = 31\n    elif month in [4, 6, 9, 11]:\n        max_days = 30\n    else:\n        max_days = 29 if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0) else 28\n\n    if not(1 <= day <= max_days):\n        return False\n    \n    return True\n",
        "import re\n\ndef valid_date(date):\n    if not date:\n        return False\n    \n    date_parts = date.split('-')\n    \n    if len(date_parts) != 3:\n        return False\n    \n    month, day, year = date_parts\n    \n    if not all(part.isdigit() for part in date_parts):\n        return False\n    \n    month = int(month)\n    \n    if month < 1 or month > 12:\n        return False\n    \n    day = int(day)\n    \n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:  # Consider leap years separately\n            return False\n    else:\n        return False\n    \n    if not re.match(r'^\\d{2}-\\d{2}-\\d{4}$', date):\n        return False\n    \n    return True\n",
        "def valid_date(date):\n    if not date:\n        return False\n    \n    date_components = date.split('-')\n    if len(date_components) != 3:\n        return False\n\n    month = int(date_components[0])\n    if month < 1 or month > 12:\n        return False\n\n    day = int(date_components[1])\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    else:\n        return False\n\n    return True\n",
        "def valid_date(date):\n    if not date:\n        return False\n    \n    date_parts = date.split('-')\n    if len(date_parts) != 3:\n        return False\n    \n    month, day, year = date_parts\n    \n    try:\n        month = int(month)\n        day = int(day)\n        year = int(year)\n    except ValueError:\n        return False\n    \n    if month < 1 or month > 12:\n        return False\n\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        max_days = 31\n    elif month in [4, 6, 9, 11]:\n        max_days = 30\n    else:\n        if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:\n            max_days = 29\n        else:\n            max_days = 28\n    \n    if day < 1 or day > max_days:\n        return False\n    \n    if year <= 0:\n        return False\n\n    return True\n"
    ],
    "HumanEval/125": [
        "def split_words(txt):\n    is_whitespace_present = ' ' in txt\n    \n    if is_whitespace_present:\n        return txt.split()\n    else:\n        is_comma_present = ',' in txt\n        \n        if is_comma_present:\n            return txt.split(',')\n        else:\n            count_odd_lowercase = sum(1 for char in txt if 'a' <= char <= 'z' and ord(char) % 2 != 0)\n            return count_odd_lowercase\n",
        "def split_words(txt):\n    if ' ' in txt:\n        return txt.split()\n    \n    if ',' in txt:\n        return txt.split(',')\n\n    count = sum(1 for char in txt if char.islower() and ord(char) % 2 != 0)\n    return count\n",
        "def split_words(txt):\n    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.split(\",\")\n    else:\n        count = sum(1 for char in txt if char.islower() and ord(char) % 2 == 1)\n        return count if count > 0 else \"No lowercase letters with odd order in the alphabet\"\n",
        "def split_words(txt):\n    has_whitespace = ' ' in txt\n    \n    if has_whitespace:\n        words = txt.split()\n        return words\n    \n    has_commas = ',' in txt\n    \n    if not has_whitespace and has_commas:\n        words = txt.split(',')\n        return [word.strip() for word in words]\n    \n    if not has_whitespace and not has_commas:\n        count_odd_lower_case_letters = 0\n        txt_lower = txt.lower()\n        \n        for char in txt_lower:\n            if char.islower() and ord(char) % 2 != 0:\n                count_odd_lower_case_letters += 1\n        \n        return count_odd_lower_case_letters\n",
        "def split_words(txt):\n    if ' ' in txt:\n        words = txt.split()\n    elif ',' in txt:\n        words = txt.split(',')\n    else:\n        odd_count = sum(1 for char in txt if char.islower() and ord(char) % 2 != 0)\n        return odd_count\n    \n    return words\n"
    ],
    "HumanEval/126": [
        "def is_sorted(lst):\n    for num in lst:\n        if lst.count(num) > 1:\n            return False\n    return lst == sorted(lst)\n",
        "def is_sorted(lst):\n    def has_more_than_one_duplicate(lst):\n        for num in lst:\n            if lst.count(num) > 2:  # Check if any number has more than two occurrences\n                return True\n        return False\n\n    def is_sorted_ascending(lst):\n        return all(lst[i] <= lst[i + 1] for i in range(len(lst) - 1))\n\n    return not has_more_than_one_duplicate(lst) and is_sorted_ascending(lst)\n",
        "def is_sorted(lst):\n    prev = None\n    duplicates = set()\n    \n    for num in lst:\n        if num == prev:\n            duplicates.add(num)\n        elif num < prev:\n            return False\n        prev = num\n    \n    if len(duplicates) > 1:\n        return False\n    \n    return True\n",
        "def has_duplicates(lst):\n    num_count = {}\n    for num in lst:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n    \n    for count in num_count.values():\n        if count > 1:\n            return True\n    \n    return False\n\ndef is_sorted(lst):\n    if has_duplicates(lst):\n        return False\n    \n    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1)\n",
        "def is_sorted(lst):\n    def has_duplicate(lst):\n        count_dict = {}\n        for num in lst:\n            if num in count_dict:\n                count_dict[num] += 1\n            else:\n                count_dict[num] = 1\n        \n        for count in count_dict.values():\n            if count > 1:\n                return True\n        \n        return False\n    \n    if has_duplicate(lst):\n        return False\n    \n    sorted_lst = sorted(lst)\n    return lst == sorted_lst\n"
    ],
    "HumanEval/127": [
        "def is_prime(num):\n    if num < 2:\n        return False\n    \n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    \n    return True\n\ndef intersection(interval1, interval2):\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n\n    if start > end:\n        return \"NO\"\n    \n    length = end - start + 1\n\n    if is_prime(length):\n        return \"YES\"\n    else:\n        return \"NO\"\n",
        "def intersection(interval1, interval2):\n    def is_prime(number):\n        if number < 2:\n            return False\n        for i in range(2, int(number ** 0.5) + 1):\n            if number % i == 0:\n                return False\n        return True\n\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n\n    if start > end:\n        return \"NO\"\n\n    length = end - start + 1\n\n    if is_prime(length):\n        return \"YES\"\n    else:\n        return \"NO\"\n",
        "def intersection(interval1, interval2):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    \n    if start > end:\n        return \"NO\"  # No intersection\n    \n    length = end - start + 1\n    \n    if is_prime(length):\n        return \"YES\"\n    else:\n        return \"NO\"\n",
        "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef intersection(interval1, interval2):\n    start1, end1 = min(interval1), max(interval1)\n    start2, end2 = min(interval2), max(interval2)\n    \n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    \n    if intersect_start > intersect_end:\n        return \"NO\"\n    \n    intersection_length = intersect_end - intersect_start\n    \n    if is_prime(intersection_length):\n        return \"YES\"\n    else:\n        return \"NO\"\n",
        "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef intersection(interval1, interval2):\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    \n    if start > end:\n        return \"NO\"\n    \n    length = end - start\n    \n    if is_prime(length):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    ],
    "HumanEval/128": [
        "def prod_signs(arr):\n    if not arr:  # Step 0: Check if the input array is empty\n        return None\n    \n    result = 0  # Step 1: Initialize a variable `result` to 0\n    sum_magnitude = 0  # Step 4: Initialize a variable `sum_magnitude` to 0\n    \n    for num in arr:\n        # Step 2: Calculate the product of signs and sum of magnitudes concurrently\n        if num > 0:\n            result += num\n            sum_magnitude += abs(num)\n        elif num < 0:\n            result -= num\n            sum_magnitude += abs(num)\n    \n    return result  # Step 3: Return the `result`\n",
        "def prod_signs(arr):\n    if not arr:\n        return None\n    \n    sign_product = 1\n    sum_magnitudes = 0\n    \n    for num in arr:\n        if num > 0:\n            sum_magnitudes += abs(num)\n        elif num < 0:\n            sum_magnitudes -= abs(num)\n        sign_product *= 1 if num > 0 else (-1 if num < 0 else 0)\n    \n    return sign_product * sum_magnitudes\n",
        "def prod_signs(arr):\n    if not arr:\n        return None\n    \n    sign_product = 1\n    sum_magnitudes = 0\n    \n    for num in arr:\n        if num == 0:\n            continue\n        elif num > 0:\n            sum_magnitudes += num\n            sign_product *= 1\n        else:\n            sum_magnitudes += abs(num)\n            sign_product *= -1\n    \n    return sum_magnitudes * sign_product\n",
        "def prod_signs(arr):\n    if not arr:\n        return None\n\n    sign_prod = 1\n    sum_magnitudes = 0\n\n    for num in arr:\n        sign_prod *= 1 if num > 0 else -1 if num < 0 else 0\n        sum_magnitudes += abs(num)\n\n    return sign_prod * sum_magnitudes\n",
        "def prod_signs(arr):\n    if not arr:\n        return None\n    \n    product_sign = 1\n    \n    for num in arr:\n        if num > 0:\n            product_sign *= 1\n        elif num < 0:\n            product_sign *= -1\n        else:  # for num == 0\n            product_sign *= 0\n    \n    total_magnitude = sum(abs(num) for num in arr)\n    return product_sign * total_magnitude\n"
    ],
    "HumanEval/129": [
        "def minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with your current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exists an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path goes through.\n    \"\"\"\n    \n    n_rows = len(grid)\n    n_cols = len(grid[0])\n    \n    def get_neighbors(grid, row, col):\n        neighbors = []\n        if row > 0:\n            neighbors.append((row - 1, col))  # Top neighbor\n        if row < n_rows - 1:\n            neighbors.append((row + 1, col))  # Bottom neighbor\n        if col > 0:\n            neighbors.append((row, col - 1))  # Left neighbor\n        if col < n_cols - 1:\n            neighbors.append((row, col + 1))  # Right neighbor\n        return neighbors\n    \n    def find_min_path(grid, row, col, k, path):\n        if k == 0:\n            return path\n\n        neighbors = get_neighbors(grid, row, col)\n        next_cell = None\n        for neighbor in neighbors:\n            next_row, next_col = neighbor\n            if grid[next_row][next_col] not in path:\n                next_cell = neighbor\n                break\n\n        if next_cell:\n            return find_min_path(grid, next_cell[0], next_cell[1], k - 1, path + [grid[next_cell[0]][next_cell[1]])\n        else:\n            return []\n    \n    min_path = []\n    for i in range(n_rows):\n        for j in range(n_cols):\n            path = find_min_path(grid, i, j, k - 1, [grid[i][j]])\n            if path and (not min_path or path < min_path):\n                min_path = path\n\n    return min_path\n",
        "def minPath(grid, k):\n    def get_neighbors(cell):\n        neighbors = []\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # right, left, down, up\n    \n        for dx, dy in directions:\n            new_x, new_y = cell[0] + dx, cell[1] + dy\n            if 0 <= new_x < len(grid) and 0 <= new_y < len(grid[0]):\n                neighbors.append((new_x, new_y))\n        \n        return neighbors\n\n    def dfs(cell, path):\n        if len(path) == k:\n            return path\n        \n        neighbors = get_neighbors(cell)\n        min_path = None\n        \n        for neighbor in neighbors:\n            if neighbor not in path:\n                new_path = dfs(neighbor, path + [neighbor])\n                if min_path is None or new_path < min_path:\n                    min_path = new_path\n        \n        return min_path\n\n    start_cell = find_starting_cell(grid)\n    return [grid[cell[0]][cell[1]] for cell in dfs(start_cell, [start_cell])]\n",
        "def minPath(grid, k):\n    def get_neighbors(grid, row, col):\n        neighbors = []\n        rows, cols = len(grid), len(grid[0])\n\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                neighbors.append((new_row, new_col))\n\n        return neighbors\n\n    def find_min_path(grid, k, start_row, start_col):\n        rows, cols = len(grid), len(grid[0])\n\n        def backtrack(row, col, path):\n            if len(path) == k:\n                return path\n\n            neighbors = get_neighbors(grid, row, col)\n            paths = []\n            for new_row, new_col in neighbors:\n                if (new_row, new_col) not in path:\n                    new_path = backtrack(new_row, new_col, path + [(new_row, new_col)])\n                    if new_path:\n                        paths.append(new_path)\n\n            if paths:\n                return min(paths)\n            return None\n\n        return [grid[start_row][start_col]] + backtrack(start_row, start_col, [(start_row, start_col)])\n\n    rows, cols = len(grid), len(grid[0])\n    min_path = None\n\n    for i in range(rows):\n        for j in range(cols):\n            path = find_min_path(grid, k, i, j)\n            if min_path is None or path < min_path:\n                min_path = path\n\n    return min_path\n",
        "def minPath(grid, k):\n    start_value = 1\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == start_value:\n                start_pos = (row, col)\n                break\n    \n    def get_neighbors(grid, row, col):\n        neighbors = []\n        if row > 0:\n            neighbors.append((row - 1, col))\n        if row < len(grid) - 1:\n            neighbors.append((row + 1, col))\n        if col > 0:\n            neighbors.append((row, col - 1))\n        if col < len(grid[0]) - 1:\n            neighbors.append((row, col + 1))\n        return neighbors\n\n    def dfs(grid, k, path, current_pos):\n        if len(path) == k:\n            return path\n\n        for neighbor in get_neighbors(grid, current_pos[0], current_pos[1]):\n            new_row, new_col = neighbor\n            new_pos_value = grid[new_row][new_col]\n            if new_pos_value not in path:\n                found_path = dfs(grid, k, path + [new_pos_value], neighbor)\n                if found_path:\n                    return found_path\n\n    return dfs(grid, k, [start_value], start_pos)\n\n# Test the minPath function\ngrid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nk = 3\n\n",
        "def minPath(grid, k):\n    def neighbors(grid, i, j):\n        rows, cols = len(grid), len(grid[0])\n        valid_neighbors = []\n        offsets = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in offsets:\n            x, y = i + dx, j + dy\n            if 0 <= x < rows and 0 <= y < cols:\n                valid_neighbors.append((x, y))\n        return valid_neighbors\n\n    def is_valid_move(grid, i, j):\n        rows, cols = len(grid), len(grid[0])\n        return 0 <= i < rows and 0 <= j < cols\n\n    def is_valid_path(path, k):\n        return len(path) == k\n\n    def lexicographically_less(path_a, path_b):\n        return path_a < path_b\n            \n    def dfs(grid, i, j, path, result):\n        path.append(grid[i][j])\n\n        if is_valid_path(path, k):\n            result.append(path.copy())\n        else:\n            for ni, nj in neighbors(grid, i, j):\n                dfs(grid, ni, nj, path, result)\n\n        path.pop()\n\n    rows, cols = len(grid), len(grid[0])\n    result = []\n    for i in range(rows):\n        for j in range(cols):\n            dfs(grid, i, j, [], result)\n\n    return min(result)\n\n# Test the function with the examples provided\n\n\n"
    ],
    "HumanEval/130": [
        "def tri(n):\n    \"\"\"Generate the first n+1 numbers of the Tribonacci sequence.\"\"\"\n    if n < 0:\n        return []\n    \n    tribonacci = [1, 3]\n    \n    if n < 2:\n        return tribonacci\n    \n    for i in range(2, n + 1):\n        if i % 2 == 0:  # If i is even\n            tribonacci.append(1 + i // 2)\n        else:  # If i is odd\n            tribonacci.append(tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3])\n    \n    return tribonacci\n",
        "def tri(n):\n    tribonacci_sequence = []\n    \n    if n >= 1:\n        tribonacci_sequence.append(1)\n    if n >= 2:\n        tribonacci_sequence.append(3)\n    \n    if n == 0:\n        return tribonacci_sequence\n    \n    for i in range(3, n+1):\n        if i % 2 == 0:\n            tribonacci_sequence.append(1 + i // 2)\n        else:\n            tribonacci_sequence.append(tribonacci_sequence[i-1] + tribonacci_sequence[i-2] + tribonacci_sequence[i-3])\n    \n    return tribonacci_sequence\n",
        "def tri(n):\n    tribonacci = []  # To store the numbers in the Tribonacci sequence\n    \n    if n == 0:\n        return tribonacci\n    elif n == 1:\n        return [3]\n    elif n == 2:\n        return [3, 2]\n    \n    tribonacci = [0] * (n + 1)  # Initialize the list with zeros\n    tribonacci[0], tribonacci[1], tribonacci[2] = 0, 1, 1  # Set the initial values\n    \n    for i in range(3, n+1):\n        if i % 2 == 0:  # If i is even\n            tribonacci[i] = 1 + i // 2\n        else:  # If i is odd\n            tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3]\n    \n    return tribonacci\n",
        "def tri(n):\n    tribonacci_sequence = [3, 1]  # Initialize the list with the first two values of the Tribonacci sequence\n    \n    # Iterate from index 2 up to n (inclusive) to calculate the Tribonacci sequence\n    for i in range(2, n + 1):\n        # Check if i is even or odd to determine the Tribonacci number\n        if i % 2 == 0:\n            tribonacci_number = 1 + i // 2  # Calculate Tribonacci number for even index i\n        else:\n            tribonacci_number = tribonacci_sequence[i - 1] + tribonacci_sequence[i - 2] + tribonacci_sequence[i - 3]\n        \n        tribonacci_sequence.append(tribonacci_number)  # Append the calculated Tribonacci number to the list\n    \n    return tribonacci_sequence\n",
        "def tri(n):\n    tribonacci_sequence = [3]  # Initialize list with the base case tri(1)\n\n    if n > 0:\n        tribonacci_sequence.append(1)  # Add base case when n = 1\n        \n    for i in range(2, n+1):\n        if i % 2 == 0:\n            tribonacci_sequence.append(1 + i // 2)  # Calculate Tribonacci number based on the rule for even numbers\n        else:\n            tribonacci_sequence.append(tribonacci_sequence[i-1] + tribonacci_sequence[i-2] + tribonacci_sequence[i+1])  # Calculate Tribonacci number based on the rule for odd numbers\n            \n    return tribonacci_sequence\n"
    ],
    "HumanEval/131": [
        "def digits(n):\n    n_str = str(n)\n    product = 1\n    for digit in n_str:\n        if int(digit) % 2 != 0:\n            product *= int(digit)\n    if product == 1:\n        return 0\n    return product\n",
        "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n    product = 1\n    while n > 0:\n        digit = n % 10  # Get the last digit\n        if digit % 2 != 0:\n            product *= digit\n        n //= 10  # Remove the last digit\n    \n    return product\n",
        "def digits(n):\n    product = 1\n    n_str = str(n)\n    \n    for digit in n_str:\n        digit_int = int(digit)\n        \n        if digit_int % 2 != 0:\n            product *= digit_int\n    \n    if product == 1:\n        return 0\n    \n    return product\n",
        "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n    product = 1\n    n_str = str(n)\n    \n    for digit in n_str:\n        digit_int = int(digit)\n        \n        if digit_int % 2 != 0:\n            product *= digit_int\n    \n    return product\n",
        "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n    \n    product = 1  # Initialize the product to 1\n    digits_list = [int(d) for d in str(n)]  # Extract individual digits from the given number\n    odd_digits = [d for d in digits_list if d % 2 != 0]  # Check if each digit is odd\n    \n    for digit in odd_digits:\n        product *= digit  # Multiply each odd digit with the running product\n    \n    return product  # Return the final product\n"
    ],
    "HumanEval/132": [
        "def is_nested(s):\n    stack = []\n    \n    for bracket in s:\n        if bracket == '[':\n            stack.append(bracket)\n        elif bracket == ']':\n            if not stack:\n                return False\n            stack.pop()\n    \n    if stack:\n        return True\n    else:\n        return False\n",
        "def is_nested(string):\n    stack = []\n    \n    if not string:\n        return False\n\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            else:\n                stack.pop()\n\n    return bool(stack)\n",
        "def is_nested(string):\n    stack = []\n    \n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n    \n    return len(stack) > 0\n",
        "def is_nested(string):\n    stack = []\n\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n    \n    return len(stack) > 0\n",
        "return len(stack) < len(string)  # Return True if there are remaining elements in the stack (nested brackets found)\n"
    ],
    "HumanEval/133": [
        "import math\n\ndef sum_squares(lst):\n    total = 0\n    \n    for num in lst:\n        rounded_num = math.ceil(num)\n        total += rounded_num ** 2\n    \n    return total\n",
        "import math\n\ndef sum_squares(lst):\n    rounded_list = [math.ceil(num) for num in lst]\n    squared_list = [num**2 for num in rounded_list]\n    return sum(squared_list)\n",
        "import math\n\ndef sum_squares(lst):\n    total_sum = 0\n    for num in lst:\n        rounded_num = math.ceil(num)\n        squared_num = rounded_num * rounded_num\n        total_sum += squared_num\n    return total_sum\n",
        "import math\n\ndef sum_squares(lst):\n    rounded_lst = [math.ceil(elem) for elem in lst]\n    squared_lst = [elem ** 2 for elem in rounded_lst]\n    total_sum = sum(squared_lst)\n    \n    return total_sum\n\n# Test the function with the provided examples\n\n\n\n\n\n",
        "import math\n\ndef sum_squares(lst):\n    rounded_lst = [math.ceil(x) for x in lst]\n    squared_sum = sum([x ** 2 for x in rounded_lst])\n    return squared_sum\n"
    ],
    "HumanEval/134": [
        "def check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n    '''\n    if not txt:\n        return False\n    \n    last_char = txt[-1]\n    \n    if last_char.isalpha() and (len(txt) == 1 or txt[-2] == ' '):\n        return True\n    else:\n        return False\n",
        "def check_if_last_char_is_a_letter(txt):\n    if txt == \"\":\n        return False\n    \n    words = txt.split()\n    \n    if not words:\n        return False\n    \n    last_word = words[-1]\n    last_char = last_word[-1]\n    \n    return last_char.isalpha() and not last_char.isalnum()\n",
        "def check_if_last_char_is_a_letter(txt):\n    if txt == \"\":\n        return False\n    \n    last_char = txt[-1]\n    if last_char.isalpha() and (len(txt) == 1 or txt[-2] == \" \"):\n        return True\n    else:\n        return False\n",
        "def check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    \n    txt = txt.rstrip()  # Remove trailing whitespace\n    words = txt.split()  # Split the string into words\n    \n    if len(words) == 0:\n        return False\n\n    last_word = words[-1]  # Get the last word\n\n    if not last_word:\n        return False\n\n    last_character = last_word[-1]  # Get the last character of the last word\n\n    return last_character.isalpha()\n",
        "def check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n\n    txt = txt.rstrip()\n\n    words = txt.split()\n    last_word = words[-1]\n\n    if not last_word:\n        return False\n\n    last_char = last_word[-1]\n    return last_char.isalpha()\n"
    ],
    "HumanEval/135": [
        "def can_arrange(arr):\n    if len(arr) < 2:\n        return -1\n",
        "def can_arrange(arr):\n    result_index = -1\n    for i in range(1, len(arr)):\n        if arr[i] <= arr[i - 1]:\n            result_index = i\n\n    return result_index\n",
        "def can_arrange(arr):\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n                \n    return -1\n",
        "def can_arrange(arr):\n    max_index = -1  # Initialize the maximum index found so far\n    for i in range(1, len(arr)):\n        if arr[i] <= arr[i-1]:  # Check if the current element is not greater than or equal to the element before it\n            max_index = max(max_index, i-1)\n    \n    return max_index\n\n# Test cases\n\n\n",
        "def can_arrange(arr):\n    max_index = -1\n    \n    if not arr:\n        return max_index\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            max_index = i\n    \n    return max_index\n"
    ],
    "HumanEval/136": [
        "def largest_smallest_integers(lst):\n    largest_negative = None\n    smallest_positive = None\n    \n    for num in lst:\n        if num < 0 and (largest_negative is None or num > largest_negative):\n            largest_negative = num\n        elif num > 0 and (smallest_positive is None or num < smallest_positive):\n            smallest_positive = num\n    \n    return (largest_negative, smallest_positive)\n",
        "def largest_smallest_integers(lst):\n    largest_negative = None\n    smallest_positive = None\n    \n    for num in lst:\n        if num < 0 and (largest_negative is None or num > largest_negative):\n            largest_negative = num\n        elif num > 0 and (smallest_positive is None or num < smallest_positive):\n            smallest_positive = num\n    \n    return (largest_negative, smallest_positive) if largest_negative is not None or smallest_positive is not None else (None, None)\n",
        "def largest_smallest_integers(lst):\n    largest_negative = None\n    smallest_positive = None\n    \n    for num in lst:\n        if num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n        elif num > 0:\n            if smallest_positive is None or num < smallest_positive:\n                smallest_positive = num\n\n    return (largest_negative, smallest_positive)\n",
        "def largest_smallest_integers(lst):\n    largest_neg = None\n    smallest_pos = None\n\n    for num in lst:\n        if num < 0 and (largest_neg is None or num > largest_neg):\n            largest_neg = num\n        elif num > 0 and (smallest_pos is None or num < smallest_pos):\n            smallest_pos = num\n\n    return (largest_neg, smallest_pos)\n",
        "def largest_smallest_integers(lst):\n    largest_neg = None\n    smallest_pos = None\n    \n    for num in lst:\n        if num < 0 and (largest_neg is None or num > largest_neg):\n            largest_neg = num\n        elif num > 0 and (smallest_pos is None or num < smallest_pos):\n            smallest_pos = num\n    \n    return (largest_neg, smallest_pos)\n"
    ],
    "HumanEval/137": [
        "def compare_one(a, b):\n    if a == b:\n        return None\n\n    if isinstance(a, (int, float)) and isinstance(b, (int, float)):\n        return max(a, b)\n    \n    if isinstance(a, str):\n        a = float(a.replace(',', '.'))\n\n    if isinstance(b, str):\n        b = float(b.replace(',', '.'))\n\n    if isinstance(a, float) and isinstance(b, float):\n        return max(a, b)\n\n    return None\n",
        "def compare_one(a, b):\n    if isinstance(a, str) and ',' in a:\n        a = float(a.replace(\",\", \".\"))\n    if isinstance(b, str) and ',' in b:\n        b = float(b.replace(\",\", \".\")\n\n    if abs(float(a)) > abs(float(b)):\n        return a if isinstance(a, str) else b\n    elif abs(float(b)) > abs(float(a)):\n        return b if isinstance(b, str) else a\n    else:\n        return None\n",
        "def compare_one(a, b):\n    if a == b:\n        return None\n\n    if (isinstance(a, (int, float)) or a.replace(\",\", \".\").replace(\".\", \"\").isdigit()) and \\\n       (isinstance(b, (int, float)) or b.replace(\",\", \".\").replace(\".\", \"\").isdigit()):\n    \n        a_numeric = float(a.replace(\",\", \".\")) if isinstance(a, str) else a\n        b_numeric = float(b.replace(\",\", \".\")) if isinstance(b, str) else b\n\n        return max(a_numeric, b_numeric)\n    \n    return a if a > b else b\n",
        "def compare_one(a, b):\n    if type(a) == type(b):\n        if isinstance(a, (int, float)):\n            return max(a, b)\n        elif isinstance(a, str):\n            try:\n                a = float(a.replace(',', '.'))\n            except ValueError:\n                return None\n            try:\n                b = float(b.replace(',', '.'))\n            except ValueError:\n                return None\n            if a != b:\n                return max(a, b)\n            else:\n                return None\n    else:\n        return None\n",
        "def compare_one(a, b):\n    if isinstance(a, str):\n        a = a.replace(',', '.')\n        a = float(a)\n    else:\n        a = float(a)\n\n    if isinstance(b, str):\n        b = b.replace(',', '.')\n        b = float(b)\n    else:\n        b = float(b)\n\n    if a > b:\n        return a\n    elif b > a:\n        return b\n    else:\n        return None\n"
    ],
    "HumanEval/138": [
        "def is_equal_to_sum_even(n):\n    if n < 8:\n        return False\n    \n    # Generate all combinations of 4 even numbers that sum up to `n`\n    for i in range(2, n // 2 + 1, 2):\n        for j in range(2, n // 2 + 1, 2):\n            for k in range(2, n // 2 + 1, 2):\n                for l in range(2, n // 2 + 1, 2):\n                    if i + j + k + l == n:\n                        return True\n    return False\n",
        "def is_equal_to_sum_even(n):\n    even_numbers = [x for x in range(n, 0, -2) if x % 2 == 0]\n    \n    for i in range(len(even_numbers)):\n        for j in range(i+1, len(even_numbers)):\n            for k in range(j+1, len(even_numbers)):\n                for l in range(k+1, len(even_numbers)):\n                    if even_numbers[i] + even_numbers[j] + even_numbers[k] + even_numbers[l] == n:\n                        return True\n    return False\n",
        "def is_equal_to_sum_even(n):\n    if n < 8:\n        return False\n    \n    count = 0\n    for i in range(2, n, 2):\n        diff = n - i\n        if diff >= 0:\n            count += 1\n    \n    return count == 4\n",
        "def is_equal_to_sum_even(n):\n    if n < 8:\n        return False\n\n    for i in range(2, n // 2 + 1):\n        for j in range(2, n // 2 + 1):\n            for k in range(2, n // 2 + 1):\n                for l in range(2, n // 2 + 1):\n                    if i + j + k + l == n:\n                        return True\n    return False\n",
        "def is_equal_to_sum_even(n):\n    if n < 8:\n        return False\n\n    if n % 4 == 0:\n        return True\n    \n    for i in range(2, n-6, 2):\n        for j in range(i, n-4, 2):\n            for k in range(j, n-2, 2):\n                if i + j + k + n == n:\n                    return True\n                \n    return False\n"
    ],
    "HumanEval/139": [
        "def special_factorial(n):\n    result = 1\n    for i in range(n, 0, -1):\n        factorial_i = 1\n        for j in range(i, 0, -1):\n            factorial_i *= j\n        result *= factorial_i\n    return result\n",
        "def special_factorial(n):\n    if n <= 0:\n        raise ValueError(\"n must be greater than 0\")\n\n    result = 1\n\n    for i in range(n, 0, -1):\n        factorial_i = 1\n        for j in range(1, i + 1):\n            factorial_i *= j\n        \n        result *= factorial_i\n\n    return result\n",
        "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    result = 1\n\n    def factorial(num):\n        if num <= 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n\n    return result\n",
        "def special_factorial(n):\n    result = 1\n    for i in range(n, 0, -1):\n        factorial = 1\n        for j in range(1, i+1):\n            factorial *= j\n        result *= factorial\n    return result\n",
        "def special_factorial(n):\n    def factorial(num):\n        if num == 0:\n            return 1\n        else:\n            return num * factorial(num - 1)\n    \n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result\n"
    ],
    "HumanEval/140": [
        "def fix_spaces(text):\n    fixed_text = \"\"\n    consecutive_spaces = 0\n    \n    for char in text:\n        if char == \" \":\n            consecutive_spaces += 1\n            if consecutive_spaces > 2:\n                fixed_text = fixed_text.rstrip(\"_\")  # Remove multiple consecutive underscores\n                fixed_text += \"-\"\n            else:\n                fixed_text += \"_\"\n        else:\n            fixed_text += char\n            consecutive_spaces = 0\n    \n    return fixed_text\n",
        "def fix_spaces(text):\n    text = text.replace(\" \", \"_\")\n    text = text.replace(\"__\", \"-\")\n    return text\n",
        "def fix_spaces(text):\n    modified_text = text.replace(\" \", \"_\")\n    \n    # Replace more than two consecutive underscores with a single underscore\n    modified_text = modified_text.replace(\"__\", \"_\")\n    \n    # Replace all remaining consecutive underscores with a single hyphen\n    while \"--\" in modified_text:\n        modified_text = modified_text.replace(\"--\", \"-\")\n    \n    return modified_text\n",
        "def fix_spaces(text):\n    result = \"\"\n    current_consecutive_spaces = 0  # count of consecutive spaces\n    \n    for i, char in enumerate(text):\n        if char == \" \":\n            current_consecutive_spaces += 1\n\n            if i + 1 < len(text) and text[i + 1] == \" \":\n                current_consecutive_spaces += 1\n                \n                if current_consecutive_spaces > 2:\n                    result += \"-\"\n                else:\n                    result += \"_\"\n            else:\n                result += \"_\"\n        else:\n            current_consecutive_spaces = 0\n            result += char\n\n    return result\n",
        "import re\n\ndef fix_spaces(text):\n    # Step 0: Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Step 1: Replace all instances of more than 2 consecutive spaces with a single underscore using regular expressions\n    result = re.sub(r'( {2,})', '_', text)\n    \n    return result\n"
    ],
    "HumanEval/141": [
        "def file_name_check(file_name):\n    # Check if the file name contains more than three digits\n    if sum(c.isdigit() for c in file_name) > 3:\n        return 'No'\n    \n    # Check if the file name contains exactly one dot\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Check if the substring before the dot is not empty and starts with a letter from the Latin alphabet\n    file_parts = file_name.split('.')\n    if len(file_parts) != 2 or not file_parts[0] or not file_parts[0][0].isalpha():\n        return 'No'\n\n    # Check if the substring after the dot is 'txt', 'exe', or 'dll'\n    valid_extensions = ['txt', 'exe', 'dll']\n    if file_parts[1] not in valid_extensions:\n        return 'No'\n    \n    return 'Yes'\n",
        "def file_name_check(file_name):\n    digit_count = sum(1 for char in file_name if char.isdigit())\n    \n    if digit_count > 3:\n        return 'No'\n    \n    dot_count = file_name.count('.')\n    \n    if dot_count != 1:\n        return 'No'\n    \n    parts = file_name.split('.')\n    \n    if len(parts[0]) == 0 or not parts[0][0].isalpha():\n        return 'No'\n    \n    valid_extensions = ['txt', 'exe', 'dll']\n    if parts[1] not in valid_extensions:\n        return 'No'\n    \n    return 'Yes'\n",
        "def file_name_check(file_name):\n    if sum(c.isdigit() for c in file_name) > 3:\n        return 'No'\n\n    if file_name.count('.') != 1:\n        return 'No'\n\n    file_parts = file_name.split('.')\n    if not file_parts[0][0].isalpha():\n        return 'No'\n\n    valid_extensions = ['txt', 'exe', 'dll']\n    if file_parts[-1] not in valid_extensions:\n        return 'No'\n\n    return 'Yes'\n",
        "def file_name_check(file_name):\n    if sum(char.isdigit() for char in file_name) > 3:\n        return 'No'\n\n    if file_name.count('.') != 1:\n        return 'No'\n\n    file_parts = file_name.split('.')\n    if len(file_parts) != 2:\n        return 'No'\n\n    if not file_parts[0] or not file_parts[0][0].isalpha():\n        return 'No'\n\n    if file_parts[1] not in ['txt', 'exe', 'dll']:\n        return 'No'\n\n    return 'Yes'\n",
        "def file_name_check(file_name):\n    valid_extensions = ['txt', 'exe', 'dll']\n    \n    if file_name.count('.') != 1:\n        return 'No'\n    \n    name_parts = file_name.split('.')\n    if len(name_parts) != 2:\n        return 'No'\n    \n    before_dot, after_dot = name_parts\n    \n    if not before_dot or not before_dot[0].isalpha():\n        return 'No'\n    \n    if after_dot not in valid_extensions:\n        return 'No'\n    \n    return 'Yes'\n"
    ],
    "HumanEval/142": [
        "def sum_squares(lst):\n    result = 0\n    \n    for i, num in enumerate(lst):\n        if i % 3 == 0:\n            result += num ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            result += num ** 3\n    return result\n",
        "def sum_squares(lst):\n    total_sum = 0\n    \n    for index, num in enumerate(lst):\n        if index % 3 == 0 or (index % 4 == 0 and index % 3 != 0):\n            if index % 3 == 0:\n                num = num ** 2\n            total_sum += num\n            \n    return total_sum\n",
        "def sum_squares(lst):\n    total = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = lst[i] ** 3\n        total += lst[i]\n    return total\n",
        "def sum_squares(lst):\n    total_sum = 0\n    \n    for index in range(len(lst)):\n        num = lst[index]\n        \n        if index % 3 == 0:\n            total_sum += num**2\n        \n        elif index % 4 == 0 and index % 3 != 0:\n            total_sum += num**3\n    \n    return total_sum\n",
        "def sum_squares(lst):\n    sum_result = 0\n    for index, num in enumerate(lst):\n        if index % 3 == 0:\n            sum_result += num ** 2\n        elif index % 4 == 0:\n            sum_result += num ** 3\n    return sum_result\n"
    ],
    "HumanEval/143": [
        "def words_in_sentence(sentence):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word)]\n\n    result = \" \".join(prime_words)\n    return result\n",
        "def words_in_sentence(sentence):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_prime_length(word):\n        return is_prime(len(word))\n\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime_length(word)]\n    return \" \".join(prime_words)\n",
        "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    \n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n        \n    return True\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)\n\nsentence = \"This is a test\"\n\n",
        "def words_in_sentence(sentence):\n\n    def is_prime(number):\n        if number < 2:\n            return False\n        for i in range(2, int(number ** 0.5) + 1):\n            if number % i == 0:\n                return False\n        return True\n\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return \" \".join(prime_words)\n",
        "def words_in_sentence(sentence):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    \n    return ' '.join(prime_words)\n"
    ],
    "HumanEval/144": [
        "def simplify(x, n):\n    x_num, x_denom = map(int, x.split('/'))\n    n_num, n_denom = map(int, n.split('/'))\n    product_num = x_num * n_num\n    product_denom = x_denom * n_denom\n    whole_number = product_num % product_denom == 0\n    return whole_number\n",
        "from math import gcd\n\ndef parse_fraction(fraction):\n    numerator, denominator = map(int, fraction.split('/'))\n    return numerator, denominator\n\ndef multiply_fractions(x, n):\n    x_numer, x_denom = parse_fraction(x)\n    n_numer, n_denom = parse_fraction(n)\n\n    result_numer = x_numer * n_numer\n    result_denom = x_denom * n_denom\n\n    return result_numer, result_denom\n\ndef simplify_result(result):\n    numer, denom = result\n    div = gcd(numer, denom)\n    return numer // div, denom // div\n\ndef simplify(x, n):\n    result = multiply_fractions(x, n)\n    simplified_result = simplify_result(result)\n\n    return simplified_result[1] == 1 or simplified_result[1] == -1\n\n",
        "def simplify(x, n):\n    x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n\n    result_num = x_num * n_num\n    result_den = x_den * n_den\n\n    return result_num % result_den == 0\n",
        "def simplify(x, n):\n    # Step 0: Extract numerators and denominators\n    x_numer, x_denom = map(int, x.split('/'))\n    n_numer, n_denom = map(int, n.split('/'))\n    \n    # Step 1: Multiply numerators\n    prod_numer = x_numer * n_numer\n    \n    # Step 2: Multiply denominators\n    prod_denom = x_denom * n_denom\n    \n    # Step 3: Check if product is a whole number\n    return prod_numer % prod_denom == 0\n",
        "def simplify(x, n):\n    x_num, x_denom = map(int, x.split('/'))\n    n_num, n_denom = map(int, n.split('/'))\n    \n    result_num = x_num * n_num\n    result_denom = x_denom * n_denom\n    \n    return result_num % result_denom == 0\n"
    ],
    "HumanEval/145": [
        "def digit_sum(n):\n    return sum(int(digit) for digit in str(abs(n)))\n\ndef order_by_points(nums):\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))\n",
        "def order_by_points(nums):\n    def sum_of_digits(num):\n        return sum(int(digit) for digit in str(abs(num)))\n\n    sums_of_digits = [sum_of_digits(num) for num in nums]\n    sorted_nums = sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))\n\n    return sorted_nums\n",
        "def sum_of_digits(num):\n    return sum(int(digit) for digit in str(abs(num)))\n\ndef order_by_points(nums):\n    key_func = lambda num, idx: (sum_of_digits(num), idx)\n    return sorted(nums, key=lambda x: key_func(x, nums.index(x)))\n",
        "def order_by_points(nums):\n    def digit_sum(num):\n        return sum(int(digit) for digit in str(abs(num)))\n\n    return sorted(nums, key=lambda num: (digit_sum(num), nums.index(num)))\n",
        "def order_by_points(nums):\n    def digit_sum(num):\n        return sum(int(digit) for digit in str(abs(num)))\n\n    sums = [(digit_sum(num), index, num) for index, num in enumerate(nums)]\n    sorted_nums = sorted(sums, key=lambda x: (x[0], x[1]))\n    return [num for _, _, num in sorted_nums]\n"
    ],
    "HumanEval/146": [
        "def specialFilter(nums):\n    count = 0\n    for num in nums:\n        if num > 10:\n            str_num = str(abs(num))\n            if int(str_num[0]) % 2 != 0 and int(str_num[-1]) % 2 != 0:\n                count += 1\n    return count\n",
        "def specialFilter(nums):\n    count = 0\n    for num in nums:\n        if num > 10:\n            str_num = str(num)\n            if int(str_num[0]) % 2 != 0 and int(str_num[-1]) % 2 != 0:\n                count += 1\n    return count\n\n# Testing the function\n\n\n",
        "def specialFilter(nums):\n    count = 0\n\n    for num in nums:\n        if num > 10:\n            str_num = str(abs(num))\n            if int(str_num[0]) % 2 == 1 and int(str_num[-1]) % 2 == 1:\n                count += 1\n\n    return count\n",
        "def specialFilter(nums):\n    count = 0  # Initialize a counter variable to keep track of the number of elements that meet the specified conditions\n    \n    for num in nums:\n        # Check if the number is greater than 10 and if both the first and last digits are odd\n        str_num = str(abs(num))  # Convert the number to a string and take the absolute value to handle negative numbers\n        first_digit = int(str_num[0])  # Get the first digit of the number\n        last_digit = abs(num) % 10  # Get the last digit of the number\n\n        # If the number meets the conditions, increment the counter\n        if num > 10 and first_digit % 2 != 0 and last_digit % 2 != 0:\n            count += 1\n\n    return count\n",
        "def specialFilter(nums):\n    count = 0\n    if not nums:\n        return 0\n\n    count = 0\n\n    for num in nums:\n        if num > 10:\n            first_digit = int(str(num)[0])\n            last_digit = int(str(num)[-1])\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n\n    return count\n"
    ],
    "HumanEval/147": [
        "def get_max_triples(n):\n    result = []\n    count = 0\n\n    for i in range(1, n + 1):\n        a_i = i * i - i + 1\n        result.append(a_i)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (result[i] + result[j] + result[k]) % 3 == 0:\n                    count += 1\n\n    return count\n",
        "def get_max_triples(n):\n    a = []\n    count = 0\n\n    for i in range(1, n+1):\n        a.append(i * i - i + 1)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n\n    return count\n",
        "def get_max_triples(n):\n    a = []\n    for i in range(1, n+1):\n        a.append(i * i - i + 1)\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    \n    return count\n",
        "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n+1)]\n    \n    count_triples = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count_triples += 1\n    \n    return count_triples\n",
        "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count\n"
    ],
    "HumanEval/148": [
        "planet_order = {\n    \"Mercury\": 1,\n    \"Venus\": 2,\n    \"Earth\": 3,\n    \"Mars\": 4,\n    \"Jupiter\": 5,\n    \"Saturn\": 6,\n    \"Uranus\": 7,\n    \"Neptune\": 8\n}\n\ndef bf(planet1, planet2):\n    if planet1 not in planet_order or planet2 not in planet_order:\n        return ()\n\n    order_planet1 = planet_order[planet1]\n    order_planet2 = planet_order[planet2]\n\n    planets_between = [planet for planet, order in planet_order.items()\n                       if order_planet1 <= order <= order_planet2]\n\n    if not planets_between:\n        return ()\n\n    sorted_planets = sorted(planets_between, key=lambda x: planet_order[x])\n\n    return tuple(sorted_planets)\n",
        "# Step 0: Store the correct planet names in a list in the correct order\nplanets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\ndef bf(planet1, planet2):\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    \n    index_1 = planets.index(planet1)\n    index_2 = planets.index(planet2)\n    \n    if index_1 == -1 or index_2 == -1:\n        return ()\n    \n    if index_1 > index_2:\n        index_1, index_2 = index_2, index_1\n    \n    result = planets[index_1+1:index_2]\n    result.sort(key=lambda x: planets.index(x))\n    \n    return tuple(result)\n",
        "def bf(planet1, planet2):\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    index1 = planets.index(planet1) if planet1 in planets else -1\n    index2 = planets.index(planet2) if planet2 in planets else -1\n    \n    if index1 == -1 or index2 == -1:\n        return ()\n    \n    if index1 > index2:\n        planet1, planet2 = planet2, planet1\n        \n    between_planets = planets[index1+1:index2]\n    \n    return tuple(between_planets)\n",
        "    return tuple(sorted_planets)\n",
        "def bf(planet1, planet2):\n    PLANETS = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    if planet1 in PLANETS and planet2 in PLANETS:\n        index1 = PLANETS.index(planet1)\n        index2 = PLANETS.index(planet2)\n        \n        if index1 > index2:\n            index1, index2 = index2, index1  # Swap the indexes if they are not in the correct order\n            \n        planets_between = PLANETS[index1+1:index2]\n        \n        sorted_planets = sorted(planets_between, key=lambda x: PLANETS.index(x))\n        \n        return tuple(sorted_planets)\n        \n    else:\n        return ()\n"
    ],
    "HumanEval/149": [
        "def sorted_list_sum(lst):\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    return sorted_list\n",
        "def sorted_list_sum(lst):\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    return sorted_list\n",
        "def sorted_list_sum(lst):\n    if not lst:\n        return []\n\n    filtered_list = [word for word in lst if len(word) % 2 != 0]\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n\n    return sorted_list\n",
        "def list_sort(lst):\n    even_length_strings = [string for string in lst if len(string) % 2 == 0]\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    return sorted_strings\n",
        "def sorted_list_sum(lst):\n    even_length_words = []\n    \n    for word in lst:\n        if len(word) % 2 == 0:\n            even_length_words.append(word)\n    \n    sorted_words = sorted(even_length_words, key=lambda x: (len(x), x))\n    \n    return sorted_words\n"
    ],
    "HumanEval/150": [
        "def x_or_y(n, x, y):\n    if is_prime(n):\n        return x\n    else:\n        return y\n",
        "def x_or_y(n, x, y):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    if is_prime(n):\n        return x\n    else:\n        return y\n",
        "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = math.isqrt(n) + 1\n    for i in range(3, max_divisor, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef x_or_y(n, x, y):\n    if is_prime(n):\n        return x\n    else:\n        return y\n",
        "def x_or_y(n, x, y):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    if is_prime(n):\n        return x\n    else:\n        return y\n",
        "def x_or_y(n, x, y):\n    import math\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    if is_prime(n):\n        return x\n    else:\n        return y\n"
    ],
    "HumanEval/151": [
        "def double_the_difference(lst):\n    total = 0\n    for num in lst:\n        if isinstance(num, int) and num >= 0 and num % 2 != 0:\n            total += num ** 2\n    return total * 2\n",
        "def double_the_difference(lst):\n    # Step 0: Filter out negative numbers and non-integers\n    filtered_list = [num for num in lst if num >= 0 and isinstance(num, int)]\n    \n    # Step 1: Filter the list to only contain odd numbers\n    odd_numbers = [num for num in filtered_list if num % 2 == 1]\n    \n    # Step 2: Calculate the sum of squares of the odd numbers\n    sum_of_squares = sum(num**2 for num in odd_numbers)\n    \n    # Step 3: Double the sum of squares\n    result = 2 * sum_of_squares\n    \n    return result\n",
        "def double_the_difference(lst):\n    sum_squares = 0\n    \n    for num in lst:\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            square_num = num ** 2\n            sum_squares += square_num\n    \n    return sum_squares if sum_squares > 0 else 0\n",
        "def double_the_difference(lst):\n    result = 0\n\n    for num in lst:\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            result += num ** 2\n\n    return result * 2\n",
        "def double_the_difference(lst):\n    # Step 1: Filter out negative numbers from the list\n    filtered_numbers = [num for num in lst if num >= 0]\n\n    # Step 2: Filter out even numbers\n    odd_numbers = [num for num in filtered_numbers if num % 2 != 0]\n\n    # Step 3: Square each odd number and calculate the sum\n    sum_of_squares = sum([num ** 2 for num in odd_numbers])\n\n    return sum_of_squares\n"
    ],
    "HumanEval/152": [
        "def compare(game, guess):\n    result = []\n    for g, c in zip(game, guess):\n        if g == c:\n            result.append(0)\n        else:\n            result.append(abs(g - c))\n    return result\n",
        "def compare(game, guess):\n    result_diff = []\n    \n    for i in range(len(game)):\n        diff = abs(game[i] - guess[i])\n        result_diff.append(diff)\n    \n    return result_diff\n",
        "def compare(game, guess):\n    differences = []  # Step 0: Create an empty list to store the differences\n    \n    # Step 1: Iterate over the elements of the game and guess arrays simultaneously using zip\n    for score, prediction in zip(game, guess):\n        # Step 2: Calculate the absolute difference between the score and prediction\n        diff = abs(score - prediction)\n        differences.append(diff)\n    \n    # Step 3: Return the list of differences\n    return differences\n",
        "def compare(game, guess):\n    return [abs(game[i] - guess[i]) for i in range(len(game))]\n",
        "def compare(game, guess):\n    result = []\n    \n    for score, g in zip(game, guess):\n        diff = abs(score - g)\n        result.append(diff)\n    \n    return result\n"
    ],
    "HumanEval/153": [
        "def Strongest_Extension(class_name, extensions):\n    max_strength = float('-inf')\n    strongest_extension = ''\n    \n    for extension in extensions:\n        cap_count = sum(1 for c in extension if c.isupper())\n        sm_count = sum(1 for c in extension if c.islower())\n        \n        strength = cap_count - sm_count\n        \n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n        elif strength == max_strength:\n            if extensions.index(extension) < extensions.index(strongest_extension):\n                strongest_extension = extension\n            \n    result = f\"{class_name}.{strongest_extension}\"\n    return result\n",
        "def Strongest_Extension(class_name, extensions):\n    strongest_extension_name = None\n    strongest_extension_strength = float('-inf')\n    strongest_extension_index = None\n    \n    for index, extension in enumerate(extensions):\n        # Calculate strength of the extension\n        cap_count = sum(1 for char in extension if char.isupper())\n        sm_count = sum(1 for char in extension if char.islower())\n        strength = cap_count - sm_count\n\n        # Update strongest extension if current extension is stronger\n        if strength > strongest_extension_strength or (strength == strongest_extension_strength and index < strongest_extension_index):\n            strongest_extension_name = extension\n            strongest_extension_strength = strength\n            strongest_extension_index = index\n\n    return f\"{class_name}.{strongest_extension_name}\"\n",
        "def Strongest_Extension(class_name, extensions):\n    strongest_extension = \"\"\n    max_strength = float('-inf')\n    \n    for extension in extensions:\n        CAP = sum(1 for letter in extension if letter.isupper())\n        SM = sum(1 for letter in extension if letter.islower())\n        strength = CAP - SM\n        \n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n\n    return f\"{class_name}.{strongest_extension}\"\n",
        "def Strongest_Extension(class_name, extensions):\n    strongest_extension_name = None\n    strongest_extension_strength = float('-inf')\n    \n    for extension in extensions:\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        extension_strength = CAP - SM\n        \n        if extension_strength > strongest_extension_strength:\n            strongest_extension_name = extension\n            strongest_extension_strength = extension_strength\n        elif extension_strength == strongest_extension_strength:\n            if extensions.index(extension) < extensions.index(strongest_extension_name):\n                strongest_extension_name = extension\n    \n    result = f\"{class_name}.{strongest_extension_name}\"\n    return result\n",
        "def Strongest_Extension(class_name, extensions):\n    strengths = {}\n    for extension in extensions:\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        strength = CAP - SM\n        strengths[extension] = strength\n    \n    max_strength_extension = max(strengths, key=strengths.get)\n    \n    return f\"{class_name}.{max_strength_extension}\"\n"
    ],
    "HumanEval/154": [
        "def cycpattern_check(a, b):\n    if not b:  # If the second word is empty, return False\n        return False\n    \n    for i in range(len(b)):  # Loop through each character in the second word\n        rotated_word = b[i:] + b[:i]  # Rotate the word\n        if rotated_word in a:  # Check if any rotation of the second word is a substring of the first word\n            return True\n    \n    return False  # Return False if no rotations are found\n",
        "def cycpattern_check(a, b):\n    if len(a) != len(b):\n        return False\n    else:\n        concat_word = a + a\n        \n        for i in range(len(a)):\n            if concat_word[i:i+len(b)] == b:\n                return True\n                \n        return False\n",
        "def cycpattern_check(a, b):\n    if len(a) < len(b):\n        return False\n    \n    concat_a = a + a\n    \n    for i in range(len(a)):\n        sub_str = concat_a[i:i + len(b)]\n        if sub_str == b:\n            return True\n        b = b[1:] + b[0]\n    \n    return False\n",
        "def rotate_word(word):\n    for i in range(len(word)):\n        yield word[i:] + word[:i]\n\ndef cycpattern_check(a, b):\n    rotated_b = rotate_word(b)\n    for rot in rotated_b:\n        if rot in a:\n            return True\n    return False\n",
        "def cycpattern_check(a, b):\n    def rotations(word):\n        word_rotations = []\n        for i in range(len(word)):\n            rotated_word = word[i:] + word[:i]\n            word_rotations.append(rotated_word)\n        return word_rotations\n\n    word_rotations = rotations(b)\n    \n    for rotation in word_rotations:\n        if rotation in a:\n            return True\n    \n    return False\n"
    ],
    "HumanEval/155": [
        "def even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n    \n    for digit in str(abs(num)):\n        if digit.isdigit() and digit != '-':\n            digit = int(digit)\n            if digit % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    \n    return (even_count, odd_count)\n",
        "def even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n\n    num_str = str(abs(num))\n    \n    for digit in num_str:\n        digit = int(digit)\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return (even_count, odd_count)\n",
        "return even_count, odd_count  # Return the counts of even and odd digits\n",
        "def even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n    \n    num_str = str(num)\n    \n    for digit_char in num_str:\n        digit = int(digit_char)\n        \n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return even_count, odd_count\n",
        "def even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n\n    num_str = str(num)\n\n    for digit in num_str:\n        if digit.isdigit():\n            digit_int = int(digit)\n\n            if digit_int % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)\n"
    ],
    "HumanEval/156": [
        "def int_to_mini_roman(number):\n    roman_dict = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd', 100: 'c', 90: 'xc',\n                  50: 'l', 40: 'xl', 10: 'x', 9: 'ix', 5: 'v', 4: 'iv', 1: 'i'}\n    \n    roman_numeral = \"\"\n    \n    for key in sorted(roman_dict, reverse=True):\n        while number >= key:\n            roman_numeral += roman_dict[key]\n            number -= key\n    \n    return roman_numeral.lower()\n",
        "def int_to_mini_roman(number):\n    roman_numerals = {\n        'M': 1000, 'CM': 900, 'D': 500, 'CD': 400,\n        'C': 100, 'XC': 90, 'L': 50, 'XL': 40,\n        'X': 10, 'IX': 9, 'V': 5, 'IV': 4, 'I': 1\n    }\n\n    result = \"\"\n\n    roman_values = sorted(roman_numerals.items(), key=lambda x: x[1], reverse=True)\n\n    for roman_char, value in roman_values:\n        while number >= value:\n            result += roman_char\n            number -= value\n\n    return result.lower()\n",
        "def int_to_mini_roman(number):\n    roman_numerals = {\n        1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x',\n        40: 'xl', 50: 'l', 90: 'xc', 100: 'c',\n        400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'\n    }\n    \n    conversion_rules = [\n        (1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n        (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'),\n        (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')\n    ]\n    \n    result = ''\n    for value, numeral in conversion_rules:\n        while number >= value:\n            result += roman_numerals[value]\n            number -= value\n            \n    return result.lower()\n",
        "roman_numerals = {\n    1000: 'm',\n    900: 'cm',\n    500: 'd',\n    400: 'cd',\n    100: 'c',\n    90: 'xc',\n    50: 'l',\n    40: 'xl',\n    10: 'x',\n    9: 'ix',\n    5: 'v',\n    4: 'iv',\n    1: 'i'\n}\n\ndef int_to_mini_roman(number):\n    roman_result = ''\n    \n    for value, roman_val in sorted(roman_numerals.items(), reverse=True):\n        while number >= value:\n            roman_result += roman_val\n            number -= value\n\n    return roman_result\n",
        "def int_to_mini_roman(number):\n    roman_numerals = {\n        1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x', 40: 'xl', 50: 'l',\n        90: 'xc', 100: 'c', 400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'\n    }\n    \n    def convert_to_roman(num):\n        result = ''\n        for value in sorted(roman_numerals, reverse=True):\n            while num >= value:\n                result += roman_numerals[value]\n                num -= value\n        return result.lower()\n    \n    return convert_to_roman(number)\n"
    ],
    "HumanEval/157": [
        "def is_triangle(a, b, c):\n    return a + b > c and a + c > b and b + c > a\n\ndef right_angle_triangle(a, b, c):\n    if not is_triangle(a, b, c):\n        return False\n    \n    longest_side = max(a, b, c)\n    \n    if longest_side**2 == a**2 + b**2 + c**2 - longest_side**2:\n        return True\n    else:\n        return False\n",
        "def right_angle_triangle(a, b, c):\n    if not is_valid_triangle(a, b, c):\n        return False\n\n    longest_side = max(a, b, c)\n    sum_of_squares = a**2 + b**2 if longest_side == c else (a**2 + c**2 if longest_side == b else b**2 + c**2)\n\n    return longest_side**2 == sum_of_squares\n",
        "def right_angle_triangle(a, b, c):\n    if a + b > c and b + c > a and a + c > b:\n        hypotenuse = max(a, b, c)\n        if hypotenuse == a:\n            return a**2 == b**2 + c**2\n        elif hypotenuse == b:\n            return b**2 == a**2 + c**2\n        else:\n            return c**2 == a**2 + b**2\n    return False\n",
        "import math\n\ndef right_angle_triangle(a, b, c):\n    # Step 0: Check if the given sides can form a triangle\n    if a > 0 and b > 0 and c > 0 and a + b > c and b + c > a and a + c > b:\n        # Calculate the squares of the sides\n        a_squared = a * a\n        b_squared = b * b\n        c_squared = c * c\n        \n        # Check if any of the angles determined by the sides is a right angle (90 degrees)\n        if a_squared + b_squared == c_squared or b_squared + c_squared == a_squared or a_squared + c_squared == b_squared:\n            return True\n        else:\n            return False\n    else:\n        return False\n",
        "def right_angle_triangle(a, b, c):\n    if all(isinstance(side, int) and side > 0 for side in [a, b, c]):\n        if a + b > c and b + c > a and a + c > b:\n            sides = [a, b, c]\n            sides.sort()\n            longest_side = sides[2]\n            other_sides = [sides[0], sides[1]]\n            if longest_side ** 2 == other_sides[0] ** 2 + other_sides[1] ** 2:\n                return True\n            else:\n                return False\n        else:\n            return False\n    else:\n        return False\n"
    ],
    "HumanEval/158": [
        "def find_max(words):\n    unique_char_count = {}\n    \n    # Step 1: Iterate through each word and count the number of unique characters in each word\n    for word in words:\n        unique_chars = set(word)\n        unique_char_count[word] = (len(unique_chars), word)\n    \n    # Step 2: Find the word with the maximum number of unique characters\n    max_unique_chars = max(unique_char_count.values(), key=lambda x: (x[0], x[1]))\n    \n    return max_unique_chars[1]\n",
        "def find_max(words):\n    max_unique_word = \"\"\n    max_unique_count = -1\n    \n    for word in words:\n        unique_count = len(set(word))\n        if unique_count > max_unique_count:\n            max_unique_count = unique_count\n            max_unique_word = word\n        elif unique_count == max_unique_count and word < max_unique_word:\n            max_unique_word = word\n            \n    return max_unique_word\n",
        "def find_max(words):\n    unique_char_count = {}\n\n    for word in words:\n        unique_chars = set(word)\n        unique_char_count[word] = len(unique_chars)\n    \n    max_word = \"\"\n    max_count = 0\n\n    for word, count in unique_char_count.items():\n        if count > max_count or (count == max_count and word < max_word):\n            max_word = word\n            max_count = count\n\n    return max_word\n",
        "def find_max(words):\n    char_count = {}\n    max_unique_count = 0\n    max_word = \"\"\n\n    for word in words:\n        unique_chars = set()\n        for char in word:\n            unique_chars.add(char)\n        \n        count_unique = len(unique_chars)\n        \n        if count_unique > char_count.get(word, 0):\n            char_count[word] = count_unique\n            if count_unique > max_unique_count or (count_unique == max_unique_count and word < max_word):\n                max_unique_count = count_unique\n                max_word = word\n    \n    return max_word\n",
        "def find_max(words):\n    unique_char_counts = {}\n    max_unique_count = 0\n    max_unique_words = []\n\n    for word in words:\n        unique_count = len(set(word))\n        unique_char_counts[word] = unique_count\n\n        if unique_count > max_unique_count:\n            max_unique_count = unique_count\n            max_unique_words = [word]\n        elif unique_count == max_unique_count:\n            max_unique_words.append(word)\n\n    if max_unique_words:\n        max_unique_words.sort()\n        return max_unique_words[0]\n    else:\n        return \"\"\n"
    ],
    "HumanEval/159": [
        "def eat(number, need, remaining):\n    if need <= remaining:\n        total_carrots_eaten = number + need\n        carrots_left = remaining - need\n    else:\n        total_carrots_eaten = number + remaining\n        carrots_left = 0\n    \n    return [total_carrots_eaten, carrots_left]\n",
        "def eat(number, need, remaining):\n    total_carrots_eaten = number + need\n    carrots_left = remaining - total_carrots_eaten\n    if carrots_left < 0:\n        carrots_left = 0\n    return [total_carrots_eaten, carrots_left]\n",
        "def eat(number, need, remaining):\n    total_eaten = number + need\n    carrots_left = remaining - total_eaten\n    if carrots_left < 0:\n        carrots_left = 0\n    return [total_eaten, carrots_left]\n",
        "def eat(number, need, remaining):\n    total_eaten = number + need\n    total_left = max(remaining - total_eaten, 0)\n\n    return total_eaten, total_left\n",
        "def eat(number, need, remaining):\n    total_eaten = number + need\n    total_remaining = remaining\n    \n    if remaining < need:\n        total_eaten += remaining\n        total_remaining = 0\n    \n    return [total_eaten, total_remaining]\n"
    ],
    "HumanEval/160": [
        "# Define the function do_algebra(operator, operand)\ndef do_algebra(operator, operand):\n    # Check the length constraints for operator and operand lists\n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"Length of operator list should be one less than the length of operand list\")\n\n    if len(operator) < 1 or len(operand) < 2:\n        raise ValueError(\"Operator list should have at least one operator and operand list should have at least two operands.\")\n\n    # Step 1: Initialize the result with the first operand\n    result = operand[0]\n\n    # Step 2: Loop through the operators and operands together\n    for op, num in zip(operator, operand[1:]):\n        # Step 3: Update the result based on the operator\n        if op == '+':\n            result += num\n        elif op == '-':\n            result -= num\n        elif op == '*':\n            result *= num\n        elif op == '//':\n            result //= num\n        elif op == '**':\n            result **= num\n\n    return result\n\n# Test the function with an example\noperator = ['+', '*', '-']\noperand = [2, 3, 4, 5]\nresult = do_algebra(operator, operand)\n\n",
        "def do_algebra(operator, operand):\n    expression = operand[0]\n    \n    for i in range(1, len(operand)):\n        if operator[i-1] == '+':\n            expression += operand[i]\n        elif operator[i-1] == '-':\n            expression -= operand[i]\n        elif operator[i-1] == '*':\n            expression *= operand[i]\n        elif operator[i-1] == '//':\n            expression //= operand[i]\n        elif operator[i-1] == '**':\n            expression **= operand[i]\n    \n    return expression\n",
        "def do_algebra(operator, operand):\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i+1]\n        elif operator[i] == '-':\n            result -= operand[i+1]\n        elif operator[i] == '*':\n            result *= operand[i+1]\n        elif operator[i] == '//':\n            result //= operand[i+1]\n        elif operator[i] == '**':\n            result **= operand[i+1]\n    return result\n",
        "def do_algebra(operator, operand):\n    if len(operator) != len(operand) - 1:\n        return \"Error: Length of operator list should be one less than the length of the operand list.\"\n\n    expression = str(operand[0]) \n\n    for i in range(len(operator)):\n        expression += operator[i]  # Add the operator\n        expression += str(operand[i+1])  # Add the current operand\n\n    result = eval(expression)\n\n    return result\n",
        "def do_algebra(operator, operand):\n    if len(operand) < 2 or len(operator) != len(operand) - 1:\n        return \"Invalid input lists. Operand list must have at least 2 elements, and Operator list length should be 1 less than operand list.\"\n\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n\n    result = eval(expression)\n    return result\n"
    ],
    "HumanEval/161": [
        "def solve(s):\n    result = \"\"\n    contains_letter = any(char.isalpha() for char in s)\n    \n    if contains_letter:\n        for char in s:\n            if char.isalpha():\n                result += char.swapcase()\n            else:\n                result += char\n    else:\n        result = s[::-1]\n    \n    return result\n",
        "def solve(s):\n    result = \"\"\n\n    for char in s:\n        if char.isalpha():\n            result += char.swapcase()\n        else:\n            result += char\n\n    if not any(char.isalpha() for char in result):\n        result = result[::-1]\n\n    return result\n",
        "def solve(s):\n    result = \"\"\n    \n    has_letters = any(char.isalpha() for char in s)\n    \n    for char in s:\n        if char.isalpha():\n            result += char.swapcase()\n        else:\n            result += char\n    \n    if not has_letters:\n        result = s[::-1]\n    \n    return result\n",
        "def solve(s):\n    result = \"\"\n    has_letters = False\n\n    for char in s:\n        if char.isalpha():\n            has_letters = True\n            result += char.upper() if char.islower() else char.lower()\n        else:\n            result += char\n\n    if not has_letters:\n        return s[::-1]\n\n    return result\n",
        "def solve(s):\n    result = \"\"\n    \n    if not any(char.isalpha() for char in s):\n        return s[::-1]\n    \n    for char in s:\n        if char.isalpha():\n            result += char.swapcase()\n        else:\n            result += char\n    \n    return result\n"
    ],
    "HumanEval/162": [
        "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    else:\n        md5_hash = hashlib.md5(text.encode()).hexdigest()\n        return md5_hash\n",
        "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    \n    md5_hash = hashlib.md5(text.encode()).hexdigest()\n    return md5_hash\n",
        "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    \n    md5_hash = hashlib.md5(text.encode()).hexdigest()\n    return md5_hash\n",
        "import hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its MD5 hash equivalent string.\n    If 'text' is an empty string, return None.\n    \"\"\"\n    if not text:\n        return None\n    \n    md5_hash = hashlib.md5()\n    md5_hash.update(text.encode('utf-8'))\n    \n    return md5_hash.hexdigest()\n",
        "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    \n    hash_object = hashlib.md5(text.encode())\n    return hash_object.hexdigest()\n"
    ],
    "HumanEval/163": [
        "def generate_integers(a, b):\n    even_digits = []\n    \n    if a > b:\n        a, b = b, a  # Swap a and b if a is greater than b\n        \n    for num in range(a, b+1):\n        if int(str(num)[-1]) % 2 == 0:\n            even_digits.append(num)\n    \n    return even_digits\n",
        "def generate_integers(a, b):\n    even_digits = []\n    for num in range(a, b+1):\n        if num % 2 == 0:\n            even_digits.append(num)\n    return even_digits\n",
        "def generate_integers(a, b):\n    result = []\n    \n    for i in range(a, b+1):\n        if i % 2 == 0:\n            result.append(i)\n    \n    return result\n",
        "def generate_integers(a, b):\n    even_digits = []\n    \n    if a > b:\n        a, b = b, a\n    \n    for num in range(a, b + 1):\n        if num % 2 == 0:\n            even_digits.append(num)\n    \n    return even_digits\n",
        "def generate_integers(a, b):\n    even_digits = []\n    \n    for num in range(a, b+1):\n        if num % 2 == 0:\n            even_digits.append(num)\n    \n    return even_digits\n"
    ]
}
{
    "HumanEval/0": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n",
    "HumanEval/1": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    groups = []\n    current_group = \"\"\n    nesting_level = 0\n    \n    for char in paren_string:\n        if char == '(':\n            nesting_level += 1\n            current_group += char\n        elif char == ')':\n            nesting_level -= 1\n            current_group += char\n            if nesting_level == 0:\n                groups.append(current_group)\n                current_group = \"\"\n        elif char != ' ':\n            current_group += char\n    \n    return groups\n",
    "HumanEval/2": "def truncate_number(number: float) -> float:\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n",
    "HumanEval/3": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False\n",
    "HumanEval/4": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    abs_diffs = [abs(num - mean) for num in numbers]\n    mad = sum(abs_diffs) / len(numbers)\n    return mad\n",
    "HumanEval/5": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"\n    Insert a number 'delimeter' between every two consecutive elements of input list `numbers`.\n    \n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    result = []\n    if not numbers:\n        return result\n    \n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimeter)\n    \n    return result\n",
    "HumanEval/6": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    output = []\n    for group in paren_string.split():\n        max_depth = 0\n        depth = 0\n        for char in group:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        output.append(max_depth)\n    return output\n",
    "HumanEval/7": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]\n",
    "HumanEval/8": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_of_numbers = 0\n    product_of_numbers = 1\n    \n    for num in numbers:\n        sum_of_numbers += num\n        product_of_numbers *= num\n    \n    return (sum_of_numbers, product_of_numbers)\n",
    "HumanEval/9": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n\n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n\n    return result\n",
    "HumanEval/10": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    if not string:\n        return ''\n\n    for i in range(len(string), -1, -1):\n        if is_palindrome(string[i:]):\n            palindromic_suffix = string[i:]\n            break\n    else:\n        palindromic_suffix = string\n\n    prefix = string[:-len(palindromic_suffix)]\n    return string + prefix[::-1]\n",
    "HumanEval/11": "def string_xor(a: str, b: str) -> str:\n    if len(a) != len(b):\n        raise ValueError(\"Input strings must have the same length.\")\n    \n    result = \"\"\n    for i in range(len(a)):\n        result += str(int(a[i]) ^ int(b[i]))\n    \n    return result\n",
    "HumanEval/12": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n\n    longest_str = strings[0]\n    for s in strings[1:]:\n        if len(s) > len(longest_str):\n            longest_str = s\n        elif len(s) == len(longest_str):\n            # Keep longest_str as is to preserve the first longest string\n            pass\n\n    return longest_str\n",
    "HumanEval/13": "def greatest_common_divisor(a: int, b: int) -> int:\n    if b == 0:\n        return a\n    else:\n        return greatest_common_divisor(b, a % b)\n",
    "HumanEval/14": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    prefixes = []\n    for i in range(1, len(string)+1):\n        prefixes.append(string[:i])\n    return prefixes\n",
    "HumanEval/15": "def string_sequence(n: int) -> str:\n    return ' '.join(str(i) for i in range(n+1))\n",
    "HumanEval/16": "def count_distinct_characters(string: str) -> int:\n    char_set = set(char.lower() for char in string)\n    return len(char_set)\n",
    "HumanEval/17": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    note_durations = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    \n    notes = music_string.split()\n    result = []\n    for note in notes:\n        result.append(note_durations[note])\n    \n    return result\n",
    "HumanEval/18": "def how_many_times(string: str, substring: str) -> int:\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count\n",
    "HumanEval/19": "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"\n    Input is a space-delimited string of numerals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest.\n\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n    \n    # Step 1: Split the input string into a list of words\n    word_list = numbers.split()\n    \n    # Step 2: Convert the words to their integer values using a dictionary\n    number_dict = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,\n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9\n    }\n    number_list = [number_dict[word] for word in word_list]\n    \n    # Step 3: Sort the list of integers\n    number_list.sort()\n    \n    # Step 4: Join the sorted words back into a new string\n    sorted_words = [list(number_dict.keys())[list(number_dict.values()).index(num)] for num in number_list]\n    return ' '.join(sorted_words)\n",
    "HumanEval/20": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must have at least 2 elements.\")\n    \n    numbers.sort()\n    \n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n    \n    for i in range(len(numbers) - 1):\n        diff = abs(numbers[i] - numbers[i+1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n    \n    return closest_pair\n",
    "HumanEval/21": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_value = min(numbers)\n    max_value = max(numbers)\n    transformed_numbers = [(x - min_value) / (max_value - min_value) for x in numbers]\n    return transformed_numbers\n",
    "HumanEval/22": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"Filter given list of any python values only for integers\"\"\"\n    return [value for value in values if isinstance(value, int)]\n",
    "HumanEval/23": "def strlen(string: str) -> int:\n    \"\"\"\n    Return length of given string.\n    \n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return len(string)\n",
    "HumanEval/24": "def largest_divisor(n: int) -> int:\n    return n // 2\n",
    "HumanEval/25": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"\n    Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors.\n    \n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    i = 2\n    while n > 1:\n        if n % i == 0:\n            factors.append(i)\n            n //= i\n        else:\n            i += 1\n    return factors\n",
    "HumanEval/26": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    unique_numbers = []\n    seen = set()\n\n    for num in numbers:\n        if num not in seen:\n            seen.add(num)\n            unique_numbers.append(num)\n\n    return unique_numbers\n",
    "HumanEval/27": "def flip_case(string: str) -> str:\n    \"\"\"\n    For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    \n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n    return ''.join(char.swapcase() for char in string)\n",
    "HumanEval/28": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    result = ''\n    for s in strings:\n        result += s\n    return result\n",
    "HumanEval/29": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    filtered = [s for s in strings if s.startswith(prefix)]\n    return filtered\n",
    "HumanEval/30": "def get_positive(l: list):\n    positive_nums = []\n    for num in l:\n        if num > 0:\n            positive_nums.append(num)\n    return positive_nums\n",
    "HumanEval/31": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n in (2, 3):\n        return True\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n",
    "HumanEval/32": "import math\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef find_zero(xs: list, tol: float = 1e-8):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 8) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 8) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n    if len(xs) % 2 != 0:\n        raise ValueError(\"Polynomial must have even number of coefficients\")\n\n    if max(xs) == 0:\n        raise ValueError(\"Largest coefficient must be non-zero\")\n\n    a = -10.0  # initial lower bound\n    b = 10.0   # initial upper bound\n    while abs(b - a) > tol:\n        c = (a + b) / 2\n        if abs(poly(xs, c)) < tol:\n            return c\n        if poly(xs, a) * poly(xs, c) < 0:\n            b = c\n        else:\n            a = c\n    raise ValueError(\"No root found within the given tolerance\")\n",
    "HumanEval/33": "def sort_third(l: list):\n    result = []\n    div_by_three = []\n    \n    for i, item in enumerate(l):\n        if i % 3 != 0:\n            result.append(item)\n        else:\n            div_by_three.append(item)\n    \n    div_by_three.sort()\n    \n    for i, item in enumerate(l):\n        if i % 3 == 0:\n            result.append(div_by_three.pop(0))\n        else:\n            result.append(item)\n    \n    return result\n",
    "HumanEval/34": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))\n",
    "HumanEval/35": "def max_element(l: list):\n    if not l:\n        return None\n    max_val = l[0]\n    for num in l[1:]:\n        if num > max_val:\n            max_val = num\n    return max_val\n",
    "HumanEval/36": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(11, n, 11):\n        if '7' in str(i) or any('7' in str(j) for j in range(i, n, i)):\n            count += 1\n    for i in range(13, n, 13):\n        if '7' in str(i) or any('7' in str(j) for j in range(i, n, i)):\n            count += 1\n    return count\n",
    "HumanEval/37": "def sort_even(l: list):\n    result = []\n    even_values = []\n    for i, value in enumerate(l):\n        if i % 2 == 0:\n            even_values.append(value)\n        else:\n            result.append(value)\n    even_values.sort()\n    even_index = 0\n    for i in range(len(result)):\n        if i % 2 == 0:\n            result[i] = even_values[even_index]\n            even_index += 1\n    return result\n",
    "HumanEval/38": "def decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    # Split the string into groups of 3 characters\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    \n    # Rotate each group of 3 characters to the right\n    decoded_groups = []\n    for group in groups:\n        if len(group) == 3:\n            decoded_groups.append(group[-1] + group[:-1])\n        else:\n            decoded_groups.append(group)\n    \n    # Join the decoded groups back into a single string\n    return ''.join(decoded_groups)\n",
    "HumanEval/39": "def is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    fib = [0, 1]\n    i = 2\n    while True:\n        next_fib = fib[i-1] + fib[i-2]\n        fib.append(next_fib)\n        if is_prime(next_fib):\n            if n == 1:\n                return next_fib\n            n -= 1\n        i += 1\n",
    "HumanEval/40": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n    \"\"\"\n    l.sort()\n    for i in range(len(l) - 2):\n        if i > 0 and l[i] == l[i - 1]:\n            continue\n        left = i + 1\n        right = len(l) - 1\n        while left < right:\n            total = l[i] + l[left] + l[right]\n            if total == 0:\n                return True\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return False\n",
    "HumanEval/41": "def car_race_collision(n: int) -> int:\n    collision_count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Calculate the time when the cars collide\n                collision_time = (i + j) / (i + j)\n                # Check if the collision time is positive (i.e., the cars haven't passed each other yet)\n                if collision_time > 0:\n                    collision_count += 1\n    return collision_count\n",
    "HumanEval/42": "def incr_list(l: list):\n    new_list = []\n    for element in l:\n        new_list.append(element + 1)\n    return new_list\n",
    "HumanEval/43": "def pairs_sum_to_zero(l):\n    s = set(l)\n    for i in s:\n        if -i in s and i != -i:\n            return True\n    return False\n",
    "HumanEval/44": "def change_base(x: int, base: int) -> str:\n    if base < 2 or base > 9:\n        raise ValueError(\"Base must be between 2 and 9 (inclusive)\")\n\n    result = \"\"\n    while x > 0:\n        digit = x % base\n        result = str(digit) + result\n        x //= base\n\n    return result if result else \"0\"\n",
    "HumanEval/45": "def triangle_area(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    return 0.5 * a * h\n",
    "HumanEval/46": "",
    "HumanEval/47": "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    if not l:\n        raise ValueError(\"Input list is empty.\")\n\n    l_sorted = sorted(l)\n    n = len(l_sorted)\n\n    if n % 2 == 1:\n        return l_sorted[n // 2]\n    else:\n        middle1 = l_sorted[n // 2 - 1]\n        middle2 = l_sorted[n // 2]\n        return (middle1 + middle2) / 2\n",
    "HumanEval/48": "def is_palindrome(text: str) -> bool:\n    left = 0\n    right = len(text) - 1\n    \n    while left < right:\n        if text[left] != text[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n",
    "HumanEval/49": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    if n == 0:\n        return 1\n    \n    result = 1\n    x = 2 % p\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * x) % p\n        x = (x * x) % p\n        n //= 2\n    \n    return result\n",
    "HumanEval/50": "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
    "HumanEval/51": "def remove_vowels(text):\n    result = \"\"\n    for char in text:\n        if char.lower() not in \"aeiou\":\n            result += char\n    return result\n",
    "HumanEval/52": "def below_threshold(l: list, t: int):\n    for num in l:\n        if num >= t:\n            return False\n    return True\n",
    "HumanEval/53": "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\n",
    "HumanEval/54": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)\n",
    "HumanEval/55": "def fib(n: int) -> int:\n    \"\"\"Return the n-th Fibonacci number.\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    fib_list = [0, 1]\n    for i in range(2, n+1):\n        fib_list.append(fib_list[i-1] + fib_list[i-2])\n\n    return fib_list[n]\n",
    "HumanEval/56": "def correct_bracketing(brackets: str):\n    balance = 0\n    for char in brackets:\n        if char == \"<\":\n            balance += 1\n        elif char == \">\":\n            balance -= 1\n            if balance < 0:\n                return False\n    return balance == 0\n",
    "HumanEval/57": "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    increasing = False\n    decreasing = False\n    \n    for i in range(len(l) - 1):\n        if l[i] <= l[i+1]:\n            increasing = True\n        if l[i] >= l[i+1]:\n            decreasing = True\n    \n    return increasing or decreasing\n",
    "HumanEval/58": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    l1.sort()\n    l2.sort()\n\n    result = []\n    i, j = 0, 0\n\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            result.append(l1[i])\n            i += 1\n            j += 1\n        elif l1[i] < l2[j]:\n            i += 1\n        else:\n            j += 1\n\n    return result\n",
    "HumanEval/59": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    largest_prime = 1\n    prime = 2\n    \n    while n > 1:\n        if n % prime == 0:\n            largest_prime = prime\n            n //= prime\n        else:\n            if prime == 2:\n                prime = 3\n            else:\n                prime += 2\n    \n    return largest_prime\n",
    "HumanEval/60": "def sum_to_n(n: int) -> int:\n    return n * (n + 1) // 2\n",
    "HumanEval/61": "def correct_bracketing(brackets: str):\n    counter = 0\n    for char in brackets:\n        if char == '(':\n            counter += 1\n        elif char == ')':\n            counter -= 1\n            if counter < 0:\n                return False\n    return counter == 0\n",
    "HumanEval/62": "def derivative(xs: list):\n    result = []\n    for i in range(1, len(xs)):\n        result.append(i * xs[i])\n    return result\n",
    "HumanEval/63": "def fibfib(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n\n    a, b, c = 0, 0, 1\n    for i in range(3, n+1):\n        a, b, c = b, c, a + b + c\n    return c\n",
    "HumanEval/64": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    count = 0\n    vowels = 'aeiou'\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n        elif char.lower() == 'y' and s[-1].lower() == 'y':\n            count += 1\n    return count\n",
    "HumanEval/65": "def circular_shift(x, shift):\n    x_str = str(x)\n    num_digits = len(x_str)\n    if shift < num_digits:\n        return x_str[-shift:] + x_str[:-shift]\n    else:\n        return x_str[::-1]\n",
    "HumanEval/66": "def digitSum(s):\n    total = 0\n    for char in s:\n        if char.isupper():\n            total += ord(char)\n    return total\n",
    "HumanEval/67": "def fruit_distribution(s, n):\n    parts = s.split(\" \")\n    apples = int(parts[0])\n    oranges = int(parts[4])\n    mangoes = n - apples - oranges\n    return mangoes\n",
    "HumanEval/68": "def pluck(arr):\n    if not arr:\n        return []\n\n    smallest_even = float('inf')\n    smallest_even_index = None\n\n    for i, node in enumerate(arr):\n        if node % 2 == 0 and node < smallest_even:\n            smallest_even = node\n            smallest_even_index = i\n\n    if smallest_even_index is None:\n        return []\n\n    return [smallest_even, smallest_even_index]\n",
    "HumanEval/69": "def search(lst):\n    \"\"\"\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    \"\"\"\n    freq = {}\n    for num in lst:\n        freq[num] = freq.get(num, 0) + 1\n    \n    for num in sorted(freq.keys(), reverse=True):\n        if freq[num] >= num:\n            return num\n    \n    return -1\n",
    "HumanEval/70": "def strange_sort_list(lst):\n    result = []\n    while lst:\n        result.append(min(lst))\n        lst.remove(min(lst))\n        if lst:\n            result.append(max(lst))\n            lst.remove(max(lst))\n    return result\n",
    "HumanEval/71": "import math\n\ndef triangle_area(a, b, c):\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return round(area, 2)\n",
    "HumanEval/72": "def will_it_fly(q, w):\n    if q == q[::-1] and sum(q) <= w:\n        return True\n    else:\n        return False\n",
    "HumanEval/73": "def smallest_change(arr):\n    n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - 1 - i]:\n            changes += 1\n    return changes\n",
    "HumanEval/74": "def total_match(lst1, lst2):\n    if not lst1 and not lst2:\n        return []\n\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2\n",
    "HumanEval/75": "def is_prime(n):\n    \"\"\"Returns True if n is a prime number, False otherwise.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a):\n    \"\"\"Returns True if the given number is the multiplication of 3 prime numbers, False otherwise.\"\"\"\n    if a < 100:\n        primes = [p for p in range(2, 100) if is_prime(p)]\n        for i in range(len(primes)):\n            for j in range(i, len(primes)):\n                for k in range(j, len(primes)):\n                    if primes[i] * primes[j] * primes[k] == a:\n                        return True\n    return False\n",
    "HumanEval/76": "def is_simple_power(x, n):\n    if x == 1:\n        return True\n    \n    temp = x\n    while temp % n == 0:\n        temp //= n\n    \n    return temp == 1\n",
    "HumanEval/77": "def iscube(a):\n    if a == 0:\n        return True\n    cube_root = a ** (1/3)\n    if cube_root.is_integer():\n        return True\n    else:\n        return False\n",
    "HumanEval/78": "def hex_key(num):\n    prime_hex_digits = ['2', '3', '5', '7', 'B', 'D']\n    count = 0\n    \n    for digit in num:\n        if digit in prime_hex_digits:\n            count += 1\n    \n    return count\n",
    "HumanEval/79": "def decimal_to_binary(decimal):\n    return \"db\" + bin(decimal)[2:] + \"db\"\n",
    "HumanEval/80": "def is_happy(s):\n    if len(s) < 3:\n        return False\n    \n    unique_chars = set()\n    \n    for char in s:\n        if char in unique_chars:\n            return False\n        unique_chars.add(char)\n    \n    return True\n",
    "HumanEval/81": "def numerical_letter_grade(grades):\n    \"\"\"\n    Converts a list of numerical GPAs to a list of letter grades.\n    \n    Args:\n        grades (list): A list of numerical GPAs.\n    \n    Returns:\n        list: A list of letter grades corresponding to the input GPAs.\n    \"\"\"\n    letter_grades = []\n    for gpa in grades:\n        if gpa >= 4.0:\n            letter_grade = 'A+'\n        elif gpa > 3.7:\n            letter_grade = 'A'\n        elif gpa > 3.3:\n            letter_grade = 'A-'\n        elif gpa > 3.0:\n            letter_grade = 'B+'\n        elif gpa > 2.7:\n            letter_grade = 'B'\n        elif gpa > 2.3:\n            letter_grade = 'B-'\n        elif gpa > 2.0:\n            letter_grade = 'C+'\n        elif gpa > 1.7:\n            letter_grade = 'C'\n        elif gpa > 1.3:\n            letter_grade = 'C-'\n        elif gpa > 1.0:\n            letter_grade = 'D+'\n        elif gpa > 0.7:\n            letter_grade = 'D'\n        elif gpa > 0.0:\n            letter_grade = 'D-'\n        else:\n            letter_grade = 'E'\n        letter_grades.append(letter_grade)\n    return letter_grades\n",
    "HumanEval/82": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_length(string):\n    length = len(string)\n    return is_prime(length)\n",
    "HumanEval/83": "def starts_one_ends(n):\n    return 1 + 9 * 10 ** (n - 1)\n",
    "HumanEval/84": "def solve(N):\n    N_str = str(N)\n    total_sum = 0\n    for digit in N_str:\n        total_sum += int(digit)\n    return bin(total_sum)[2:]\n",
    "HumanEval/85": "def add(lst):\n    total = 0\n    for i in range(len(lst)):\n        if i % 2 == 1 and lst[i] % 2 == 0:\n            total += lst[i]\n    return total\n",
    "HumanEval/86": "def anti_shuffle(s):\n    words = s.split()\n    sorted_words = []\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        sorted_words.append(sorted_word)\n    return ' '.join(sorted_words)\n",
    "HumanEval/87": "def get_row(lst, x):\n    coordinates = []\n    \n    for row_idx, row in enumerate(lst):\n        for col_idx, val in enumerate(row):\n            if val == x:\n                coordinates.append((row_idx, col_idx))\n    \n    coordinates.sort(key=lambda c: (c[0], -c[1]))\n    \n    return coordinates\n",
    "HumanEval/88": "def sort_array(array):\n    sorted_array = array.copy()\n    if len(sorted_array) <= 1:\n        return sorted_array\n    sum_first_last = sorted_array[0] + sorted_array[-1]\n    if sum_first_last % 2 == 1:\n        sorted_array.sort()\n    else:\n        sorted_array.sort(reverse=True)\n    return sorted_array\n",
    "HumanEval/89": "def encrypt(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rotated_alphabet = alphabet[4:] + alphabet[:4]\n    encrypted = ''\n    for char in s:\n        if char.lower() in alphabet:\n            index = alphabet.index(char.lower())\n            encrypted += rotated_alphabet[index]\n        else:\n            encrypted += char\n    return encrypted\n",
    "HumanEval/90": "def next_smallest(lst):\n    if not lst:\n        return None\n    \n    sorted_lst = sorted(lst)\n    if len(sorted_lst) == 1:\n        return None\n    \n    return sorted_lst[1]\n",
    "HumanEval/91": "def is_bored(S):\n    boredom_count = 0\n    sentences = re.split(r\"[.?!]\", S)\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith(\"I \"):\n            boredom_count += 1\n    return boredom_count\n",
    "HumanEval/92": "def any_int(x, y, z):\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        total = x + y + z\n        return total == x or total == y or total == z\n    return False\n",
    "HumanEval/93": "def encode(message):\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            if char.lower() in 'aeiou':\n                new_char = chr((ord(char.lower()) - 'a' + 2) % 26 + 'a')\n                encoded_message += new_char.upper() if char.isupper() else new_char\n            else:\n                encoded_message += char.swapcase()\n    return encoded_message\n",
    "HumanEval/94": "def skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n    \"\"\"\n    if not lst:\n        return 0\n\n    max_num = max(lst)\n    is_prime = [True] * (max_num + 1)\n    is_prime[0] = is_prime[1] = False\n\n    for i in range(2, int(max_num ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, max_num + 1, i):\n                is_prime[j] = False\n\n    largest_prime = max(num for num in lst if is_prime[num])\n\n    if largest_prime == 0:\n        return 0\n\n    digit_sum = sum(int(d) for d in str(largest_prime))\n    return digit_sum\n",
    "HumanEval/95": "def check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    \"\"\"\n    if not dict:\n        return False\n    \n    all_lower = True\n    all_upper = True\n    \n    for key in dict:\n        if not isinstance(key, str):\n            all_lower = False\n            all_upper = False\n            break\n        elif not key.islower():\n            all_lower = False\n        elif not key.isupper():\n            all_upper = False\n    \n    return all_lower or all_upper\n",
    "HumanEval/96": "def count_up_to(n):\n    \"\"\"Implement a function that takes an non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\"\"\"\n    primes = []\n    for i in range(2, n):\n        if is_prime(i):\n            primes.append(i)\n    return primes\n\ndef is_prime(n):\n    \"\"\"Checks if a given number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n",
    "HumanEval/97": "def multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n    \"\"\"\n    a_unit = abs(a) % 10\n    b_unit = abs(b) % 10\n    return a_unit * b_unit\n",
    "HumanEval/98": "def count_upper(s):\n    count = 0\n    for i, char in enumerate(s):\n        if char.isupper() and char in 'AEIOU' and i % 2 == 0:\n            count += 1\n    return count\n",
    "HumanEval/99": "def closest_integer(value):\n    if not isinstance(value, str):\n        raise TypeError(\"Input must be a string\")\n\n    try:\n        num = float(value)\n    except ValueError:\n        raise ValueError(\"Input must be a valid number\")\n\n    return round(num)\n",
    "HumanEval/100": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n    pile = [n]\n    start = n + (1 if n % 2 == 0 else 2)\n    for i in range(1, n):\n        pile.append(start + 2 * i)\n    return pile\n",
    "HumanEval/101": "def words_string(s):\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n    return s.split(\", \") if \",\" in s else s.split()\n",
    "HumanEval/102": "def choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n    if x < 0 or y < 0:\n        return -1\n\n    min_num = min(x, y)\n    max_num = max(x, y)\n\n    biggest_even = -1\n    for num in range(min_num, max_num + 1):\n        if num % 2 == 0 and num > biggest_even:\n            biggest_even = num\n\n    return biggest_even if biggest_even != -1 else -1\n",
    "HumanEval/103": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    total = sum(range(n, m+1))\n    avg = total / (m - n + 1)\n    rounded_avg = round(avg)\n    return bin(rounded_avg)\n",
    "HumanEval/104": "def unique_digits(x):\n    unique_nums = []\n    for num in x:\n        if all(int(digit) % 2 != 0 for digit in str(num)):\n            unique_nums.append(num)\n    return sorted(unique_nums)\n",
    "HumanEval/105": "def by_length(arr):\n    valid_nums = [num for num in arr if 1 <= num <= 9]\n    valid_nums.sort()\n    valid_nums = valid_nums[::-1]\n    name_map = {\n        1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\",\n        6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\n    }\n    result = [name_map[num] for num in valid_nums]\n    return result\n",
    "HumanEval/106": "def f(n):\n    result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            factorial = 1\n            for j in range(1, i+1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            sum_of_numbers = 0\n            for j in range(1, i+1):\n                sum_of_numbers += j\n            result.append(sum_of_numbers)\n    return result\n",
    "HumanEval/107": "def even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n\n    for num in range(1, n+1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)\n",
    "HumanEval/108": "def count_nums(arr):\n    count = 0\n    for num in arr:\n        digit_sum = 0\n        abs_num = abs(num)\n        while abs_num > 0:\n            digit_sum += abs_num % 10\n            abs_num //= 10\n        if digit_sum > 0:\n            count += 1\n    return count\n",
    "HumanEval/109": "def move_one_ball(arr):\n    if not arr:\n        return True\n\n    # Find the index of the smallest element\n    min_idx = 0\n    for i in range(1, len(arr)):\n        if arr[i] < arr[min_idx]:\n            min_idx = i\n\n    # Check if the array can be rotated\n    for i in range(len(arr)):\n        if arr[(i + min_idx) % len(arr)] != arr[i]:\n            return False\n\n    return True\n",
    "HumanEval/110": "def exchange(lst1, lst2):\n    can_exchange = True\n    \n    for num in lst1:\n        if num % 2 != 0:\n            can_exchange = False\n            break\n    \n    if can_exchange:\n        return \"YES\"\n    \n    for i in range(len(lst1)):\n        if lst1[i] % 2 != 0:\n            for j in range(len(lst2)):\n                if lst2[j] % 2 != 0:\n                    lst1[i], lst2[j] = lst2[j], lst1[i]\n                    can_exchange = True\n                    break\n            if can_exchange:\n                break\n    \n    if can_exchange:\n        return \"YES\"\n    else:\n        return \"NO\"\n",
    "HumanEval/111": "def histogram(test):\n    letter_counts = {}\n    words = test.split()\n    for word in words:\n        for letter in word:\n            if letter in letter_counts:\n                letter_counts[letter] += 1\n            else:\n                letter_counts[letter] = 1\n    max_count = max(letter_counts.values())\n    result = {k: v for k, v in letter_counts.items() if v == max_count}\n    return result\n",
    "HumanEval/112": "def reverse_delete(s, c):\n    result = \"\"\n    for char in s:\n        if char not in c:\n            result += char\n    return (result, result == result[::-1])\n",
    "HumanEval/113": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4 in the string 0 of the input.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1 in the string 0 of the input.\",\n     \"the number of odd elements 8 in the string 1 of the input.\"]\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst):\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        output_string = f\"the number of odd elements {odd_count} in the string {i} of the input.\"\n        result.append(output_string)\n    return result\n",
    "HumanEval/114": "def minSubArraySum(nums):\n    min_sum = float('inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n        if current_sum > 0:\n            current_sum = 0\n\n    return min_sum\n",
    "HumanEval/115": "import math\n\ndef max_fill(grid, capacity):\n    total_water = 0\n    total_buckets = 0\n\n    for row in grid:\n        row_water = sum(row)\n        total_water += row_water\n        total_buckets += math.ceil(row_water / capacity)\n\n    return total_buckets\n",
    "HumanEval/116": "def count_ones(num):\n    \"\"\"\n    Helper function to count the number of 1's in the binary representation of a number.\n    \"\"\"\n    return bin(abs(num)).count('1')\n\ndef sort_array(arr):\n    \"\"\"\n    Sorts the input array 'arr' based on the number of 1's in the binary representation\n    of each number, and then by the decimal value of the number.\n    \"\"\"\n    return sorted(arr, key=lambda x: (count_ones(x), x))\n",
    "HumanEval/117": "def select_words(s, n):\n    if not s:\n        return []\n\n    words = s.split()\n    result = []\n    for word in words:\n        consonants = ''.join(c for c in word.lower() if c not in 'aeiou')\n        if len(consonants) == n:\n            result.append(word)\n    return result\n",
    "HumanEval/118": "def get_closest_vowel(word):\n    vowels = 'aeiouAEIOU'\n    last_consonant = -1\n\n    for i, char in enumerate(word):\n        if char in vowels:\n            if last_consonant >= 0 and i < len(word) - 1 and word[i+1] not in vowels:\n                return char\n        elif char not in vowels:\n            last_consonant = i\n\n    return \"\"\n",
    "HumanEval/119": "def match_parens(lst):\n    if len(lst) != 2:\n        return 'No'\n\n    can_be_matched = False\n\n    for string in lst:\n        open_count = 0\n        close_count = 0\n        for char in string:\n            if char == '(':\n                open_count += 1\n            elif char == ')':\n                close_count += 1\n        if open_count == close_count:\n            can_be_matched = True\n            break\n\n    if can_be_matched:\n        return 'Yes'\n    else:\n        return 'No'\n",
    "HumanEval/120": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return arr[:k]\n",
    "HumanEval/121": "def solution(lst):\n    total = 0\n    for i in range(len(lst)):\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            total += lst[i]\n    return total\n",
    "HumanEval/122": "def add_elements(arr, k):\n    total = 0\n    for i in range(k):\n        if abs(arr[i]) < 100:\n            total += arr[i]\n    return total\n",
    "HumanEval/123": "def get_odd_collatz(n):\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    odd_numbers = []\n    \n    while n != 1:\n        if n % 2 == 1:\n            odd_numbers.append(n)\n        n = 3 * n + 1 if n % 2 == 1 else n // 2\n    \n    odd_numbers.append(1)\n    \n    return sorted(odd_numbers)\n",
    "HumanEval/124": "import calendar\n\ndef valid_date(date):\n    if not isinstance(date, str) or len(date.split('-')) != 3:\n        return False\n\n    month_str, day_str, year_str = date.split('-')\n\n    try:\n        month = int(month_str)\n        day = int(day_str)\n        year = int(year_str)\n    except ValueError:\n        return False\n\n    max_days = calendar.monthrange(year, month)[1]\n\n    if day < 1 or day > max_days:\n        return False\n\n    return True\n",
    "HumanEval/125": "def split_words(txt):\n    words = txt.split(',')\n    if len(words) > 1:\n        return words\n\n    words = txt.split()\n    if len(words) > 1:\n        return words\n\n    odd_count = 0\n    for char in txt:\n        if char.islower():\n            ord_value = ord(char) - ord('a')\n            if ord_value % 2 == 1:\n                odd_count += 1\n    return odd_count\n",
    "HumanEval/126": "def is_sorted(lst):\n    prev = None\n    unique_elements = set()\n\n    for num in lst:\n        if prev is not None and num < prev:\n            return False\n        unique_elements.add(num)\n        prev = num\n\n    return len(unique_elements) == len(lst)\n",
    "HumanEval/127": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1, interval2):\n    start1, end1 = interval1\n    start2, end2 = interval2\n\n    if end1 < start2 or end2 < start1:\n        return \"NO\"\n\n    start = max(start1, start2)\n    end = min(end1, end2)\n\n    length = end - start + 1\n\n    if is_prime(length):\n        return \"YES\"\n    else:\n        return \"NO\"\n",
    "HumanEval/128": "def prod_signs(arr):\n    if not arr:\n        return None\n\n    product_of_signs = 1\n    sum_of_magnitudes = 0\n\n    for num in arr:\n        if num > 0:\n            product_of_signs *= 1\n        elif num < 0:\n            product_of_signs *= -1\n        else:\n            product_of_signs *= 0\n\n        sum_of_magnitudes += abs(num)\n\n    return product_of_signs * sum_of_magnitudes\n",
    "HumanEval/129": "import heapq\n\ndef minPath(grid, k):\n    n = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    min_heap = []\n\n    def dfs(x, y, path, k):\n        if len(path) == k:\n            heapq.heappush(min_heap, path)\n            if len(min_heap) > 1 and path > min_heap[0]:\n                return\n        for dx, dy in directions:\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < n and 0 <= new_y < n and grid[new_x][new_y] not in path:\n                dfs(new_x, new_y, path + [grid[new_x][new_y]], k)\n\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, [grid[i][j]], k)\n\n    return min_heap[0]\n",
    "HumanEval/130": "def tri(n):\n    \"\"\"\n    Returns a list of the first n+1 numbers in the Tribonacci sequence.\n    \"\"\"\n    tribonacci = [3]  # base case: tri(1) = 3\n    \n    for i in range(2, n+1):\n        if i % 2 == 0:\n            tribonacci.append(1 + i//2)\n        else:\n            tribonacci.append(tribonacci[i-2] + tribonacci[i-3] + tribonacci[i-4])\n    \n    return tribonacci\n",
    "HumanEval/131": "def digits(n):\n    product = 1\n    for digit in str(n):\n        if int(digit) % 2 != 0:\n            product *= int(digit)\n    return 0 if product == 1 else product\n",
    "HumanEval/132": "def is_nested(string):\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n",
    "HumanEval/133": "import math\n\ndef sum_squares(lst):\n    sum_of_squares = 0\n    for num in lst:\n        rounded_up = math.ceil(num)\n        squared = rounded_up ** 2\n        sum_of_squares += squared\n    return sum_of_squares\n",
    "HumanEval/134": "def check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    \n    words = txt.split()\n    if not words:\n        return False\n    \n    last_word = words[-1]\n    if last_word and last_word[-1].isalpha():\n        return True\n    else:\n        return False\n",
    "HumanEval/135": "def can_arrange(arr):\n    max_index = -1\n    \n    for i in range(len(arr) - 1, 0, -1):\n        if arr[i] < arr[i-1]:\n            max_index = i - 1\n            break\n    \n    return max_index\n",
    "HumanEval/136": "def largest_smallest_integers(lst):\n    largest_negative = None\n    smallest_positive = None\n\n    for num in lst:\n        if num < 0 and (largest_negative is None or num > largest_negative):\n            largest_negative = num\n        elif num > 0 and (smallest_positive is None or num < smallest_positive):\n            smallest_positive = num\n\n    if largest_negative is None:\n        largest_negative = None\n    if smallest_positive is None:\n        smallest_positive = None\n\n    return (largest_negative, smallest_positive)\n",
    "HumanEval/137": "def compare_one(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n    \"\"\"\n    # Check the type of a and b individually\n    a_type = type(a)\n    b_type = type(b)\n\n    # If both are integers, compare the values and return the larger one\n    if a_type == int and b_type == int:\n        if a > b:\n            return a\n        elif b > a:\n            return b\n        else:\n            return None\n\n    # If both are floats, compare the values and return the larger one\n    elif a_type == float and b_type == float:\n        if a > b:\n            return a\n        elif b > a:\n            return b\n        else:\n            return None\n\n    # If both are strings, remove any commas, convert to floats, and then compare the values and return the larger one\n    elif a_type == str and b_type == str:\n        a_float = float(a.replace(\",\", \".\"))\n        b_float = float(b.replace(\",\", \".\"))\n        if a_float > b_float:\n            return a\n        elif b_float > a_float:\n            return b\n        else:\n            return None\n\n    # If the types are different, return None\n    else:\n        return None\n",
    "HumanEval/138": "def is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\"\"\"\n    if n % 4 != 0:\n        return False\n    even_numbers = [2, 4, 6, 8]\n    sum_of_even_numbers = sum(even_numbers)\n    while sum_of_even_numbers < n:\n        even_numbers = [num + 2 for num in even_numbers]\n        sum_of_even_numbers = sum(even_numbers)\n    return sum_of_even_numbers == n\n",
    "HumanEval/139": "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result\n\ndef factorial(n):\n    \"\"\"Calculates the factorial of a number n.\"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n",
    "HumanEval/140": "def fix_spaces(text):\n    result = \"\"\n    prev_char = None\n    for char in text:\n        if char == \" \":\n            if prev_char == \" \":\n                result += \"-\"\n            else:\n                result += \"_\"\n        else:\n            result += char\n        prev_char = char\n    return result\n",
    "HumanEval/141": "def file_name_check(file_name):\n    # Initialize the result\n    result = \"Yes\"\n\n    # Check for more than 3 digits\n    if sum(c.isdigit() for c in file_name) > 3:\n        result = \"No\"\n        return result\n\n    # Check for exactly one dot\n    if file_name.count(\".\") != 1:\n        result = \"No\"\n        return result\n\n    # Split the file name into two parts\n    parts = file_name.split(\".\")\n    before_dot, after_dot = parts[0], parts[1]\n\n    # Check if the part before the dot is empty\n    if not before_dot:\n        result = \"No\"\n        return result\n\n    # Check if the first character of the part before the dot is a letter\n    if not before_dot[0].isalpha():\n        result = \"No\"\n        return result\n\n    # Check if the part after the dot is a valid extension\n    valid_extensions = [\"txt\", \"exe\", \"dll\"]\n    if after_dot not in valid_extensions:\n        result = \"No\"\n        return result\n\n    return result\n",
    "HumanEval/142": "def sum_squares(lst):\n    result = 0\n    for i, x in enumerate(lst):\n        if i % 3 == 0:\n            result += x ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            result += x ** 3\n        else:\n            result += x\n    return result\n",
    "HumanEval/143": "def words_in_sentence(sentence):\n    max_word_length = max(len(word) for word in sentence.split())\n    prime_lengths = get_prime_numbers(max_word_length)\n    return ' '.join(word for word in sentence.split() if len(word) in prime_lengths and word.isalpha())\n\ndef get_prime_numbers(max_length):\n    primes = set()\n    for i in range(2, max_length + 1):\n        if is_prime(i):\n            primes.add(i)\n    return primes\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n",
    "HumanEval/144": "def simplify(x, n):\n    # Extract the numerators and denominators\n    x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n\n    # Calculate the product of the numerators and denominators\n    product_num = x_num * n_num\n    product_den = x_den * n_den\n\n    # Check if the product of the numerators is divisible by the product of the denominators\n    return product_num % product_den == 0\n",
    "HumanEval/145": "def order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    return sorted(nums, key=lambda x: (sum(int(digit) for digit in str(abs(x))), nums.index(x)))\n",
    "HumanEval/146": "def specialFilter(nums):\n    count = 0\n    for num in nums:\n        if num > 10:\n            first_digit = int(str(abs(num))[0])\n            last_digit = int(str(abs(num))[-1])\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count\n",
    "HumanEval/147": "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n+1)]\n    count_0 = count_1 = count_2 = 0\n    for x in a:\n        remainder = x % 3\n        if remainder == 0:\n            count_0 += 1\n        elif remainder == 1:\n            count_1 += 1\n        else:\n            count_2 += 1\n    return count_0 * count_1 * count_2\n",
    "HumanEval/148": "def bf(planet1, planet2):\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    result = planets[min(index1, index2):max(index1, index2)+1]\n    return tuple(sorted(result))\n",
    "HumanEval/149": "def sorted_list_sum(lst):\n    filtered_sorted_lst = []\n    for word in lst:\n        if len(word) % 2 == 0:\n            filtered_sorted_lst.append(word)\n    filtered_sorted_lst.sort(key=lambda x: (len(x), x))\n    return filtered_sorted_lst\n",
    "HumanEval/150": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef x_or_y(n, x, y):\n    if is_prime(n):\n        return x\n    else:\n        return y\n",
    "HumanEval/151": "def double_the_difference(lst):\n    sum_of_squares = 0\n    for num in lst:\n        if isinstance(num, int):\n            if num % 2 != 0:\n                sum_of_squares += 2 * (num ** 2 - num)\n    return sum_of_squares\n",
    "HumanEval/152": "def compare(game, guess):\n    results = []\n    \n    for i in range(len(game)):\n        if game[i] == guess[i]:\n            results.append(0)\n        else:\n            results.append(abs(game[i] - guess[i]))\n    \n    return results\n",
    "HumanEval/153": "def Strongest_Extension(class_name, extensions):\n    strongest_extension = None\n    strongest_strength = float('-inf')\n\n    for extension in extensions:\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        strength = cap - sm\n\n        if strength > strongest_strength or (strength == strongest_strength and extensions.index(extension) < extensions.index(strongest_extension)):\n            strongest_extension = extension\n            strongest_strength = strength\n\n    return f\"{class_name}.{strongest_extension}\"\n",
    "HumanEval/154": "def cycpattern_check(a, b):\n    n = len(b)\n    rotated_words = [b[i:] + b[:i] for i in range(n)]\n    for word in rotated_words:\n        if word in a:\n            return True\n    return False\n",
    "HumanEval/155": "def even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n\n    num_str = str(abs(num))\n\n    for digit in num_str:\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    return (even_count, odd_count)\n",
    "HumanEval/156": "def int_to_mini_roman(number):\n    if not 1 <= number <= 1000:\n        raise ValueError(\"Number must be between 1 and 1000 (inclusive)\")\n\n    roman_numeral = \"\"\n\n    roman_values = {\n        1000: \"m\",\n        900: \"cm\",\n        500: \"d\",\n        400: \"cd\",\n        100: \"c\",\n        90: \"xc\",\n        50: \"l\",\n        40: \"xl\",\n        10: \"x\",\n        9: \"ix\",\n        5: \"v\",\n        4: \"iv\",\n        1: \"i\"\n    }\n\n    for value in sorted(roman_values, reverse=True):\n        count = number // value\n        roman_numeral += (roman_values[value] * count)\n        number -= value * count\n\n    return roman_numeral\n",
    "HumanEval/157": "def right_angle_triangle(a, b, c):\n    # Determine the longest side (hypotenuse)\n    hypotenuse = max(a, b, c)\n    \n    # Calculate the squares of the other two sides\n    a_squared = a ** 2\n    b_squared = b ** 2\n    c_squared = c ** 2\n    \n    # Check if the square of the hypotenuse is equal to the sum of the squares of the other two sides\n    if hypotenuse ** 2 == a_squared + b_squared or hypotenuse ** 2 == a_squared + c_squared or hypotenuse ** 2 == b_squared + c_squared:\n        return True\n    else:\n        return False\n",
    "HumanEval/158": "def find_max(words):\n    max_unique = 0\n    max_word = \"\"\n    \n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique and word < max_word:\n            max_word = word\n    \n    return max_word\n",
    "HumanEval/159": "def eat(number, need, remaining):\n    if not (0 <= number <= 1000 and 0 <= need <= 1000 and 0 <= remaining <= 1000):\n        raise ValueError(\"Input values must be within the given constraints.\")\n\n    total_eaten = min(number + need, number + remaining)\n    remaining_carrots = max(remaining - need, 0)\n\n    return [total_eaten, remaining_carrots]\n",
    "HumanEval/160": "def do_algebra(operator, operand):\n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The length of the operator list must be equal to the length of the operand list minus one.\")\n    \n    for op in operand:\n        if op < 0:\n            raise ValueError(\"The operand list must contain only non-negative integers.\")\n    \n    if len(operator) < 1 or len(operand) < 2:\n        raise ValueError(\"The operator list must have at least one operator, and the operand list must have at least two operands.\")\n    \n    result = operand[0]\n    \n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i+1]\n        elif operator[i] == '-':\n            result -= operand[i+1]\n        elif operator[i] == '*':\n            result *= operand[i+1]\n        elif operator[i] == '//':\n            result //= operand[i+1]\n        elif operator[i] == '**':\n            result **= operand[i+1]\n        else:\n            raise ValueError(f\"Unknown operator: {operator[i]}\")\n    \n    return result\n",
    "HumanEval/161": "def solve(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            result += char.swapcase()\n        else:\n            result += char\n    \n    if not result:\n        return s[::-1]\n    \n    return result\n",
    "HumanEval/162": "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    text_bytes = text.encode('utf-8')\n    md5_hash = hashlib.md5(text_bytes)\n    md5_string = md5_hash.hexdigest()\n    return md5_string\n",
    "HumanEval/163": "def generate_integers(a, b):\n    even_digits = []\n    for num in (a, b):\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                even_digits.append(int(digit))\n    return sorted(set(even_digits))\n"
}
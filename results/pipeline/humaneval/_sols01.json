{
    "HumanEval/0": "from typing import List\\n\\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\\n    numbers.sort()\\n    \\n    for i in range(len(numbers) - 1):\\n        if abs(numbers[i] - numbers[i+1]) < threshold:\\n            return True\\n\\n    return False\\n",
    "HumanEval/1": "from typing import List\\n\\ndef separate_paren_groups(paren_string: str) -> List[str]:\\n    paren_string = paren_string.replace(\\\" \\\", \\\"\\\")\\n    separated_groups = []\\n    left = 0\\n    right = 0\\n    start = 0\\n    for i, char in enumerate(paren_string):\\n        if char == '(':\\n            left += 1\\n        elif char == ')':\\n            right += 1\\n        \\n        if left == right:\\n            separated_groups.append(paren_string[start:(i+1)])\\n            start = i + 1\\n    \\n    return separated_groups\\n",
    "HumanEval/2": "def truncate_number(number: float) -> float:\\n    int_part = int(number)\\n    decimal_part = number - int_part\\n    return decimal_part\\n",
    "HumanEval/3": "from typing import List\\n\\ndef below_zero(operations: List[int]) -> bool:\\n    balance = 0\\n\\n    for operation in operations:\\n        balance += operation\\n        \\n        if balance < 0:\\n            return True\\n\\n    return False\\n",
    "HumanEval/4": "from typing import List\\n\\ndef mean_absolute_deviation(numbers: List[float]) -> float:\\n    mean = sum(numbers) / len(numbers)\\n    \\n    absolute_diff = [abs(num - mean) for num in numbers]\\n    \\n    mean_abs_dev = sum(absolute_diff) / len(numbers)\\n    return mean_abs_dev\\n",
    "HumanEval/5": "from typing import List\\n\\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\\n    result = []\\n    \\n    for i, num in enumerate(numbers):\\n        result.append(num)\\n        \\n        if i != len(numbers) - 1:\\n            result.append(delimiter)\\n    \\n    return result\\n",
    "HumanEval/6": "from typing import List\\n\\ndef parse_nested_parens(paren_string: str) -> List[int]:\\n    groups = paren_string.split()\\n    result = []\\n    \\n    for group in groups:\\n        max_count = 0\\n        open_count = 0\\n        \\n        for char in group:\\n            if char == '(':\\n                open_count += 1\\n                if open_count > max_count:\\n                    max_count = open_count\\n            elif char == ')':\\n                open_count -= 1\\n        \\n        result.append(max_count)\\n    \\n    return result\\n",
    "HumanEval/7": "from typing import List\\n\\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\\n    filtered_strings = []\\n    \\n    for string in strings:\\n        if substring in string:\\n            filtered_strings.append(string)\\n    \\n    return filtered_strings\\n",
    "HumanEval/8": "from typing import List, Tuple\\n\\n\\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\\n    sum_result = 0\\n    product_result = 1\\n\\n    if not numbers:\\n        return sum_result, product_result\\n\\n    for num in numbers:\\n        sum_result += num\\n        product_result *= num\\n\\n    return sum_result, product_result\\n",
    "HumanEval/9": "from typing import List\\n\\ndef rolling_max(numbers: List[int]) -> List[int]:\\n    rolling_max_list = []\\n    max_val = float('-inf')\\n    \\n    for num in numbers:\\n        max_val = max(max_val, num)\\n        rolling_max_list.append(max_val)\\n    \\n    return rolling_max_list\\n",
    "HumanEval/10": "def is_palindrome(string: str) -> bool:\\n    \\\"\\\"\\\" Test if given string is a palindrome \\\"\\\"\\\"\\n    return string == string[::-1]\\n\\n\\ndef make_palindrome(string: str) -> str:\\n    if not string:\\n        return ''\\n\\n    if is_palindrome(string):\\n        return string\\n\\n    for i in range(len(string) - 1, -1, -1):\\n        if is_palindrome(string[i:]):\\n            return string + string[:i-1][::-1]\\n",
    "HumanEval/11": "from typing import List\\n\\ndef string_xor(a: str, b: str) -> str:\\n    int_a = int(a, 2)\\n    int_b = int(b, 2)\\n    \\n    xor_result = int_a ^ int_b\\n    \\n    xor_result_str = bin(xor_result)[2:]\\n\\n    return xor_result_str\\n",
    "HumanEval/12": "from typing import List, Optional\\n\\ndef longest(strings: List[str]) -> Optional[str]:\\n    if not strings:\\n        return None\\n\\n    max_length = 0\\n    longest_string = None\\n\\n    for string in strings:\\n        if len(string) > max_length:\\n            max_length = len(string)\\n            longest_string = string\\n\\n    return longest_string\\n",
    "HumanEval/13": "def greatest_common_divisor(a: int, b: int) -> int:\\n    \\\"\\\"\\\" Return a greatest common divisor of two integers a and b\\n    >>> greatest_common_divisor(3, 5)\\n    1\\n    >>> greatest_common_divisor(25, 15)\\n    5\\n    \\\"\\\"\\\"\\n    gcd = None\\n    \\n    while b != 0:\\n        a, b = b, a % b\\n    \\n    return a\\n\\n# Testing the function with example test cases\\nif __name__ == \\\"__main__\\\":\\n    import doctest\\n    doctest.testmod()\\n",
    "HumanEval/14": "from typing import List\\n\\ndef all_prefixes(string: str) -> List[str]:\\n    prefixes = []\\n    \\n    for i in range(len(string)):\\n        prefix = string[:i+1]\\n        prefixes.append(prefix)\\n        \\n    return prefixes\\n",
    "HumanEval/15": "def string_sequence(n: int) -> str:\\n    seq = \\\"0\\\"  # Step 1: Initialize the sequence string starting from 0\\n    \\n    # Step 2: Loop through numbers from 1 to n inclusive\\n    for i in range(1, n + 1):\\n        seq += \\\" \\\" + str(i)  # Append each number with a space delimiter\\n    \\n    return seq  # Step 3: Return the final sequence string\\n",
    "HumanEval/16": "def count_distinct_characters(string: str) -> int:\\n    unique_chars = set()\\n    lowercase_string = string.lower()\\n    \\n    for char in lowercase_string:\\n        if char.isalpha():\\n            unique_chars.add(char)\\n    \\n    return len(unique_chars)\\n",
    "HumanEval/17": "from typing import List\\n\\ndef parse_music(music_string: str) -> List[int]:\\n    notes = music_string.split()\\n    beats = []\\n    for note in notes:\\n        if note == 'o':\\n            beats.append(4)\\n        elif note == 'o|':\\n            beats.append(2)\\n        elif note == '.|':\\n            beats.append(1)\\n        else:\\n            beats.extend([4 if n == 'o' else 2 if n == 'o|' else 1 for n in note.split('|')])    \\n    return beats\\n\\n# Test the function with an example\\nresult = parse_music('o o| .| o| o| .| .| .| .| o o')\\nprint(result)\\n",
    "HumanEval/18": "def how_many_times(string: str, substring: str) -> int:\\n    \\\"\\\"\\\" Find how many times a given substring can be found in the original string. Count overlapping cases.\\\"\\\"\\\"\\n    \\n    # Handle corner case when input string is empty\\n    if not string:\\n        return 0\\n    \\n    count = 0\\n    substr_len = len(substring)\\n    \\n    # Count the number of occurrences of the substring in the string\\n    for i in range(len(string) - substr_len + 1):\\n        if string[i:i+substr_len] == substring:\\n            count += 1\\n            \\n    return count\\n",
    "HumanEval/19": "def sort_numbers(numbers: str) -> str:\\n    number_words = numbers.split()\\n    \\n    number_map = {\\n        'zero': 0,\\n        'one': 1,\\n        'two': 2,\\n        'three': 3,\\n        'four': 4,\\n        'five': 5,\\n        'six': 6,\\n        'seven': 7,\\n        'eight': 8,\\n        'nine': 9\\n    }\\n    \\n    sorted_number_words = sorted(number_words, key=lambda x: number_map[x])\\n    sorted_numbers_str = ' '.join(sorted_number_words)\\n    \\n    return sorted_numbers_str\\n",
    "HumanEval/20": "from typing import List, Tuple\\n\\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\\n    if len(numbers) < 2:\\n        raise ValueError(\\\"Input list must have at least two elements.\\\")\\n\\n    sorted_numbers = sorted(numbers)\\n\\n    closest_pair = None\\n    closest_distance = float('inf')\\n\\n    for i in range(len(sorted_numbers) - 1):\\n        distance = abs(sorted_numbers[i] - sorted_numbers[i + 1])\\n        if distance < closest_distance:\\n            closest_distance = distance\\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\\n\\n    return closest_pair\\n",
    "HumanEval/21": "from typing import List\\n\\n\\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\\n    min_num = min(numbers)\\n    max_num = max(numbers)\\n    range_nums = max_num - min_num\\n\\n    rescaled_nums = [(num - min_num) / range_nums for num in numbers]\\n    \\n    return rescaled_nums\\n",
    "HumanEval/22": "from typing import List, Any\\n\\ndef filter_integers(values: List[Any]) -> List[int]:\\n    filtered_integers = []\\n    \\n    for value in values:\\n        if isinstance(value, int):\\n            filtered_integers.append(value)\\n    \\n    return filtered_integers\\n",
    "HumanEval/23": "def strlen(string: str) -> int:\\n    \\\"\\\"\\\" Return length of given string\\n    >>> strlen('')\\n    0\\n    >>> strlen('abc')\\n    3\\n    \\\"\\\"\\\"\\n    return len(string)\\n",
    "HumanEval/24": "def largest_divisor(n: int) -> int:\\n    largest_div = 1\\n    for i in range(2, n):\\n        if n % i == 0:\\n            if i > largest_div:\\n                largest_div = i\\n    return largest_div\\n",
    "HumanEval/25": "from typing import List\\n\\ndef factorize(n: int) -> List[int]:\\n    factors = []\\n    divisor = 2\\n    \\n    while n > 1:\\n        if n % divisor == 0:\\n            factors.append(divisor)\\n            n //= divisor\\n        else:\\n            divisor += 1\\n    \\n    return factors\\n",
    "HumanEval/26": "from typing import List\\n\\n\\ndef remove_duplicates(numbers: List[int]) -> List[int]:\\n    unique_numbers = []\\n    \\n    for num in numbers:\\n        if num not in unique_numbers:\\n            unique_numbers.append(num)\\n    \\n    return unique_numbers\\n",
    "HumanEval/27": "def flip_case(string: str) -> str:\\n    result = \\\"\\\"\\n    for char in string:\\n        if char.islower():\\n            result += char.upper()\\n        elif char.isupper():\\n            result += char.lower()\\n        else:\\n            result += char\\n    return result\\n",
    "HumanEval/28": "from typing import List\\n\\ndef concatenate(strings: List[str]) -> str:\\n    result = ''\\n    for string in strings:\\n        result += string\\n    return result\\n",
    "HumanEval/29": "from typing import List\\n\\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\\n    result = []\\n    for string in strings:\\n        if string.startswith(prefix):\\n            result.append(string)\\n    return result\\n",
    "HumanEval/30": "def get_positive(l: list):\\n    pos_nums = []\\n    \\n    # Iterate through the input list.\\n    for num in l:\\n        # Check if the number is positive.\\n        if num > 0:\\n            # If it is positive, add it to the new list.\\n            pos_nums.append(num)\\n    \\n    return pos_nums\\n",
    "HumanEval/31": "import math\\n\\ndef is_prime(n):\\n    if n < 2:\\n        return False\\n        \\n    for i in range(2, math.isqrt(n) + 1):\\n        if n % i == 0:\\n            return False\\n            \\n    return True\\n",
    "HumanEval/32": "    if len(xs) % 2 != 0 or xs[-1] == 0:\\n        raise ValueError(\\\"Input list xs must have an even number of coefficients \\\"\\n                         \\\"and the largest non-zero coefficient.\\\")\\n\\n    degree = len(xs) // 2\\n",
    "HumanEval/33": "def sort_third(l: list):\\n    result = []\\n    to_sort = []\\n    \\n    for i, val in enumerate(l):\\n        if i % 3 == 0:\\n            to_sort.append(val)\\n            result.append(None)  # Placeholder for values to be sorted later\\n        else:\\n            result.append(val)\\n\\n    indices_to_sort = [i for i in range(len(l)) if i % 3 == 0]\\n    sorted_values = sorted(to_sort)\\n\\n    for i, sorted_val in zip(indices_to_sort, sorted_values):\\n        result[i] = sorted_val\\n\\n    final_result = [result[i] if i in indices_to_sort else val for i, val in enumerate(l)]\\n\\n    return final_result\\n",
    "HumanEval/34": "def unique(l: list):\\n    unique_set = set(l)\\n    unique_list = list(unique_set)\\n    return sorted(unique_list)\\n",
    "HumanEval/35": "def max_element(l: list):\\n    \\\"\\\"\\\"Return maximum element in the list.\\n    >>> max_element([1, 2, 3])\\n    3\\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\\n    123\\n    \\\"\\\"\\\"\\n    \\n    max_num = l[0]\\n    \\n    for num in l[1:]:\\n        if num > max_num:\\n            max_num = num\\n    \\n    return max_num\\n",
    "HumanEval/36": "def fizz_buzz(n: int):\\n    count = 0\\n    \\n    for i in range(1, n):\\n        if i % 11 == 0 or i % 13 == 0:\\n            if '7' in str(i):\\n                count += 1\\n                \\n    return count\\n",
    "HumanEval/37": "def sort_even(l: list):\\n    l_sorted = l.copy()\\n    even_values = sorted(l_sorted[::2])\\n    l_sorted[::2] = even_values\\n    return l_sorted\\n",
    "HumanEval/38": "def decode_cyclic(s: str):\\n    \\\"\\\"\\\"\\n    Takes an input string encoded with encode_cyclic function and returns the decoded string.\\n    \\n    Parameters:\\n    s (str): The encoded string to be decoded.\\n    \\n    Returns:\\n    str: The decoded string.\\n    \\\"\\\"\\\"\\n    \\n    groups = [s[i:i+3] for i in range(0, len(s), 3)]\\n    decoded_groups = [(group[2] + group[:2]) if len(group) == 3 else group for group in groups]\\n    return \\\"\\\".join(decoded_groups)\\n",
    "HumanEval/39": "def is_prime(num: int) -> bool:\\n    if num < 2:\\n        return False\\n    for i in range(2, int(num**0.5) + 1):\\n        if num % i == 0:\\n            return False\\n    return True\\n\\ndef prime_fib(n: int) -> int:\\n    def generate_fibonacci():\\n        a, b = 0, 1\\n        yield a\\n        yield b\\n        while True:\\n            a, b = b, a + b\\n            yield b\\n\\n    fibonacci_gen = generate_fibonacci()\\n    count = 0\\n    while count < n:\\n        fib_num = next(fibonacci_gen)\\n        if is_prime(fib_num):\\n            count += 1\\n\\n    return fib_num\\n",
    "HumanEval/40": "def triples_sum_to_zero(l: list):\\n    sorted_list = sorted(l)\\n    \\n    for i in range(len(sorted_list)):\\n        left = i + 1\\n        right = len(sorted_list) - 1\\n        \\n        while left < right:\\n            current_sum = sorted_list[i] + sorted_list[left] + sorted_list[right]\\n            if current_sum == 0:\\n                return True\\n            elif current_sum < 0:\\n                left += 1\\n            else:\\n                right -= 1\\n    \\n    return False\\n",
    "HumanEval/41": "return collisions\\n",
    "HumanEval/42": "def incr_list(l: list):\\n    result = []\\n    \\n    for num in l:\\n        result.append(num + 1)\\n    \\n    return result\\n",
    "HumanEval/43": "def pairs_sum_to_zero(l):\\n    seen_numbers = set()\\n\\n    for num in l:\\n        if -num in seen_numbers:\\n            return True\\n        seen_numbers.add(num)\\n\\n    return False\\n",
    "HumanEval/44": "def change_base(x: int, base: int):\\n    \\\"\\\"\\\"\\n    Change numerical base of input number x to base.\\n    Return string representation after the conversion.\\n    Base numbers are less than 10.\\n    \\\"\\\"\\\"\\n    result = \\\"\\\"\\n    while x > 0:\\n        remainder = x % base\\n        result = str(remainder) + result\\n        x //= base\\n    return result\\n",
    "HumanEval/45": "def triangle_area(a, h):\\n    \\\"\\\"\\\"Given length of a side and height, return the area of a triangle.\\\"\\\"\\\"\\n    \\n    # Calculate the area of the triangle\\n    area = (a * h) / 2\\n    \\n    return area\\n",
    "HumanEval/46": "def fib4(n: int):\\n    fib4_nums = [0, 0, 2, 0]\\n    \\n    for i in range(4, n):\\n        next_num = sum(fib4_nums)\\n        fib4_nums.append(next_num)\\n    \\n    return fib4_nums[n-1]\\n",
    "HumanEval/47": "def median(l: list):\\n    \\\"\\\"\\\"Return median of elements in the list l.\\n    >>> median([3, 1, 2, 4, 5])\\n    3\\n    >>> median([-10, 4, 6, 1000, 10, 20])\\n    15.0\\n    \\\"\\\"\\\"\\n    l.sort()\\n    length = len(l)\\n    is_odd = length % 2 != 0\\n    \\n    if is_odd:\\n        return l[length // 2]\\n",
    "HumanEval/48": "def is_palindrome(text: str):\\n    if len(text) <= 1:\\n        return True\\n    \\n    if text == text[::-1]:\\n        return True\\n    else:\\n        return False\\n",
    "HumanEval/49": "def modp(n: int, p: int):\\n    \\\"\\\"\\\"Return 2^n modulo p (be aware of numerics).\\n    \\\"\\\"\\\"\\n    if n == 0:\\n        return 1\\n    \\n    result = pow(2, n)\\n    \\n    return result % p\\n",
    "HumanEval/50": "def encode_shift(s: str):\\n    \\\"\\\"\\\"\\n    Returns encoded string by shifting every character by 5 in the alphabet.\\n    \\\"\\\"\\\"\\n    return \\\"\\\".join([chr((ord(ch) - ord(\\\"a\\\") - 5) % 26 + ord(\\\"a\\\") if ch.islower() else ch for ch in s])\\n\\n\\ndef decode_shift(s: str):\\n    \\\"\\\"\\\"\\n    Takes as input a string encoded with encode_shift function. Returns decoded string.\\n    \\\"\\\"\\\"\\n    decoded_chars = []\\n    \\n    for ch in s:\\n        original_ch = chr((ord(ch) + 5 - ord(\\\"a\\\")) % 26 + ord(\\\"a\\\") if ch.islower() else ch)\\n        decoded_chars.append(original_ch)\\n    \\n    return \\\"\\\".join(decoded_chars)\\n",
    "HumanEval/51": "def remove_vowels(text):\\n    result = ''\\n    \\n    if not text:\\n        return result\\n    \\n    vowels = 'aeiouAEIOU'\\n    \\n    for char in text:\\n        if char not in vowels:\\n            result += char\\n    \\n    return result\\n",
    "HumanEval/52": "def below_threshold(l: list, t: int):\\n    for num in l:\\n        if num >= t:\\n            return False\\n    return True\\n",
    "HumanEval/53": "def add(x: int, y: int):\\n    \\\"\\\"\\\"Add two numbers x and y\\n    \\\"\\\"\\\"\\n    return x + y\\n",
    "HumanEval/54": "def same_chars(s0: str, s1: str):\\n    if len(s0) != len(s1):\\n        return False\\n    \\n    set_s0 = set(s0)\\n    set_s1 = set(s1)\\n    \\n    return set_s0 == set_s1\\n",
    "HumanEval/55": "def fib(n: int):\\n    \\\"\\\"\\\"Return n-th Fibonacci number.\\n    >>> fib(10)\\n    55\\n    >>> fib(1)\\n    1\\n    >>> fib(8)\\n    21\\n    \\\"\\\"\\\"\\n    if n == 0 or n == 1:\\n        return n\\n    \\n    a, b = 0, 1\\n    \\n    for _ in range(2, n + 1):\\n        a, b = b, a + b\\n        \\n    return b\\n",
    "HumanEval/56": "def correct_bracketing(brackets: str):\\n    stack = []\\n    for bracket in brackets:\\n        if bracket == \\\"<\\\":\\n            stack.append(bracket)\\n        elif bracket == \\\">\\\":\\n            if not stack:\\n                return False\\n            stack.pop()\\n\\n    return not stack\\n",
    "HumanEval/57": "def monotonic(l: list):\\n    increasing = True\\n    decreasing = True\\n    \\n    for i in range(1, len(l)):\\n        if l[i] <= l[i-1]:\\n            increasing = False\\n        if l[i] >= l[i-1]:\\n            decreasing = False\\n    \\n    return increasing or decreasing\\n",
    "HumanEval/58": "def common(l1: list, l2: list):\\n    common_elements = set(l1) & set(l2)\\n    unique_sorted_common_elements = sorted(list(common_elements))\\n    return unique_sorted_common_elements\\n",
    "HumanEval/59": "#!/usr/bin/env python3\\n\\ndef is_prime(num):\\n    if num < 2:\\n        return False\\n    for i in range(2, int(num**0.5) + 1):\\n        if num % i == 0:\\n            return False\\n    return True\\n\\ndef largest_prime_factor(n: int):\\n    largest_prime = 2\\n    i = 2\\n    while i <= n:\\n        if n % i == 0:\\n            n //= i\\n            if is_prime(n):\\n                largest_prime = n\\n        else:\\n            i += 1\\n    return largest_prime\\n\\nprint(largest_prime_factor(13195))  # Expected output: 29\\nprint(largest_prime_factor(2048))  # Expected output: 2\\n",
    "HumanEval/60": "def sum_to_n(n: int):\\n    \\\"\\\"\\\"sum_to_n is a function that sums numbers from 1 to n.\\\"\\\"\\\"\\n    sum_numbers = 0\\n    \\n    for i in range(1, n+1):\\n        sum_numbers += i\\n        \\n    return sum_numbers\\n",
    "HumanEval/61": "def correct_bracketing(brackets: str):\\n    \\\"\\\"\\\"Check if every opening bracket has a corresponding closing bracket.\\\"\\\"\\\"\\n    \\n    count = 0  # Variable to keep track of the balance of brackets\\n\\n    for bracket in brackets:  # Iterate over each character in the brackets string\\n        if bracket == \\\"(\\\":  # If the character is an opening bracket\\n            count += 1  # Increment the count by 1\\n        else:  # If the character is a closing bracket\\n            if count > 0:  # If there are corresponding opening brackets\\n                count -= 1  # Decrement the count by 1\\n            else:  # If there is a closing bracket without an opening bracket\\n                return False  # Return False\\n\\n    return count == 0\\n",
    "HumanEval/62": "def derivative(xs: list):\\n    \\\"\\\"\\\" xs represent coefficients of a polynomial.\\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\\n    Return derivative of this polynomial in the same form.\\n    >>> derivative([3, 1, 2, 4, 5])\\n    [1, 4, 12, 20]\\n    >>> derivative([1, 2, 3])\\n    [2, 6]\\n    \\\"\\\"\\\"\\n    derivatives = []\\n    for i in range(1, len(xs)):\\n        derivatives.append(xs[i] * i)\\n\\n    return derivatives\\n",
    "HumanEval/63": "def fibfib(n: int):\\n    if n == 0:\\n        return 0\\n    elif n == 1:\\n        return 0\\n    elif n == 2:\\n        return 1\\n    else:\\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\\n",
    "HumanEval/64": "def vowels_count(s):\\n    count = 0\\n\\n    for char in s:\\n        if char.lower() in ['a', 'e', 'i', 'o', 'u']:\\n            count += 1\\n        elif char.lower() == 'y' and s[-1].lower() == 'y':\\n            count += 1\\n\\n    return count\\n",
    "HumanEval/65": "def circular_shift(x, shift):\\n    x_str = str(x)\\n    num_digits = len(x_str)\\n    effective_shift = shift % num_digits\\n    shifted_num = x_str[-effective_shift:] + x_str[:-effective_shift]\\n    \\n    if effective_shift == 0 or effective_shift == num_digits:\\n        return x_str[::-1]\\n    else:\\n        return shifted_num\\n",
    "HumanEval/66": "def digitSum(s):\\n    total_sum = 0\\n    \\n    for char in s:\\n        if char.isupper():\\n            total_sum += ord(char)\\n    \\n    return total_sum\\n",
    "HumanEval/67": "def fruit_distribution(s, n):\\n    # Step 1: Parse the input string to extract the number of apples and oranges\\n    apples_str, oranges_str = s.split(\\\" and \\\")\\n    apples_count = int(apples_str.split()[0])\\n    oranges_count = int(oranges_str.split()[0])\\n    \\n    # Step 2: Calculate the number of mango fruits\\n    mango_count = n - apples_count - oranges_count\\n    \\n    return mango_count\\n",
    "HumanEval/68": "def pluck(arr):\\n    smallest_even_value = None\\n    smallest_even_index = None\\n    \\n    for i in range(len(arr)):\\n        if arr[i] % 2 == 0:  # Check if the number is even\\n            if smallest_even_value is None:  # If the smallest even value variable is None\\n                smallest_even_value = arr[i]\\n                smallest_even_index = i\\n            elif arr[i] < smallest_even_value:  # If current element is smaller than smallest even value\\n                smallest_even_value = arr[i]\\n                smallest_even_index = i\\n    \\n    if smallest_even_value is not None:\\n        return [smallest_even_value, smallest_even_index]\\n    else:\\n        return []\\n",
    "HumanEval/69": "def search(lst):\\n    freq_dict = {}\\n    \\n    for num in lst:\\n        if num in freq_dict:\\n            freq_dict[num] += 1\\n        else:\\n            freq_dict[num] = 1\\n    \\n    result = -1\\n    \\n    for num, freq in freq_dict.items():\\n        if num > 0 and freq >= num:\\n            result = max(result, num)\\n    \\n    return result\\n",
    "HumanEval/70": "def strange_sort_list(lst):\\n    if not lst:\\n        return []\\n\\n    result = []\\n    while lst:\\n        min_val = min(lst)\\n        lst.remove(min_val)\\n        result.append(min_val)\\n\\n        if lst:\\n            max_val = max(lst)\\n            lst.remove(max_val)\\n            result.append(max_val)\\n\\n    return result\\n",
    "HumanEval/71": "import math\\n\\ndef triangle_area(a, b, c):\\n    def is_valid_triangle(x, y, z):\\n        return x + y > z and x + z > y and y + z > x\\n\\n    if is_valid_triangle(a, b, c):\\n        s = (a + b + c) / 2\\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\\n        return round(area, 2)\\n    else:\\n        return -1\\n",
    "HumanEval/72": "def will_it_fly(q, w):\\n    def is_palindrome(lst):\\n        return lst == lst[::-1]\\n\\n    def sum_elements(lst):\\n        return sum(lst)\\n\\n    if is_palindrome(q) and sum_elements(q) <= w:\\n        return True\\n    else:\\n        return False\\n",
    "HumanEval/73": "def smallest_change(arr):\\n    n = len(arr)\\n    mid = n // 2\\n    changes = 0\\n\\n    for i in range(mid):\\n        if arr[i] != arr[n - i - 1]:\\n            changes += 1\\n        \\n    total_changes = max(changes, 1)\\n        \\n    return total_changes\\n",
    "HumanEval/74": "def total_match(lst1, lst2):\\n    total_chars_lst1 = sum(len(s) for s in lst1)\\n    total_chars_lst2 = sum(len(s) for s in lst2)\\n    \\n    if total_chars_lst1 < total_chars_lst2:\\n        return lst1\\n    return lst2\\n",
    "HumanEval/75": "def is_multiply_prime(a):\\n    def is_prime(num):\\n        if num < 2:\\n            return False\\n        for i in range(2, int(num ** 0.5) + 1):\\n            if num % i == 0:\\n                return False\\n        return True\\n    \\n    for i in range(2, a):\\n        if is_prime(i):\\n            for j in range(i, a):\\n                if is_prime(j):\\n                    for k in range(j, a):\\n                        if is_prime(k) and i * j * k == a:\\n                            return True\\n    return False\\n",
    "HumanEval/76": "def is_simple_power(x, n):\\n    if x == 1:\\n        return n == 1\\n    if n == 1:\\n        return False\\n    if x == n:\\n        return True\\n\\n    power = 1\\n    while power < x:\\n        power *= n\\n    return power == x\\n",
    "HumanEval/77": "def iscube(a):\\n    def is_perfect_cube(num):\\n        return round(num ** (1/3)) ** 3 == num\\n    \\n    if a >= 0:\\n        return is_perfect_cube(a)\\n    else:\\n        return is_perfect_cube(-a)\\n",
    "HumanEval/78": "def hex_key(num):\\n    prime_digits = ['2', '3', '5', '7', 'B', 'D']\\n    count = 0\\n    \\n    for digit in num:\\n        if digit in prime_digits:\\n            count += 1\\n    \\n    return count\\n",
    "HumanEval/79": "def decimal_to_binary(decimal):\\n    binary_digits = bin(decimal)[2:]\\n    binary_string = 'db' + binary_digits + 'db'\\n    return binary_string\\n",
    "HumanEval/80": "def is_happy(s):\\n    if len(s) < 3:\\n        return False\\n\\n    for i in range(len(s) - 2):\\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\\n            return False\\n\\n    return True\\n",
    "HumanEval/81": "def numerical_letter_grade(grades):\\n    letter_grades = []\\n\\n    for gpa in grades:\\n        if gpa == 4.0:\\n            letter_grades.append('A+')\\n        elif gpa > 3.7:\\n            letter_grades.append('A')\\n        elif gpa > 3.3:\\n            letter_grades.append('A-')\\n        elif gpa > 3.0:\\n            letter_grades.append('B+')\\n        elif gpa > 2.7:\\n            letter_grades.append('B')\\n        elif gpa > 2.3:\\n            letter_grades.append('B-')\\n        elif gpa > 2.0:\\n            letter_grades.append('C+')\\n        elif gpa > 1.7:\\n            letter_grades.append('C')\\n        elif gpa > 1.3:\\n            letter_grades.append('C-')\\n        elif gpa > 1.0:\\n            letter_grades.append('D+')\\n        elif gpa > 0.7:\\n            letter_grades.append('D')\\n        elif gpa >= 0.0:\\n            letter_grades.append('D-')\\n        else:\\n            letter_grades.append('E')\\n\\n    return letter_grades\\n",
    "HumanEval/82": "def prime_length(string):\\n    def is_prime(num):\\n        if num < 2:\\n            return False\\n        for i in range(2, int(num**0.5) + 1):\\n            if num % i == 0:\\n                return False\\n        return True\\n\\n    string_length = len(string)\\n    return is_prime(string_length)\\n",
    "HumanEval/83": "def starts_one_ends(n):\\n    count = 0\\n    for i in range(10**(n-1), 10**n):\\n        if str(i)[0] == '1':\\n            count += 1\\n        if str(i)[-1] == '1':\\n            count += 1\\n    return count\\n",
    "HumanEval/84": "def solve(N):\\n    binary_str = bin(N)[2:]\\n    binary_list = list(map(int, binary_str))\\n    sum_digits = sum(binary_list)\\n    binary_sum = bin(sum_digits)[2:]\\n    return binary_sum\\n",
    "HumanEval/85": "def add(lst):\\n    sum_of_even_at_odd_indices = 0\\n    \\n    for i in range(1, len(lst), 2):\\n        if lst[i] % 2 == 0:\\n            sum_of_even_at_odd_indices += lst[i]\\n    \\n    return sum_of_even_at_odd_indices\\n",
    "HumanEval/86": "def anti_shuffle(s):\\n    words = s.split()\\n    sorted_words = [''.join(sorted(word, key=lambda x: ord(x))) for word in words]\\n    return ' '.join(sorted_words)\\n",
    "HumanEval/87": "def get_row(lst, x):\\n    coordinates = []\\n\\n    for row_index, row in enumerate(lst):\\n        if x in row:\\n            column_index = row.index(x)\\n            coordinates.append((row_index, column_index))\\n\\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\\n\\n    return sorted_coordinates\\n",
    "HumanEval/88": "def sort_array(array):\\n    if not array:\\n        return []  # Return an empty array if the input array is empty\\n    \\n    first_element = array[0]\\n    last_element = array[-1]\\n\\n    array_sum = first_element + last_element\\n\\n    if array_sum % 2 == 1:  # Check if the sum is odd\\n        # Sort the array in ascending order\\n        sorted_array = sorted(array)\\n    else:\\n        # Sort the array in descending order\\n        sorted_array = sorted(array, reverse=True)\\n\\n    return sorted_array\\n",
    "HumanEval/89": "def encrypt(s):\\n    encrypted_text = \\\"\\\"\\n    shift = 2 * 2  # Shifting alphabet down by two multiplied to two places\\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\\n    \\n    for char in s:\\n        if char.islower():\\n            index = alphabet.index(char)\\n            new_index = (index + shift) % len(alphabet)\\n            encrypted_text += alphabet[new_index]\\n        else:\\n            encrypted_text += char\\n    \\n    return encrypted_text\\n",
    "HumanEval/90": "def next_smallest(lst):\\n    if len(lst) < 2:\\n        return None\\n    \\n    unique_elements = list(set(lst))\\n    \\n    if len(unique_elements) < 2:\\n        return None\\n    \\n    sorted_elements = sorted(unique_elements)\\n    \\n    if len(sorted_elements) < 2:\\n        return None\\n    \\n    return sorted_elements[1]\\n",
    "HumanEval/91": "def is_bored(S):\\n    words = S.split()\\n    sentences = []\\n    current_sentence = []\\n    \\n    for word in words:\\n        current_sentence.append(word)\\n        if word.endswith('.') or word.endswith('?') or word.endswith('!'):\\n            sentence = ' '.join(current_sentence)\\n            sentences.append(sentence)\\n            current_sentence = []\\n    \\n    count = sum(1 for sentence in sentences if sentence.startswith('I'))\\n    return count\\n",
    "HumanEval/92": "def any_int(x, y, z):\\n    if all(isinstance(num, int) for num in [x, y, z]):  \\n        if x == y + z or y == x + z or z == x + y:  \\n            return True\\n        else:\\n            return False\\n    else:\\n        return False\\n",
    "HumanEval/93": "def encode(message):\\n    encoded_message = \\\"\\\"\\n    \\n    for char in message:\\n        if char.isalpha():\\n            if char.lower() in ['a', 'e', 'i', 'o', 'u']:\\n                encoded_message += chr(ord(char) + 2).upper()\\n            else:\\n                encoded_message += char.swapcase()\\n        else:\\n            encoded_message += char\\n    \\n    return encoded_message\\n",
    "HumanEval/94": "def is_prime(num):\\n    \\\"\\\"\\\"Check if a number is prime.\\\"\\\"\\\"\\n    if num < 2:\\n        return False\\n    for i in range(2, int(num**0.5) + 1):\\n        if num % i == 0:\\n            return False\\n    return True\\n\\ndef sum_digits_of_largest_prime(lst):\\n    # Step 4: Find the largest prime number in the list and return the sum of its digits\\n    largest_prime = None\\n    for num in lst:\\n        if is_prime(num):\\n            if largest_prime is None or num > largest_prime:\\n                largest_prime = num\\n\\n    if largest_prime is None:\\n        return 0  # Return 0 if no prime number found\\n    return sum(int(digit) for digit in str(largest_prime))\\n",
    "HumanEval/95": "def check_dict_case(dict):\\n    if not dict:  # Check if the dictionary is empty\\n        return False\\n    \\n    first_key = next(iter(dict))  # Get the first key in the dictionary\\n\\n    key_case = first_key.islower()  # Check if the first key is lowercase or not\\n    \\n    for key in dict.keys():  # Iterate over all keys in the dictionary\\n        if key_case != key.islower() and key_case != key.isupper():\\n            return False\\n    \\n    return True  # Return True if all keys meet the condition\\n",
    "HumanEval/96": "def count_up_to(n):\\n    def is_prime(num):\\n        if num < 2:\\n            return False\\n        for i in range(2, int(num ** 0.5) + 1):\\n            if num % i == 0:\\n                return False\\n        return True\\n\\n    prime_numbers = []\\n    if n < 2:\\n        return prime_numbers\\n\\n    num = 2\\n    result = []\\n    while len(result) < n:\\n        if is_prime(num):\\n            result.append(num)\\n        num += 1\\n\\n    return result\\n",
    "HumanEval/97": "def multiply(a, b):\\n    # Step 1: Get the unit digits of a and b\\n    a_unit = abs(a) % 10\\n    b_unit = abs(b) % 10\\n    \\n    # Step 2: Multiply the unit digits together\\n    product = a_unit * b_unit\\n\\n    # Step 3: Return the product\\n    return product\\n",
    "HumanEval/98": "def count_upper(s):\\n    count = 0\\n    vowels = {'A', 'E', 'I', 'O', 'U'}\\n    \\n    for i, char in enumerate(s):\\n        if char.isupper() and i % 2 == 0 and char in vowels:\\n            count += 1\\n    \\n    return count\\n",
    "HumanEval/99": "def closest_integer(value):\\n    # Step 0: Parse the input string value into a floating-point number\\n    value = float(value)\\n    \\n    # Step 1: Determine the integer floor and integer ceiling of the parsed floating-point number\\n    floor_int = int(value)\\n    ceil_int = int(value) + 1\\n    \\n    # Step 2: Calculate the absolute differences between the parsed floating-point number and its integer floor and integer ceiling\\n    diff_floor = roundChecksum.round(abs(value - floor_int), 2)\\n    diff_ceil = roundChecksum.round(abs(value - ceil_int), 2)\\n    \\n    # Step 3: Compare the absolute differences and round away from zero if equidistant\\n    if diff_floor == diff_ceil:\\n        return ceil_int if value > 0 else floor_int\\n    else:\\n        return ceil_int if diff_floor > diff_ceil else floor_int\\n",
    "HumanEval/100": "def make_a_pile(n):\\n    \\\"\\\"\\\"\\n    Given a positive integer n, you have to make a pile of n levels of stones.\\n    The first level has n stones.\\n    The number of stones in the next level is:\\n        - the next odd number if n is odd.\\n        - the next even number if n is even.\\n    Return the number of stones in each level in a list, where element at index\\n    i represents the number of stones in the level (i+1).\\n    \\n    Examples:\\n    >>> make_a_pile(3)\\n    [3, 5, 7]\\n    \\\"\\\"\\\"\\n    stones_per_level = [n]  # Store the stones in the first level\\n    current_stones = n\\n    \\n    for i in range(n - 1):  # Iterate n times for n levels of stones\\n        if current_stones % 2 == 0:\\n            current_stones += 1  # Next odd number of stones for even current stones\\n        else:\\n            current_stones += 2  # Next even number of stones for odd current stones\\n        stones_per_level.append(current_stones)  # Store the stones in the next level\\n\\n    return stones_per_level\\n",
    "HumanEval/101": "def words_string(s):\\n    # Step 1: Split the input string by commas and spaces\\n    words = [word.strip() for word in s.replace(\\\",\\\", \\\" \\\").split() if word.strip()]  # Split by commas and spaces, then remove leading and trailing spaces and empty strings\\n\\n    return words\\n",
    "HumanEval/102": "def choose_num(x, y):\\n    \\\"\\\"\\\"This function takes two positive numbers x and y and returns the\\n    biggest even integer number that is in the range [x, y] inclusive. If \\n    there's no such number, then the function should return -1.\\n    \\\"\\\"\\\"\\n    max_even = -1\\n    \\n    for num in range(y, x - 1, -1):\\n        if num % 2 == 0:\\n            return num\\n    \\n    return max_even\\n",
    "HumanEval/103": "def rounded_avg(n, m):\\n    if n > m:\\n        return -1\\n    \\n    total_sum = sum(range(n, m + 1))\\n    count = m - n + 1\\n    average = total_sum / count\\n    rounded_avg = round(average)\\n    binary_avg = bin(rounded_avg)\\n    \\n    return binary_avg\\n",
    "HumanEval/104": "def unique_digits(x):\\n    unique_list = []\\n    sorted_list = sorted(x)\\n    \\n    for num in sorted_list:\\n        all_odd = all(int(digit) % 2 != 0 for digit in str(num))\\n        if all_odd:\\n            unique_list.append(num)\\n    \\n    unique_list.sort()\\n    \\n    return unique_list\\n",
    "HumanEval/105": "def by_length(arr):\\n    names = [\\\"One\\\", \\\"Two\\\", \\\"Three\\\", \\\"Four\\\", \\\"Five\\\", \\\"Six\\\", \\\"Seven\\\", \\\"Eight\\\", \\\"Nine\\\"]\\n    \\n    # Filter and sort the array\\n    filtered_arr = sorted([num for num in arr if 1 <= num <= 9])\\n    \\n    # Reverse sorted array and replace with names\\n    result = [names[num-1] for num in filtered_arr[::-1]]\\n    \\n    return result\\n",
    "HumanEval/106": "import math\\n\\ndef f(n):\\n    result = []  # Step 0: Create an empty list to store the output\\n    \\n    for i in range(1, n+1):  # Step 1: Run a loop from 1 to n (inclusive)\\n        if i % 2 == 0:  # Step 2: Check if the current index is even\\n            result.append(math.factorial(i))  # Step 3: Calculate the factorial of i and append it to the list\\n        else:\\n            result.append(sum(range(1, i+1)) )  # Step 5: Calculate the sum from 1 to i and append it to the list\\n    \\n    return result\\n",
    "HumanEval/107": "def even_odd_palindrome(n: int) -> tuple:\\n    def is_palindrome(num: int) -> bool:\\n        return str(num) == str(num)[::-1]\\n    \\n    even_count: int = 0\\n    odd_count: int = 0\\n\\n    for i in range(1, n+1):\\n        if is_palindrome(i):\\n            if i % 2 == 0:\\n                even_count += 1\\n            else:\\n                odd_count += 1\\n                \\n    return (even_count, odd_count)\\n",
    "HumanEval/108": "def count_nums(arr):\\n    def get_sum_of_digits(num):\\n        return sum(int(digit) for digit in str(abs(num)))\\n\\n    count = 0\\n    for num in arr:\\n        if get_sum_of_digits(num) > 0:\\n            count += 1\\n\\n    return count\\n",
    "HumanEval/109": "def move_one_ball(arr):\\n    if not arr:\\n        return True\\n\\n    min_val = min(arr)\\n    min_idx = arr.index(min_val)\\n    \\n    if min_idx == 0:\\n        return True\\n    \\n    shifts_required = len(arr) - min_idx\\n\\n    sorted_arr = arr[-shifts_required:] + arr[:-shifts_required]\\n\\n    if sorted_arr == sorted(arr):\\n        return True\\n    \\n    return False\\n",
    "HumanEval/110": "def exchange(lst1, lst2):\\n    if not lst1 or not lst2:\\n        return \\\"NO\\\"\\n    \\n    for num in lst1:\\n        if num % 2 != 0:\\n            for num2 in lst2:\\n                if num2 % 2 == 0:\\n                    lst1[lst1.index(num)], lst2[lst2.index(num2)] = num2, num\\n                    break\\n    \\n    if all(num % 2 == 0 for num in lst1):\\n        return \\\"YES\\\"\\n    else:\\n        return \\\"NO\\\"\\n",
    "HumanEval/111": "def histogram(test):\\n    test = test.replace(\\\" \\\", \\\"\\\").lower()\\n    letter_counts = {}\\n    \\n    for letter in test:\\n        if letter in letter_counts:\\n            letter_counts[letter] += 1\\n        else:\\n            letter_counts[letter] = 1\\n            \\n    max_count = max(letter_counts.values()) if letter_counts else 0\\n    max_letters = {letter: count for letter, count in letter_counts.items() if count == max_count}\\n    \\n    return max_letters\\n",
    "HumanEval/112": "def reverse_delete(s, c):\\n    def remove_characters(s, c):\\n        return \\\"\\\".join(char for char in s if char not in c)\\n\\n    def is_palindrome(s):\\n        return s == s[::-1]\\n\\n    modified_s = remove_characters(s, c)\\n    is_palindrome_result = is_palindrome(modified_s)\\n\\n    return modified_s, is_palindrome_result\\n",
    "HumanEval/113": "def odd_count(lst):\\n    if not lst or not all(isinstance(x, str) and x.isdigit() for x in lst):\\n        return []\\n    else:\\n        result = []\\n        for i in lst:\\n            odd_count = sum(int(digit) % 2 != 0 for digit in i)\\n            result.append(\\\"the number of odd elements in the string {} of the input.\\\".format(odd_count))\\n        return result\\n",
    "HumanEval/114": "        min_sum = min(min_sum, current_sum)\\n    return min_sum\\n",
    "HumanEval/115": "def max_fill(grid, capacity):\\n    import math\\n    \\n    total_buckets = 0\\n    \\n    for well in grid:\\n        total_water = sum(well)\\n        well_buckets = math.ceil(total_water / capacity)\\n        total_buckets += well_buckets\\n    \\n    return total_buckets\\n",
    "HumanEval/116": "def sort_array(arr):\\n    def count_ones(num):\\n        return bin(num).count('1')\\n    \\n    arr.sort(key=lambda x: (count_ones(x), x))\\n    return arr\\n",
    "HumanEval/117": "def select_words(s, n):\\n    def count_consonants(word):\\n        consonants = \\\"bcdfghjklmnpqrstvwxyz\\\"\\n        return sum(1 for char in word if char.lower() in consonants)\\n\\n    words = s.split()\\n    consonant_words = [word for word in words if count_consonants(word) == n]\\n    return consonant_words\\n",
    "HumanEval/118": "def get_closest_vowel(word):\\n    if len(word) < 3:\\n        return \\\"\\\"\\n    \\n    vowels = set('aeiouAEIOU')\\n\\n    for i in range(len(word)-2, 0, -1):\\n        if word[i] not in vowels and word[i-1] in vowels and word[i+1] in vowels:\\n            return word[i]\\n    \\n    return \\\"\\\"\\n",
    "HumanEval/119": "def match_parens(lst):\\n    str1, str2 = lst\\n    balance = 0\\n\\n    for char in str1 + str2:\\n        if char == '(':\\n            balance += 1\\n        elif char == ')':\\n            balance -= 1\\n        if balance < 0:\\n            return 'No'  # Unbalanced parentheses detected\\n        \\n    return 'Yes' if balance == 0 else 'No'\\n",
    "HumanEval/120": "def maximum(arr, k):\\n    arr.sort(reverse=True)\\n    return arr[:k]\\n",
    "HumanEval/121": "def solution(lst):\\n    sum_of_odd_at_even_positions = 0\\n    \\n    if not lst:\\n        return 0\\n    \\n    for index, num in enumerate(lst):\\n        if index % 2 == 0 and num % 2 != 0:\\n            sum_of_odd_at_even_positions += num\\n    \\n    return sum_of_odd_at_even_positions\\n",
    "HumanEval/122": "def add_elements(arr, k):\\n    if len(arr) < 1 or k < 1 or k > len(arr):\\n        return \\\"Invalid input\\\"\\n\\n    sum_elements = 0\\n\\n    for i in range(k):\\n        if arr[i] >= 10 and arr[i] <= 99:\\n            sum_elements += arr[i]\\n\\n    return sum_elements\\n",
    "HumanEval/123": "def get_odd_collatz(n):\\n    odd_numbers = []\\n\\n    while n != 1:\\n        if n % 2 == 0:\\n            n = n // 2\\n        else:\\n            odd_numbers.append(n)\\n            n = 3*n + 1\\n\\n    if n % 2 != 0:  # Check if the last number is odd\\n        odd_numbers.append(n)\\n\\n    return sorted(odd_numbers)\\n",
    "HumanEval/124": "def valid_date(date):\\n    if date == '':\\n        return False\\n    else:\\n        date_parts = date.split('-')\\n        if len(date_parts) != 3:\\n            return False\\n        else:\\n            month = int(date_parts[0])\\n            day = int(date_parts[1])\\n            year = int(date_parts[2])\\n\\n            if month < 1 or month > 12:\\n                return False\\n            else:\\n                if month in [1, 3, 5, 7, 8, 10, 12]:\\n                    if day < 1 or day > 31:\\n                        return False\\n                elif month in [4, 6, 9, 11]:\\n                    if day < 1 or day > 30:\\n                        return False\\n                elif month == 2:\\n                    if day < 1 or day > 29:\\n                        return False\\n\\n            return True\\n",
    "HumanEval/125": "def split_words(txt):\\n    is_whitespace_present = ' ' in txt\\n    \\n    if is_whitespace_present:\\n        return txt.split()\\n    else:\\n        is_comma_present = ',' in txt\\n        \\n        if is_comma_present:\\n            return txt.split(',')\\n        else:\\n            count_odd_lowercase = sum(1 for char in txt if 'a' <= char <= 'z' and ord(char) % 2 != 0)\\n            return count_odd_lowercase\\n",
    "HumanEval/126": "def is_sorted(lst):\\n    for num in lst:\\n        if lst.count(num) > 1:\\n            return False\\n    return lst == sorted(lst)\\n",
    "HumanEval/127": "def is_prime(num):\\n    if num < 2:\\n        return False\\n    \\n    for i in range(2, int(num ** 0.5) + 1):\\n        if num % i == 0:\\n            return False\\n    \\n    return True\\n\\ndef intersection(interval1, interval2):\\n    start = max(interval1[0], interval2[0])\\n    end = min(interval1[1], interval2[1])\\n\\n    if start > end:\\n        return \\\"NO\\\"\\n    \\n    length = end - start + 1\\n\\n    if is_prime(length):\\n        return \\\"YES\\\"\\n    else:\\n        return \\\"NO\\\"\\n",
    "HumanEval/128": "def prod_signs(arr):\\n    if not arr:  # Step 0: Check if the input array is empty\\n        return None\\n    \\n    result = 0  # Step 1: Initialize a variable `result` to 0\\n    sum_magnitude = 0  # Step 4: Initialize a variable `sum_magnitude` to 0\\n    \\n    for num in arr:\\n        # Step 2: Calculate the product of signs and sum of magnitudes concurrently\\n        if num > 0:\\n            result += num\\n            sum_magnitude += abs(num)\\n        elif num < 0:\\n            result -= num\\n            sum_magnitude += abs(num)\\n    \\n    return result  # Step 3: Return the `result`\\n",
    "HumanEval/129": "def minPath(grid, k):\\n    \\\"\\\"\\\"\\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \\n    each cell of the grid contains a value. Every integer in the range [1, N * N]\\n    inclusive appears exactly once on the cells of the grid.\\n\\n    You have to find the minimum path of length k in the grid. You can start\\n    from any cell, and in each step you can move to any of the neighbor cells,\\n    in other words, you can go to cells which share an edge with your current\\n    cell.\\n    Please note that a path of length k means visiting exactly k cells (not\\n    necessarily distinct).\\n    You CANNOT go off the grid.\\n    A path A (of length k) is considered less than a path B (of length k) if\\n    after making the ordered lists of the values on the cells that A and B go\\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\\n    than lst_B, in other words, there exists an integer index i (1 <= i <= k)\\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\\n    lst_A[j] = lst_B[j].\\n    It is guaranteed that the answer is unique.\\n    Return an ordered list of the values on the cells that the minimum path goes through.\\n    \\\"\\\"\\\"\\n    \\n    n_rows = len(grid)\\n    n_cols = len(grid[0])\\n    \\n    def get_neighbors(grid, row, col):\\n        neighbors = []\\n        if row > 0:\\n            neighbors.append((row - 1, col))  # Top neighbor\\n        if row < n_rows - 1:\\n            neighbors.append((row + 1, col))  # Bottom neighbor\\n        if col > 0:\\n            neighbors.append((row, col - 1))  # Left neighbor\\n        if col < n_cols - 1:\\n            neighbors.append((row, col + 1))  # Right neighbor\\n        return neighbors\\n    \\n    def find_min_path(grid, row, col, k, path):\\n        if k == 0:\\n            return path\\n\\n        neighbors = get_neighbors(grid, row, col)\\n        next_cell = None\\n        for neighbor in neighbors:\\n            next_row, next_col = neighbor\\n            if grid[next_row][next_col] not in path:\\n                next_cell = neighbor\\n                break\\n\\n        if next_cell:\\n            return find_min_path(grid, next_cell[0], next_cell[1], k - 1, path + [grid[next_cell[0]][next_cell[1]])\\n        else:\\n            return []\\n    \\n    min_path = []\\n    for i in range(n_rows):\\n        for j in range(n_cols):\\n            path = find_min_path(grid, i, j, k - 1, [grid[i][j]])\\n            if path and (not min_path or path < min_path):\\n                min_path = path\\n\\n    return min_path\\n",
    "HumanEval/130": "def tri(n):\\n    \\\"\\\"\\\"Generate the first n+1 numbers of the Tribonacci sequence.\\\"\\\"\\\"\\n    if n < 0:\\n        return []\\n    \\n    tribonacci = [1, 3]\\n    \\n    if n < 2:\\n        return tribonacci\\n    \\n    for i in range(2, n + 1):\\n        if i % 2 == 0:  # If i is even\\n            tribonacci.append(1 + i // 2)\\n        else:  # If i is odd\\n            tribonacci.append(tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3])\\n    \\n    return tribonacci\\n",
    "HumanEval/131": "def digits(n):\\n    n_str = str(n)\\n    product = 1\\n    for digit in n_str:\\n        if int(digit) % 2 != 0:\\n            product *= int(digit)\\n    if product == 1:\\n        return 0\\n    return product\\n",
    "HumanEval/132": "def is_nested(s):\\n    stack = []\\n    \\n    for bracket in s:\\n        if bracket == '[':\\n            stack.append(bracket)\\n        elif bracket == ']':\\n            if not stack:\\n                return False\\n            stack.pop()\\n    \\n    if stack:\\n        return True\\n    else:\\n        return False\\n",
    "HumanEval/133": "import math\\n\\ndef sum_squares(lst):\\n    total = 0\\n    \\n    for num in lst:\\n        rounded_num = math.ceil(num)\\n        total += rounded_num ** 2\\n    \\n    return total\\n",
    "HumanEval/134": "def check_if_last_char_is_a_letter(txt):\\n    '''\\n    Create a function that returns True if the last character\\n    of a given string is an alphabetical character and is not\\n    a part of a word, and False otherwise.\\n    Note: \\\"word\\\" is a group of characters separated by space.\\n    '''\\n    if not txt:\\n        return False\\n    \\n    last_char = txt[-1]\\n    \\n    if last_char.isalpha() and (len(txt) == 1 or txt[-2] == ' '):\\n        return True\\n    else:\\n        return False\\n",
    "HumanEval/135": "def can_arrange(arr):\\n    if len(arr) < 2:\\n        return -1\\n",
    "HumanEval/136": "def largest_smallest_integers(lst):\\n    largest_negative = None\\n    smallest_positive = None\\n    \\n    for num in lst:\\n        if num < 0 and (largest_negative is None or num > largest_negative):\\n            largest_negative = num\\n        elif num > 0 and (smallest_positive is None or num < smallest_positive):\\n            smallest_positive = num\\n    \\n    return (largest_negative, smallest_positive)\\n",
    "HumanEval/137": "def compare_one(a, b):\\n    if a == b:\\n        return None\\n\\n    if isinstance(a, (int, float)) and isinstance(b, (int, float)):\\n        return max(a, b)\\n    \\n    if isinstance(a, str):\\n        a = float(a.replace(',', '.'))\\n\\n    if isinstance(b, str):\\n        b = float(b.replace(',', '.'))\\n\\n    if isinstance(a, float) and isinstance(b, float):\\n        return max(a, b)\\n\\n    return None\\n",
    "HumanEval/138": "def is_equal_to_sum_even(n):\\n    if n < 8:\\n        return False\\n    \\n    # Generate all combinations of 4 even numbers that sum up to `n`\\n    for i in range(2, n // 2 + 1, 2):\\n        for j in range(2, n // 2 + 1, 2):\\n            for k in range(2, n // 2 + 1, 2):\\n                for l in range(2, n // 2 + 1, 2):\\n                    if i + j + k + l == n:\\n                        return True\\n    return False\\n",
    "HumanEval/139": "def special_factorial(n):\\n    result = 1\\n    for i in range(n, 0, -1):\\n        factorial_i = 1\\n        for j in range(i, 0, -1):\\n            factorial_i *= j\\n        result *= factorial_i\\n    return result\\n",
    "HumanEval/140": "def fix_spaces(text):\\n    fixed_text = \\\"\\\"\\n    consecutive_spaces = 0\\n    \\n    for char in text:\\n        if char == \\\" \\\":\\n            consecutive_spaces += 1\\n            if consecutive_spaces > 2:\\n                fixed_text = fixed_text.rstrip(\\\"_\\\")  # Remove multiple consecutive underscores\\n                fixed_text += \\\"-\\\"\\n            else:\\n                fixed_text += \\\"_\\\"\\n        else:\\n            fixed_text += char\\n            consecutive_spaces = 0\\n    \\n    return fixed_text\\n",
    "HumanEval/141": "def file_name_check(file_name):\\n    # Check if the file name contains more than three digits\\n    if sum(c.isdigit() for c in file_name) > 3:\\n        return 'No'\\n    \\n    # Check if the file name contains exactly one dot\\n    if file_name.count('.') != 1:\\n        return 'No'\\n    \\n    # Check if the substring before the dot is not empty and starts with a letter from the Latin alphabet\\n    file_parts = file_name.split('.')\\n    if len(file_parts) != 2 or not file_parts[0] or not file_parts[0][0].isalpha():\\n        return 'No'\\n\\n    # Check if the substring after the dot is 'txt', 'exe', or 'dll'\\n    valid_extensions = ['txt', 'exe', 'dll']\\n    if file_parts[1] not in valid_extensions:\\n        return 'No'\\n    \\n    return 'Yes'\\n",
    "HumanEval/142": "def sum_squares(lst):\\n    result = 0\\n    \\n    for i, num in enumerate(lst):\\n        if i % 3 == 0:\\n            result += num ** 2\\n        elif i % 4 == 0 and i % 3 != 0:\\n            result += num ** 3\\n    return result\\n",
    "HumanEval/143": "def words_in_sentence(sentence):\\n    def is_prime(num):\\n        if num < 2:\\n            return False\\n        for i in range(2, int(num**0.5) + 1):\\n            if num % i == 0:\\n                return False\\n        return True\\n\\n    words = sentence.split()\\n    prime_words = [word for word in words if is_prime(len(word)]\\n\\n    result = \\\" \\\".join(prime_words)\\n    return result\\n",
    "HumanEval/144": "def simplify(x, n):\\n    x_num, x_denom = map(int, x.split('/'))\\n    n_num, n_denom = map(int, n.split('/'))\\n    product_num = x_num * n_num\\n    product_denom = x_denom * n_denom\\n    whole_number = product_num % product_denom == 0\\n    return whole_number\\n",
    "HumanEval/145": "def digit_sum(n):\\n    return sum(int(digit) for digit in str(abs(n)))\\n\\ndef order_by_points(nums):\\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))\\n",
    "HumanEval/146": "def specialFilter(nums):\\n    count = 0\\n    for num in nums:\\n        if num > 10:\\n            str_num = str(abs(num))\\n            if int(str_num[0]) % 2 != 0 and int(str_num[-1]) % 2 != 0:\\n                count += 1\\n    return count\\n",
    "HumanEval/147": "def get_max_triples(n):\\n    result = []\\n    count = 0\\n\\n    for i in range(1, n + 1):\\n        a_i = i * i - i + 1\\n        result.append(a_i)\\n\\n    for i in range(n):\\n        for j in range(i + 1, n):\\n            for k in range(j + 1, n):\\n                if (result[i] + result[j] + result[k]) % 3 == 0:\\n                    count += 1\\n\\n    return count\\n",
    "HumanEval/148": "planet_order = {\\n    \\\"Mercury\\\": 1,\\n    \\\"Venus\\\": 2,\\n    \\\"Earth\\\": 3,\\n    \\\"Mars\\\": 4,\\n    \\\"Jupiter\\\": 5,\\n    \\\"Saturn\\\": 6,\\n    \\\"Uranus\\\": 7,\\n    \\\"Neptune\\\": 8\\n}\\n\\ndef bf(planet1, planet2):\\n    if planet1 not in planet_order or planet2 not in planet_order:\\n        return ()\\n\\n    order_planet1 = planet_order[planet1]\\n    order_planet2 = planet_order[planet2]\\n\\n    planets_between = [planet for planet, order in planet_order.items()\\n                       if order_planet1 <= order <= order_planet2]\\n\\n    if not planets_between:\\n        return ()\\n\\n    sorted_planets = sorted(planets_between, key=lambda x: planet_order[x])\\n\\n    return tuple(sorted_planets)\\n",
    "HumanEval/149": "def sorted_list_sum(lst):\\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\\n    return sorted_list\\n",
    "HumanEval/150": "def x_or_y(n, x, y):\\n    if is_prime(n):\\n        return x\\n    else:\\n        return y\\n",
    "HumanEval/151": "def double_the_difference(lst):\\n    total = 0\\n    for num in lst:\\n        if isinstance(num, int) and num >= 0 and num % 2 != 0:\\n            total += num ** 2\\n    return total * 2\\n",
    "HumanEval/152": "def compare(game, guess):\\n    result = []\\n    for g, c in zip(game, guess):\\n        if g == c:\\n            result.append(0)\\n        else:\\n            result.append(abs(g - c))\\n    return result\\n",
    "HumanEval/153": "def Strongest_Extension(class_name, extensions):\\n    max_strength = float('-inf')\\n    strongest_extension = ''\\n    \\n    for extension in extensions:\\n        cap_count = sum(1 for c in extension if c.isupper())\\n        sm_count = sum(1 for c in extension if c.islower())\\n        \\n        strength = cap_count - sm_count\\n        \\n        if strength > max_strength:\\n            max_strength = strength\\n            strongest_extension = extension\\n        elif strength == max_strength:\\n            if extensions.index(extension) < extensions.index(strongest_extension):\\n                strongest_extension = extension\\n            \\n    result = f\\\"{class_name}.{strongest_extension}\\\"\\n    return result\\n",
    "HumanEval/154": "def cycpattern_check(a, b):\\n    if not b:  # If the second word is empty, return False\\n        return False\\n    \\n    for i in range(len(b)):  # Loop through each character in the second word\\n        rotated_word = b[i:] + b[:i]  # Rotate the word\\n        if rotated_word in a:  # Check if any rotation of the second word is a substring of the first word\\n            return True\\n    \\n    return False  # Return False if no rotations are found\\n",
    "HumanEval/155": "def even_odd_count(num):\\n    even_count = 0\\n    odd_count = 0\\n    \\n    for digit in str(abs(num)):\\n        if digit.isdigit() and digit != '-':\\n            digit = int(digit)\\n            if digit % 2 == 0:\\n                even_count += 1\\n            else:\\n                odd_count += 1\\n    \\n    return (even_count, odd_count)\\n",
    "HumanEval/156": "def int_to_mini_roman(number):\\n    roman_dict = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd', 100: 'c', 90: 'xc',\\n                  50: 'l', 40: 'xl', 10: 'x', 9: 'ix', 5: 'v', 4: 'iv', 1: 'i'}\\n    \\n    roman_numeral = \\\"\\\"\\n    \\n    for key in sorted(roman_dict, reverse=True):\\n        while number >= key:\\n            roman_numeral += roman_dict[key]\\n            number -= key\\n    \\n    return roman_numeral.lower()\\n",
    "HumanEval/157": "def is_triangle(a, b, c):\\n    return a + b > c and a + c > b and b + c > a\\n\\ndef right_angle_triangle(a, b, c):\\n    if not is_triangle(a, b, c):\\n        return False\\n    \\n    longest_side = max(a, b, c)\\n    \\n    if longest_side**2 == a**2 + b**2 + c**2 - longest_side**2:\\n        return True\\n    else:\\n        return False\\n",
    "HumanEval/158": "def find_max(words):\\n    unique_char_count = {}\\n    \\n    # Step 1: Iterate through each word and count the number of unique characters in each word\\n    for word in words:\\n        unique_chars = set(word)\\n        unique_char_count[word] = (len(unique_chars), word)\\n    \\n    # Step 2: Find the word with the maximum number of unique characters\\n    max_unique_chars = max(unique_char_count.values(), key=lambda x: (x[0], x[1]))\\n    \\n    return max_unique_chars[1]\\n",
    "HumanEval/159": "def eat(number, need, remaining):\\n    if need <= remaining:\\n        total_carrots_eaten = number + need\\n        carrots_left = remaining - need\\n    else:\\n        total_carrots_eaten = number + remaining\\n        carrots_left = 0\\n    \\n    return [total_carrots_eaten, carrots_left]\\n",
    "HumanEval/160": "# Define the function do_algebra(operator, operand)\\ndef do_algebra(operator, operand):\\n    # Check the length constraints for operator and operand lists\\n    if len(operator) != len(operand) - 1:\\n        raise ValueError(\\\"Length of operator list should be one less than the length of operand list\\\")\\n\\n    if len(operator) < 1 or len(operand) < 2:\\n        raise ValueError(\\\"Operator list should have at least one operator and operand list should have at least two operands.\\\")\\n\\n    # Step 1: Initialize the result with the first operand\\n    result = operand[0]\\n\\n    # Step 2: Loop through the operators and operands together\\n    for op, num in zip(operator, operand[1:]):\\n        # Step 3: Update the result based on the operator\\n        if op == '+':\\n            result += num\\n        elif op == '-':\\n            result -= num\\n        elif op == '*':\\n            result *= num\\n        elif op == '//':\\n            result //= num\\n        elif op == '**':\\n            result **= num\\n\\n    return result\\n\\n# Test the function with an example\\noperator = ['+', '*', '-']\\noperand = [2, 3, 4, 5]\\nresult = do_algebra(operator, operand)\\nprint(result)  # Output should be 9\\n",
    "HumanEval/161": "def solve(s):\\n    result = \\\"\\\"\\n    contains_letter = any(char.isalpha() for char in s)\\n    \\n    if contains_letter:\\n        for char in s:\\n            if char.isalpha():\\n                result += char.swapcase()\\n            else:\\n                result += char\\n    else:\\n        result = s[::-1]\\n    \\n    return result\\n",
    "HumanEval/162": "import hashlib\\n\\ndef string_to_md5(text):\\n    if not text:\\n        return None\\n    else:\\n        md5_hash = hashlib.md5(text.encode()).hexdigest()\\n        return md5_hash\\n",
    "HumanEval/163": "def generate_integers(a, b):\\n    even_digits = []\\n    \\n    if a > b:\\n        a, b = b, a  # Swap a and b if a is greater than b\\n        \\n    for num in range(a, b+1):\\n        if int(str(num)[-1]) % 2 == 0:\\n            even_digits.append(num)\\n    \\n    return even_digits\\n"
}
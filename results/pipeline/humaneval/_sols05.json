{
    "HumanEval/0": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n",
    "HumanEval/1": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(\" \", \"\")\n    separate_groups = []\n    current_group = \"\"\n\n    for char in paren_string:\n        if char == \"(\":\n            current_group += char\n        elif char == \")\":\n            current_group += char\n            separate_groups.append(current_group)\n            current_group = \"\"\n\n    return separate_groups\n",
    "HumanEval/2": "def truncate_number(number: float) -> float:\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part\n",
    "HumanEval/3": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False\n",
    "HumanEval/4": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    # Step 0: Calculate the mean of the input list\n    mean = sum(numbers) / len(numbers)\n    \n    # Step 1: Calculate the absolute deviation for each element\n    absolute_deviations = [abs(num - mean) for num in numbers]\n    \n    # Step 2: Calculate the mean of the absolute deviations\n    mean_absolute_deviation = sum(absolute_deviations) / len(absolute_deviations)\n    \n    return mean_absolute_deviation\n",
    "HumanEval/5": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:  # Check if num is not the last element\n            result.append(delimiter)\n    return result\n",
    "HumanEval/6": "from typing import List\n\n\ndef max_nesting_level(group: str) -> int:\n    max_depth = 0\n    depth = 0\n\n    for char in group:\n        if char == '(':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ')':\n            depth -= 1\n\n    return max_depth\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    groups = paren_string.split()\n    nesting_levels = [max_nesting_level(group) for group in groups]\n    return nesting_levels\n",
    "HumanEval/7": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    filtered_strings = []\n    for string in strings:\n        if substring in string:\n            filtered_strings.append(string)\n    return filtered_strings\n",
    "HumanEval/8": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return 0, 1\n    else:\n        num_sum = sum(numbers)\n        product = 1\n        for num in numbers:\n            product *= num\n        return num_sum, product\n",
    "HumanEval/9": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    rolling_max_list = []\n    current_max = float('-inf')\n    \n    for num in numbers:\n        current_max = max(current_max, num)\n        rolling_max_list.append(current_max)\n    \n    return rolling_max_list\n",
    "HumanEval/10": "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string. \"\"\"\n    \n    # Step 1: Find the longest palindromic suffix\n    def longest_palindromic_suffix(s):\n        for i in range(len(s), 0, -1):\n            if is_palindrome(s[-i:]):\n                return s[-i:]\n        return ''\n    \n    palindromic_suffix = longest_palindromic_suffix(string)\n    \n    # Step 2: Append the reverse of the prefix before the palindromic suffix\n    return string + string[:len(string) - len(palindromic_suffix)][::-1]\n",
    "HumanEval/11": "def string_xor(a: str, b: str) -> str:\n    # Input Validation\n    if not all(char in '01' for char in a) or not all(char in '01' for char in b):\n        raise ValueError(\"Inputs should consist only of 1s and 0s.\")\n\n    # Pad the shorter string with zeros\n    max_len = max(len(a), len(b))\n    a = a.zfill(max_len)\n    b = b.zfill(max_len)\n\n    # Perform XOR operation\n    result = ''.join(str(int(char_a) ^ int(char_b)) for char_a, char_b in zip(a, b))\n    return result\n",
    "HumanEval/12": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    \n    longest_string = strings[0]\n    \n    for string in strings[1:]:\n        if len(string) > len(longest_string):\n            longest_string = string\n    \n    return longest_string\n",
    "HumanEval/13": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    if b == 0:\n        return a\n",
    "HumanEval/14": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    prefixes = []\n    \n    for i in range(1, len(string)+1):\n        prefix = string[:i]\n        prefixes.append(prefix)\n    \n    return prefixes\n",
    "HumanEval/15": "def string_sequence(n: int) -> str:\n    numbers = []\n    \n    for i in range(n + 1):\n        numbers.append(str(i))\n    \n    return ' '.join(numbers)\n",
    "HumanEval/16": "def count_distinct_characters(string: str) -> int:\n    unique_chars = set()\n    \n    string = string.lower()\n    \n    for char in string:\n        if char.isalpha():\n            unique_chars.add(char)\n    \n    return len(unique_chars)\n",
    "HumanEval/17": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    notes = music_string.split()\n    \n    beat_values = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n\n    beats = [beat_values[note] for note in notes]\n\n    return beats\n",
    "HumanEval/18": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlapping cases.\n    \"\"\"\n    count = 0\n    \n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i + len(substring)] == substring:\n            count += 1\n    \n    return count\n",
    "HumanEval/19": "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    numbers_dict = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,\n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9\n    }\n    \n    numbers_list = numbers.split()\n    sorted_numbers = sorted([numbers_dict[num] for num in numbers_list])\n    sorted_number_strings = [key for key, value in numbers_dict.items() if value in sorted_numbers]\n    \n    return ' '.join(sorted_number_strings)\n",
    "HumanEval/20": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    \n    min_diff = float('inf')  # Initialize the smallest difference variable\n    closest_pair = ()  # Initialize the pair of closest elements\n    \n    for i in range(len(numbers) - 1):\n        num1, num2 = numbers[i], numbers[i + 1]\n        diff = abs(num1 - num2)\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (num1, num2)\n    \n    return closest_pair\n",
    "HumanEval/21": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    \n    rescaled = [(num - min_val) / range_val for num in numbers]\n\n    return rescaled\n",
    "HumanEval/22": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"Filter given list of any python values only for integers\"\"\"\n    \n    filtered_integers = []\n    \n    for value in values:\n        if isinstance(value, int):\n            filtered_integers.append(value)\n    \n    return filtered_integers\n",
    "HumanEval/23": "def strlen(string: str) -> int:\n    \"\"\"\n    Return length of given string\n    \n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return len(string)\n",
    "HumanEval/24": "def largest_divisor(n: int) -> int:\n    largest = 0\n    \n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            largest = i\n            break\n    \n    return largest\n",
    "HumanEval/25": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    factors = []  # Step 0\n    \n    p = 2  # Step 1\n\n    while p <= n**0.5:  # Step 2\n        if n % p == 0:  # Step 3\n            factors.append(p)  # Step 3\n            n //= p  # Step 3\n        else:\n            p += 1  # Step 3\n            \n    if n > 1:  # Step 4\n        factors.append(n)  # Step 4\n\n    return factors  # Step 4\n",
    "HumanEval/26": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    unique_numbers = []\n    \n    for num in numbers:\n        if num not in unique_numbers:\n            unique_numbers.append(num)\n        \n    return unique_numbers\n",
    "HumanEval/27": "def flip_case(string: str) -> str:\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char.lower()\n        elif char.islower():\n            result += char.upper()\n        else:\n            result += char\n    return result\n",
    "HumanEval/28": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    result = \"\"\n    for s in strings:\n        result += s\n    return result\n",
    "HumanEval/29": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    result = []\n    \n    for string in strings:\n        if string.startswith(prefix):\n            result.append(string)\n    \n    return result\n",
    "HumanEval/30": "def get_positive(l: list):\n    pos_numbers = []\n    \n    for num in l:\n        if num > 0:\n            pos_numbers.append(num)\n    \n    return pos_numbers\n",
    "HumanEval/31": "def is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\"\"\"\n    \n    if n < 2:\n        return False\n        \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True\n",
    "HumanEval/32": "import math\n\ndef find_zero(xs: list):\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The number of coefficients must be even.\")\n    if xs[-1] == 0:\n        raise ValueError(\"The largest non-zero coefficient must not be zero.\")\n    \n    def poly(x):\n        return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n    x0 = 0  # Initial guess for the zero\n    tolerance = 1e-8  # Tolerance for convergence\n    max_iterations = 100  # Maximum number of iterations\n    i = 0\n    while i < max_iterations:\n        fx0 = poly(x0)\n        if abs(fx0) < tolerance:\n            return x0\n        dfx0 = sum([i * coeff * math.pow(x0, i - 1) for i, coeff in enumerate(xs) if i > 0])\n        x0 = x0 - fx0 / dfx0\n        i += 1\n\n    raise ValueError(\"Could not find a zero within the maximum number of iterations.\")\n",
    "HumanEval/33": "def sort_third(l: list):\n    result = []\n    \n    for index, value in enumerate(l):\n        if index % 3 == 0:\n            sorted_value = sorted(l[index])\n            result.append(sorted_value)\n        else:\n            result.append(value)\n            \n    return result\n",
    "HumanEval/34": "def unique(l: list):\n    unique_elements = set(l)\n    unique_elements_sorted = sorted(unique_elements)\n    return unique_elements_sorted\n",
    "HumanEval/35": "def max_element(l: list):\n    max_val = l[0]\n    \n    for val in l[1:]:\n        if val > max_val:\n            max_val = val\n    \n    return max_val\n",
    "HumanEval/36": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count\n",
    "HumanEval/37": "def sort_even(l: list):\n    l_copy = l.copy()\n\n    even_indices = [l_copy[i] for i in range(0, len(l_copy), 2)]\n    even_indices.sort()\n\n    for i in range(0, len(l_copy), 2):\n        l_copy[i] = even_indices[i // 2]\n\n    return l_copy\n",
    "HumanEval/38": "def decode_cyclic(s: str):\n    \"\"\"\n    Takes as input a string encoded with encode_cyclic function. Returns the decoded string.\n    \"\"\"\n    groups = [s[i:i+3] for i in range(0, len(s), 3)]\n    decoded_groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    decoded_string = \"\".join(decoded_groups)\n    return decoded_string\n",
    "HumanEval/39": "import math\n\ndef is_prime(n):\n    \"\"\"\n    Check if a number is prime.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n",
    "HumanEval/40": "def triples_sum_to_zero(l: list):\n    from itertools import combinations\n    \n    for triple in combinations(l, 3):\n        if len(set(triple)) == 3 and sum(triple) == 0:\n            return True\n    \n    return False\n",
    "HumanEval/41": "def car_race_collision(n: int):\n    collision_count = 0\n\n    for i in range(1, n + 1):\n        collision_count += i\n        \n    return collision_count\n",
    "HumanEval/42": "def incr_list(l: list):\n    result = []\n    \n    for num in l:\n        result.append(num + 1)\n        \n    return result\n",
    "HumanEval/43": "def pairs_sum_to_zero(l):\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False\n",
    "HumanEval/44": "def change_base(x: int, base: int):\n    if base >= 10:\n        raise ValueError(\"Base should be less than 10\")\n\n    result = \"\"\n    while x > 0:\n        remainder = x % base\n        result += str(remainder)\n        x = x // base\n\n    return result[::-1]\n",
    "HumanEval/45": "def triangle_area(a, h):\n    return 0.5 * a * h\n",
    "HumanEval/46": "def fib4(n: int):\n    # Step 1: Initialize the list to store the first 4 elements of the Fib4 sequence\n    fib4_list = [0, 0, 2, 0]\n\n    # Step 2: Loop to compute the next elements of the Fib4 sequence\n    for i in range(4, n + 1):\n        fib4_next = fib4_list[i-1] + fib4_list[i-2] + fib4_list[i-3] + fib4_list[i-4]\n        fib4_list.append(fib4_next)\n\n    # Step 3: Return the n-th element of the Fib4 sequence\n    return fib4_list[n]\n\n# Test cases\nprint(fib4(5))  # Output: 4\nprint(fib4(6))  # Output: 8\nprint(fib4(7))  # Output: 14\n",
    "HumanEval/47": "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    l.sort()\n        \n    n = len(l)\n    is_even = (n % 2 == 0)\n    \n    if is_even:\n        mid1 = l[n // 2]\n        mid2 = l[n // 2 - 1]\n        return (mid1 + mid2) / 2\n    else:\n        return l[n // 2]\n",
    "HumanEval/48": "def is_palindrome(text: str):\n    if not text:\n        return True\n    return text == text[::-1]\n",
    "HumanEval/49": "def modp(n: int, p: int):\n    result = 2**n\n    return result % p\n",
    "HumanEval/50": "def decode_shift(s: str):\n    \"\"\"\n    Decodes a string encoded by shifting every character by 5 in the alphabet.\n    \"\"\"\n    decoded_str = \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n    return decoded_str\n",
    "HumanEval/51": "def remove_vowels(text):\n    result = ''\n    vowels = 'aeiouAEIOU'\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result\n",
    "HumanEval/52": "def below_threshold(l: list, t: int):\n    for num in l:\n        if num >= t:\n            return False\n    return True\n",
    "HumanEval/53": "def add(x: int, y: int):\n    return x + y\n",
    "HumanEval/54": "def same_chars(s0: str, s1: str):\n    char_count_s0 = {}\n    char_count_s1 = {}\n    \n    for char in s0:\n        char_count_s0[char] = char_count_s0.get(char, 0) + 1\n    \n    for char in s1:\n        char_count_s1[char] = char_count_s1.get(char, 0) + 1\n        \n    return char_count_s0 == char_count_s1\n",
    "HumanEval/55": "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    a, b = 0, 1\n\n    for _ in range(n - 1):\n        a, b = b, a + b\n\n    return b\n",
    "HumanEval/56": "def correct_bracketing(brackets: str):\n    count = 0\n    \n    for bracket in brackets:\n        if bracket == '<':\n            count += 1\n        elif bracket == '>':\n            count -= 1\n            if count < 0:\n                return False\n    \n    return count == 0\n",
    "HumanEval/57": "def monotonic(lst: list):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\"\"\"\n    return all(lst[i] <= lst[i + 1] for i in range(len(lst) - 1)) or all(lst[i] >= lst[i + 1] for i in range(len(lst) - 1)\n",
    "HumanEval/58": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n\n    set1 = set(l1)\n    set2 = set(l2)\n\n    common_elements = sorted(list(set1.intersection(set2)))\n\n    return common_elements\n",
    "HumanEval/59": "def is_prime(number):\n    if number < 2:\n        return False\n    for i in range(2, int(number ** 0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef largest_prime_factor(n: int):\n    factor = 2\n\n    while factor < n:\n        if n % factor == 0:\n            if is_prime(factor):\n                n //= factor\n            else:\n                factor += 1\n        else:\n            factor += 1\n\n    return n\n",
    "HumanEval/60": "def sum_to_n(n: int):\n    total = 0\n    for i in range(1, n+1):\n        total += i\n    return total\n",
    "HumanEval/61": "def correct_bracketing(brackets: str):\n    stack = []\n    \n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                return False\n    \n    return len(stack) == 0\n",
    "HumanEval/62": "def derivative(xs: list):\n    derivative_xs = []\n    for i in range(1, len(xs)):\n        derivative_coefficient = xs[i] * i\n        derivative_xs.append(derivative_coefficient)\n    return derivative_xs\n",
    "HumanEval/63": "# Function for calculating the FibFib number sequence\ndef fibfib(n: int):\n    # Base cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n\n    # Recursive step\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n",
    "HumanEval/64": "def vowels_count(s):\n    count = 0\n    \n    for i, char in enumerate(s):\n        if char.lower() in ['a', 'e', 'i', 'o', 'u']:\n            \n            if char.lower() == 'y' and i == len(s) - 1:\n                count += 1\n            elif char.lower() != 'y':\n                count += 1\n    \n    return count\n",
    "HumanEval/65": "def circular_shift(x, shift):\n    x_str = str(x)\n    length_of_string = len(x_str)\n    \n    if shift == length_of_string:\n        return x_str[::-1]\n    \n    # Continue with the remaining steps...\n",
    "HumanEval/66": "def digitSum(s):\n    sum_ascii = 0\n\n    for char in s:\n        if char.isupper():\n            sum_ascii += ord(char)\n\n    return sum_ascii\n",
    "HumanEval/67": "def fruit_distribution(s, n):\n    # Step 0: Extract the number of apples and oranges from the input string\n    s = s.split()\n    apples = int(s[0])\n    oranges = int(s[3])\n\n    # Step 1: Calculate the number of mango fruits by subtracting total apples and oranges from total fruits\n    mangoes = n - apples - oranges\n    return mangoes\n",
    "HumanEval/68": "return [smallest_even_node, smallest_even_index]\n",
    "HumanEval/69": "def search(lst):\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    \n    result = -1\n    for num, freq in freq_dict.items():\n        if num > 0 and freq >= num:\n            result = max(result, num)\n    \n    return result\n",
    "HumanEval/70": "def strange_sort_list(lst):\n    sorted_lst = []\n    if not lst:\n        return sorted_lst\n    \n    length = len(lst)\n    \n    sorted_list = sorted(lst)\n    \n    for i in range(length // 2):\n        sorted_lst.append(sorted_list[i]) # Append minimum value\n        sorted_lst.append(sorted_list[length - 1 - i]) # Append maximum value\n        \n    if length % 2 == 1:\n        sorted_lst.append(sorted_list[length // 2])  # Append middle value\n\n    return sorted_lst\n",
    "HumanEval/71": "import math\n\ndef triangle_area(a, b, c):\n    if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1\n",
    "HumanEval/72": "def will_it_fly(q, w):\n    if q != q[::-1]:\n        return False\n\n    if sum(q) > w:\n        return False\n    \n    return True\n",
    "HumanEval/73": "def is_palindrome(arr):\n    return arr == arr[::-1]\n\ndef smallest_change(arr):\n    min_changes = float('inf) \n\n    if is_palindrome(arr):\n        return 0\n\n    for i in range(len(arr)):\n        changes = sum(1 for j in range(len(arr)//2) if arr[j] != arr[len(arr)-j-1])\n        min_changes = min(min_changes, changes)\n\n    return min_changes\n",
    "HumanEval/74": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum([len(s) for s in lst1])\n    total_chars_lst2 = sum([len(s) for s in lst2])\n    \n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1\n",
    "HumanEval/75": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a):\n    count = 0\n    for i in range(2, a):\n        if is_prime(i) and a % i == 0:\n            count += 1\n    return count == 3\n\n# Test cases\nprint(is_multiply_prime(30))  # Output should be True\nprint(is_multiply_prime(20))  # Output should be False\n",
    "HumanEval/76": "# Step 3\npower = n\n",
    "HumanEval/77": "def iscube(a):\n    return (a**(1/3)).is_integer() if a >= 0 else False\n",
    "HumanEval/78": "def hex_key(num):\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    \n    for digit in num:\n        if digit in prime_digits:\n            count += 1\n    \n    return count\n",
    "HumanEval/79": "def decimal_to_binary(decimal):\n    binary = bin(decimal)[2:]  # Convert decimal to binary and remove the prefix '0b'\n    binary_formatted = \"db\" + binary + \"db\"  # Add 'db' prefix and suffix to the binary representation\n    return binary_formatted\n",
    "HumanEval/80": "def is_happy(s):\n    if len(s) < 3:\n        return False\n    \n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    \n    return True\n",
    "HumanEval/81": "def numerical_letter_grade(grades):\n    letter_grades = []\n    \n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa >= 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    \n    return letter_grades\n",
    "HumanEval/82": "def prime_length(string):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    str_length = len(string)\n    \n    return is_prime(str_length)\n",
    "HumanEval/83": "def starts_one_ends(n):\n    count = 0\n    for i in range(10 ** (n - 1), 10 ** n):\n        number_str = str(i)\n        if number_str[0] == '1' or number_str[-1] == '1':\n            count += 1\n    return count\n",
    "HumanEval/84": "def solve(N):\n    total_sum = 0\n    N_str = str(N)\n\n    for digit in N_str:\n        total_sum += int(digit)\n\n    return bin(total_sum)[2:]\n",
    "HumanEval/85": "def add(lst):\n    sum_even = 0\n    \n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            sum_even += lst[index]\n    \n    return sum_even\n",
    "HumanEval/86": "def anti_shuffle(s):\n    words = s.split(' ')\n    \n    # Sort the characters in each word based on ASCII values\n    sorted_words = [''.join(sorted(word, key=lambda x: ord(x))) for word in words]\n    \n    # Join the modified words back together along with the blank spaces\n    ordered_string = ' '.join(sorted_words)\n    \n    return ordered_string\n",
    "HumanEval/87": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        if x in row:\n            j = row.index(x)\n            coordinates.append((i, j))\n    \n    return sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n",
    "HumanEval/88": "        return sorted(array, reverse=True)  # Sort in descending order\n",
    "HumanEval/89": "def encrypt(s):\n    result = \"\"\n    \n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            ascii_offset = 97 if char.islower() else 65\n            encrypted_char = chr((ord(char) + shift - ascii_offset) % 26 + ascii_offset)\n            result += encrypted_char\n        else:\n            result += char\n    \n    return result\n",
    "HumanEval/90": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    \n    lst = list(set(lst))\n    lst.sort()\n    \n    if len(lst) >= 2:\n        return lst[1]\n    else:\n        return None\n",
    "HumanEval/91": "import re\n\ndef is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n    \n    sentences = re.split(r'[.?!]', S)  # Split the input string into sentences\n    i_boredom_count = sum([1 for sentence in sentences if sentence.strip().startswith(\"I \")])\n    \n    return i_boredom_count\n",
    "HumanEval/92": "def any_int(x, y, z):\n    if not all(isinstance(num, int) for num in [x, y, z]):\n        return False\n    return x == y + z or y == x + z or z == x + y\n",
    "HumanEval/93": "def encode(message):\n    encoded_message = \"\"\n\n    for char in message:\n        if char.lower() in ['a', 'e', 'i', 'o', 'u']:\n            # Replace vowels with letters 2 places ahead in the alphabet\n            encoded_message += chr(ord(char) + 2)\n        elif char.isalpha():\n            # Swap the case of letters\n            encoded_message += char.swapcase()\n        else:\n            # Keep other characters as they are\n            encoded_message += char\n\n    return encoded_message\n",
    "HumanEval/94": "def find_largest_prime_sum(lst):\n    largest_prime = None\n    for num in lst:\n        if is_prime(num):\n            if largest_prime is None or num > largest_prime:\n                largest_prime = num\n\n    if largest_prime is None:\n        return 0  # Return 0 if no prime numbers were found\n\n    return sum_digits(largest_prime)\n",
    "HumanEval/95": "def check_dict_case(dictionary):\n    if not dictionary:\n        return False\n    if not all(isinstance(key, str) for key in dictionary.keys()):\n        return False\n\n    is_lower_case = all(key.islower() for key in dictionary.keys())\n    is_upper_case = all(key.isupper() for key in dictionary.keys())\n\n    if is_lower_case or is_upper_case:\n        return True\n\n    return False\n",
    "HumanEval/96": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_up_to(n):\n    primes = []\n    \n    if n < 2:\n        return primes\n    if n == 2:\n        return [2]\n    \n    for num in range(2, n):\n        if is_prime(num):\n            primes.append(num)\n\n    return primes\n",
    "HumanEval/97": "def multiply(a, b):\n    a_unit = abs(a) % 10\n    b_unit = abs(b) % 10\n    product = a_unit * b_unit\n    return product\n",
    "HumanEval/98": "def count_upper(s):\n    count = 0\n    for i in range(0, len(s), 2):\n        char = s[i]\n        if char.upper() in ['A', 'E', 'I', 'O', 'U']:\n            count += 1\n\n    return count\n",
    "HumanEval/99": "import math\n\ndef closest_integer(value):\n    float_value = float(value)\n    floor_value = math.floor(float_value)\n    ceiling_value = math.ceil(float_value)\n    \n    distance_floor = abs(float_value - floor_value)\n    distance_ceiling = abs(ceiling_value - float_value)\n    \n    if distance_floor <= distance_ceiling:\n        return floor_value\n    else:\n        return ceiling_value\n",
    "HumanEval/100": "def make_a_pile(n):\n    levels = [n]\n    current_stones = n\n    for i in range(1, n):\n        if current_stones % 2 == 0:\n            current_stones += i * 2\n        else:\n            current_stones += i * 2 + 1\n        levels.append(current_stones)\n    return levels\n",
    "HumanEval/101": "def words_string(s):\n    words = s.replace(\", \", \" \").split()\n    return words\n",
    "HumanEval/102": "def choose_num(x, y):\n    if x <= 0 or y <= 0:\n        return -1\n\n    # Step 1: Check if both x and y are positive and even numbers\n    if x % 2 != 0:\n        x += 1  # Make x even if it's not already\n    if y % 2 != 0:\n        y -= 1  # Make y even if it's not already\n\n    # Step 2: Find the biggest even number in the range [x, y]\n    for i in range(y, x - 1, -2):\n        if i % 2 == 0:\n            return i\n\n    return -1  # No even number in the range\n",
    "HumanEval/103": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    \n    sum_avg = sum(range(n, m + 1))\n    avg = round(sum_avg / (m - n + 1))\n    binary_avg = bin(avg)\n    \n    return binary_avg\n",
    "HumanEval/104": "def unique_digits(x):\n    result = []\n    \n    for num in x:\n        has_even_digit = any(int(digit) % 2 == 0 for digit in str(num))\n        if not has_even_digit:\n            result.append(num)\n    \n    result.sort()\n    \n    return result\n",
    "HumanEval/105": "def by_length(arr):\n    num_to_word = {1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    \n    valid_digits = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    filtered_arr = list(filter(lambda x: x in valid_digits, arr))\n    sorted_arr = sorted(filtered_arr)\n    reversed_arr = sorted_arr[::-1]\n    \n    result = [num_to_word[num] for num in reversed_arr]\n    \n    return result\n",
    "HumanEval/106": "def f(n):\n    result = []\n    \n    for i in range(1, n+1):\n        if i % 2 == 0:\n            factorial = 1\n            for j in range(1, i+1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            result.append(sum(range(1, i+1)))\n    \n    return result\n",
    "HumanEval/107": "def even_odd_palindrome(n):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for num in range(1, n+1):\n        if is_palindrome(num):\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)\n",
    "HumanEval/108": "def sum_of_digits(n):\n    return sum(int(d) for d in str(abs(n)))\n\ndef count_nums(arr):\n    count = 0\n    for num in arr:\n        if sum_of_digits(num) > 0:\n            count += 1\n    \n    return count\n",
    "HumanEval/109": "def move_one_ball(arr):\n    # Step 0: Check if the array is already sorted\n    if arr == sorted(arr):\n        return True\n    \n    # Step 1: Find the index of the minimum element in the array\n    min_index = arr.index(min(arr))\n    \n    # Step 2: Handle multiple occurrences of the minimum element\n    next_min_index = arr[min_index+1:].index(min(arr)) + min_index + 1 if min(arr) in arr[min_index+1:] else min_index\n    \n    # Step 3: Check if elements to the left of the minimum element are sorted\n    if arr[:min_index] == sorted(arr[:min_index]):\n        \n        # Step 4: Check if elements to the right of the minimum element are sorted\n        if arr[min_index+1:] == sorted(arr[min_index+1:]):\n            return True\n    \n    return False\n",
    "HumanEval/110": "def exchange(lst1, lst2):\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    \n    odd_in_lst1 = [num for num in lst1 if num % 2 != 0]\n    even_in_lst2 = [num for num in lst2 if num % 2 == 0]\n\n    if len(odd_in_lst1) > len(even_in_lst2):\n        return \"NO\"\n\n    return \"YES\"\n",
    "HumanEval/111": "def histogram(test):\n    letters = test.split()\n    letter_count = {}\n    for letter in letters:\n        if letter in letter_count:\n            letter_count[letter] += 1\n        else:\n            letter_count[letter] = 1\n    result = {letter: count for letter, count in letter_count.items() if count == max(letter_count.values())}\n    return result\n",
    "HumanEval/112": "def reverse_delete(s, c):\n    def delete_chars_from_string(s, chars_to_delete):\n        result = \"\"\n        for char in s:\n            if char not in chars_to_delete:\n                result += char\n        return result\n\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    result_string = delete_chars_from_string(s, c)\n    is_palindrome_result = is_palindrome(result_string)\n\n    return result_string, is_palindrome_result\n",
    "HumanEval/113": "def odd_count(lst):\n    result = []\n    \n    for string in lst:\n        odd_count = len([digit for digit in string if int(digit) % 2 != 0])\n        replaced_sentence = f\"the number of odd elements {odd_count} in the string {odd_count} of the input.\"\n        result.append(replaced_sentence)\n    \n    return result\n",
    "HumanEval/114": "def minSubArraySum(nums):\n    min_sum = float('inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n        current_sum = max(current_sum, 0)\n    \n    return min_sum\n",
    "HumanEval/115": "def max_fill(grid, capacity):\n    total_water = sum(sum(row) for row in grid)\n    num_times = total_water // capacity + (1 if total_water % capacity != 0 else 0)\n    return num_times\n",
    "HumanEval/116": "def sort_array(arr):\n    def custom_sort(num):\n        return bin(num).count('1'), num\n    \n    non_negative_arr = [num for num in arr if num >= 0]\n    sorted_arr = sorted(non_negative_arr, key=custom_sort)\n    \n    return sorted_arr\n",
    "HumanEval/117": "def count_consonants(word):\n    return sum(1 for letter in word if letter.isalpha() and letter.lower() not in 'aeiou')\n\n\ndef select_words(s, n):\n    words = s.split()\n    result = []\n\n    for word in words:\n        consonant_count = count_consonants(word)\n        \n        if consonant_count == n:\n            result.append(word)\n    \n    return result\n",
    "HumanEval/118": "def get_closest_vowel(word):\n    if len(word) < 3:\n        return \"\"\n\n    vowels = set(\"AEIOUaeiou\")\n    \n    for i in range(1, len(word) - 1):\n        if word[i] not in vowels and word[i-1] in vowels and word[i+1] in vowels:\n            return word[i]\n    \n    return \"\"\n",
    "HumanEval/119": "def match_parens(lst):\n    open_count = lst[0].count('(') + lst[1].count('(')\n    close_count = lst[0].count(')') + lst[1].count(')')\n    \n    balance_diff = open_count - close_count\n    \n    if balance_diff % 2 == 0:\n        for i in range(len(lst)):\n            if balance_diff == 0:\n                break\n            for j in range(len(lst[i])):\n                if lst[i][j] == '(':\n                    balance_diff -= 1\n                    lst[i] = lst[i][:j] + lst[i][j+1:]\n                    break\n        \n        if balance_diff == 0:\n            for s in lst:\n                for c in s:\n                    if c == ')':\n                        return 'No'\n            return 'Yes'\n    \n    return 'No'\n\n# Test the function with examples\nprint(match_parens(['()(', ')']))  # Output should be 'Yes'\nprint(match_parens([')', ')']))    # Output should be 'No'\n",
    "HumanEval/120": "def maximum(arr, k):\n    arr.sort(reverse=True)\n    return arr[:k]\n",
    "HumanEval/121": "def solution(lst):\n    total_sum = 0\n    \n    for i in range(len(lst)):\n        if lst[i] % 2 != 0 and i % 2 == 0:\n            total_sum += lst[i]\n    \n    return total_sum\n",
    "HumanEval/122": "def add_elements(arr, k):\n    total = 0\n    \n    for i in range(k):\n        element = arr[i]\n        if 10 <= abs(element) < 100:\n            total += element\n            \n    return total\n",
    "HumanEval/123": "def get_odd_collatz(n):\n    collatz_sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_sequence.append(n)\n    return sorted(filter(lambda x: x % 2 != 0, collatz_sequence))\n",
    "HumanEval/124": "def valid_date(date):\n    if not date:\n        return False\n    \n    date_parts = date.split('-')\n    if len(date_parts) != 3:\n        return False\n    \n    month, day, year = date_parts\n    \n    try:\n        month = int(month)\n        day = int(day)\n        year = int(year)\n    except ValueError:\n        return False\n    \n    if month < 1 or month > 12:\n        return False\n\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        max_days = 31\n    elif month in [4, 6, 9, 11]:\n        max_days = 30\n    else:\n        if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:\n            max_days = 29\n        else:\n            max_days = 28\n    \n    if day < 1 or day > max_days:\n        return False\n    \n    if year <= 0:\n        return False\n\n    return True\n",
    "HumanEval/125": "def split_words(txt):\n    if ' ' in txt:\n        words = txt.split()\n    elif ',' in txt:\n        words = txt.split(',')\n    else:\n        odd_count = sum(1 for char in txt if char.islower() and ord(char) % 2 != 0)\n        return odd_count\n    \n    return words\n",
    "HumanEval/126": "def is_sorted(lst):\n    def has_duplicate(lst):\n        count_dict = {}\n        for num in lst:\n            if num in count_dict:\n                count_dict[num] += 1\n            else:\n                count_dict[num] = 1\n        \n        for count in count_dict.values():\n            if count > 1:\n                return True\n        \n        return False\n    \n    if has_duplicate(lst):\n        return False\n    \n    sorted_lst = sorted(lst)\n    return lst == sorted_lst\n",
    "HumanEval/127": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef intersection(interval1, interval2):\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    \n    if start > end:\n        return \"NO\"\n    \n    length = end - start\n    \n    if is_prime(length):\n        return \"YES\"\n    else:\n        return \"NO\"\n",
    "HumanEval/128": "def prod_signs(arr):\n    if not arr:\n        return None\n    \n    product_sign = 1\n    \n    for num in arr:\n        if num > 0:\n            product_sign *= 1\n        elif num < 0:\n            product_sign *= -1\n        else:  # for num == 0\n            product_sign *= 0\n    \n    total_magnitude = sum(abs(num) for num in arr)\n    return product_sign * total_magnitude\n",
    "HumanEval/129": "def minPath(grid, k):\n    def neighbors(grid, i, j):\n        rows, cols = len(grid), len(grid[0])\n        valid_neighbors = []\n        offsets = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in offsets:\n            x, y = i + dx, j + dy\n            if 0 <= x < rows and 0 <= y < cols:\n                valid_neighbors.append((x, y))\n        return valid_neighbors\n\n    def is_valid_move(grid, i, j):\n        rows, cols = len(grid), len(grid[0])\n        return 0 <= i < rows and 0 <= j < cols\n\n    def is_valid_path(path, k):\n        return len(path) == k\n\n    def lexicographically_less(path_a, path_b):\n        return path_a < path_b\n            \n    def dfs(grid, i, j, path, result):\n        path.append(grid[i][j])\n\n        if is_valid_path(path, k):\n            result.append(path.copy())\n        else:\n            for ni, nj in neighbors(grid, i, j):\n                dfs(grid, ni, nj, path, result)\n\n        path.pop()\n\n    rows, cols = len(grid), len(grid[0])\n    result = []\n    for i in range(rows):\n        for j in range(cols):\n            dfs(grid, i, j, [], result)\n\n    return min(result)\n\n# Test the function with the examples provided\nprint(minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3))  # Output: [1, 2, 1]\nprint(minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1))  # Output: [1]\n",
    "HumanEval/130": "def tri(n):\n    tribonacci_sequence = [3]  # Initialize list with the base case tri(1)\n\n    if n > 0:\n        tribonacci_sequence.append(1)  # Add base case when n = 1\n        \n    for i in range(2, n+1):\n        if i % 2 == 0:\n            tribonacci_sequence.append(1 + i // 2)  # Calculate Tribonacci number based on the rule for even numbers\n        else:\n            tribonacci_sequence.append(tribonacci_sequence[i-1] + tribonacci_sequence[i-2] + tribonacci_sequence[i+1])  # Calculate Tribonacci number based on the rule for odd numbers\n            \n    return tribonacci_sequence\n",
    "HumanEval/131": "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n    \n    product = 1  # Initialize the product to 1\n    digits_list = [int(d) for d in str(n)]  # Extract individual digits from the given number\n    odd_digits = [d for d in digits_list if d % 2 != 0]  # Check if each digit is odd\n    \n    for digit in odd_digits:\n        product *= digit  # Multiply each odd digit with the running product\n    \n    return product  # Return the final product\n",
    "HumanEval/132": "return len(stack) < len(string)  # Return True if there are remaining elements in the stack (nested brackets found)\n",
    "HumanEval/133": "import math\n\ndef sum_squares(lst):\n    rounded_lst = [math.ceil(x) for x in lst]\n    squared_sum = sum([x ** 2 for x in rounded_lst])\n    return squared_sum\n",
    "HumanEval/134": "def check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n\n    txt = txt.rstrip()\n\n    words = txt.split()\n    last_word = words[-1]\n\n    if not last_word:\n        return False\n\n    last_char = last_word[-1]\n    return last_char.isalpha()\n",
    "HumanEval/135": "def can_arrange(arr):\n    max_index = -1\n    \n    if not arr:\n        return max_index\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            max_index = i\n    \n    return max_index\n",
    "HumanEval/136": "def largest_smallest_integers(lst):\n    largest_neg = None\n    smallest_pos = None\n    \n    for num in lst:\n        if num < 0 and (largest_neg is None or num > largest_neg):\n            largest_neg = num\n        elif num > 0 and (smallest_pos is None or num < smallest_pos):\n            smallest_pos = num\n    \n    return (largest_neg, smallest_pos)\n",
    "HumanEval/137": "def compare_one(a, b):\n    if isinstance(a, str):\n        a = a.replace(',', '.')\n        a = float(a)\n    else:\n        a = float(a)\n\n    if isinstance(b, str):\n        b = b.replace(',', '.')\n        b = float(b)\n    else:\n        b = float(b)\n\n    if a > b:\n        return a\n    elif b > a:\n        return b\n    else:\n        return None\n",
    "HumanEval/138": "def is_equal_to_sum_even(n):\n    if n < 8:\n        return False\n\n    if n % 4 == 0:\n        return True\n    \n    for i in range(2, n-6, 2):\n        for j in range(i, n-4, 2):\n            for k in range(j, n-2, 2):\n                if i + j + k + n == n:\n                    return True\n                \n    return False\n",
    "HumanEval/139": "def special_factorial(n):\n    def factorial(num):\n        if num == 0:\n            return 1\n        else:\n            return num * factorial(num - 1)\n    \n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    return result\n",
    "HumanEval/140": "import re\n\ndef fix_spaces(text):\n    # Step 0: Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Step 1: Replace all instances of more than 2 consecutive spaces with a single underscore using regular expressions\n    result = re.sub(r'( {2,})', '_', text)\n    \n    return result\n",
    "HumanEval/141": "def file_name_check(file_name):\n    valid_extensions = ['txt', 'exe', 'dll']\n    \n    if file_name.count('.') != 1:\n        return 'No'\n    \n    name_parts = file_name.split('.')\n    if len(name_parts) != 2:\n        return 'No'\n    \n    before_dot, after_dot = name_parts\n    \n    if not before_dot or not before_dot[0].isalpha():\n        return 'No'\n    \n    if after_dot not in valid_extensions:\n        return 'No'\n    \n    return 'Yes'\n",
    "HumanEval/142": "def sum_squares(lst):\n    sum_result = 0\n    for index, num in enumerate(lst):\n        if index % 3 == 0:\n            sum_result += num ** 2\n        elif index % 4 == 0:\n            sum_result += num ** 3\n    return sum_result\n",
    "HumanEval/143": "def words_in_sentence(sentence):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    \n    return ' '.join(prime_words)\n",
    "HumanEval/144": "def simplify(x, n):\n    x_num, x_denom = map(int, x.split('/'))\n    n_num, n_denom = map(int, n.split('/'))\n    \n    result_num = x_num * n_num\n    result_denom = x_denom * n_denom\n    \n    return result_num % result_denom == 0\n",
    "HumanEval/145": "def order_by_points(nums):\n    def digit_sum(num):\n        return sum(int(digit) for digit in str(abs(num)))\n\n    sums = [(digit_sum(num), index, num) for index, num in enumerate(nums)]\n    sorted_nums = sorted(sums, key=lambda x: (x[0], x[1]))\n    return [num for _, _, num in sorted_nums]\n",
    "HumanEval/146": "def specialFilter(nums):\n    count = 0\n    if not nums:\n        return 0\n\n    count = 0\n\n    for num in nums:\n        if num > 10:\n            first_digit = int(str(num)[0])\n            last_digit = int(str(num)[-1])\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n\n    return count\n",
    "HumanEval/147": "def get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count\n",
    "HumanEval/148": "def bf(planet1, planet2):\n    PLANETS = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    if planet1 in PLANETS and planet2 in PLANETS:\n        index1 = PLANETS.index(planet1)\n        index2 = PLANETS.index(planet2)\n        \n        if index1 > index2:\n            index1, index2 = index2, index1  # Swap the indexes if they are not in the correct order\n            \n        planets_between = PLANETS[index1+1:index2]\n        \n        sorted_planets = sorted(planets_between, key=lambda x: PLANETS.index(x))\n        \n        return tuple(sorted_planets)\n        \n    else:\n        return ()\n",
    "HumanEval/149": "def sorted_list_sum(lst):\n    even_length_words = []\n    \n    for word in lst:\n        if len(word) % 2 == 0:\n            even_length_words.append(word)\n    \n    sorted_words = sorted(even_length_words, key=lambda x: (len(x), x))\n    \n    return sorted_words\n",
    "HumanEval/150": "def x_or_y(n, x, y):\n    import math\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    if is_prime(n):\n        return x\n    else:\n        return y\n",
    "HumanEval/151": "def double_the_difference(lst):\n    # Step 1: Filter out negative numbers from the list\n    filtered_numbers = [num for num in lst if num >= 0]\n\n    # Step 2: Filter out even numbers\n    odd_numbers = [num for num in filtered_numbers if num % 2 != 0]\n\n    # Step 3: Square each odd number and calculate the sum\n    sum_of_squares = sum([num ** 2 for num in odd_numbers])\n\n    return sum_of_squares\n",
    "HumanEval/152": "def compare(game, guess):\n    result = []\n    \n    for score, g in zip(game, guess):\n        diff = abs(score - g)\n        result.append(diff)\n    \n    return result\n",
    "HumanEval/153": "def Strongest_Extension(class_name, extensions):\n    strengths = {}\n    for extension in extensions:\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        strength = CAP - SM\n        strengths[extension] = strength\n    \n    max_strength_extension = max(strengths, key=strengths.get)\n    \n    return f\"{class_name}.{max_strength_extension}\"\n",
    "HumanEval/154": "def cycpattern_check(a, b):\n    def rotations(word):\n        word_rotations = []\n        for i in range(len(word)):\n            rotated_word = word[i:] + word[:i]\n            word_rotations.append(rotated_word)\n        return word_rotations\n\n    word_rotations = rotations(b)\n    \n    for rotation in word_rotations:\n        if rotation in a:\n            return True\n    \n    return False\n",
    "HumanEval/155": "def even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n\n    num_str = str(num)\n\n    for digit in num_str:\n        if digit.isdigit():\n            digit_int = int(digit)\n\n            if digit_int % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)\n",
    "HumanEval/156": "def int_to_mini_roman(number):\n    roman_numerals = {\n        1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x', 40: 'xl', 50: 'l',\n        90: 'xc', 100: 'c', 400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'\n    }\n    \n    def convert_to_roman(num):\n        result = ''\n        for value in sorted(roman_numerals, reverse=True):\n            while num >= value:\n                result += roman_numerals[value]\n                num -= value\n        return result.lower()\n    \n    return convert_to_roman(number)\n",
    "HumanEval/157": "def right_angle_triangle(a, b, c):\n    if all(isinstance(side, int) and side > 0 for side in [a, b, c]):\n        if a + b > c and b + c > a and a + c > b:\n            sides = [a, b, c]\n            sides.sort()\n            longest_side = sides[2]\n            other_sides = [sides[0], sides[1]]\n            if longest_side ** 2 == other_sides[0] ** 2 + other_sides[1] ** 2:\n                return True\n            else:\n                return False\n        else:\n            return False\n    else:\n        return False\n",
    "HumanEval/158": "def find_max(words):\n    unique_char_counts = {}\n    max_unique_count = 0\n    max_unique_words = []\n\n    for word in words:\n        unique_count = len(set(word))\n        unique_char_counts[word] = unique_count\n\n        if unique_count > max_unique_count:\n            max_unique_count = unique_count\n            max_unique_words = [word]\n        elif unique_count == max_unique_count:\n            max_unique_words.append(word)\n\n    if max_unique_words:\n        max_unique_words.sort()\n        return max_unique_words[0]\n    else:\n        return \"\"\n",
    "HumanEval/159": "def eat(number, need, remaining):\n    total_eaten = number + need\n    total_remaining = remaining\n    \n    if remaining < need:\n        total_eaten += remaining\n        total_remaining = 0\n    \n    return [total_eaten, total_remaining]\n",
    "HumanEval/160": "def do_algebra(operator, operand):\n    if len(operand) < 2 or len(operator) != len(operand) - 1:\n        return \"Invalid input lists. Operand list must have at least 2 elements, and Operator list length should be 1 less than operand list.\"\n\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i + 1])\n\n    result = eval(expression)\n    return result\n",
    "HumanEval/161": "def solve(s):\n    result = \"\"\n    \n    if not any(char.isalpha() for char in s):\n        return s[::-1]\n    \n    for char in s:\n        if char.isalpha():\n            result += char.swapcase()\n        else:\n            result += char\n    \n    return result\n",
    "HumanEval/162": "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    \n    hash_object = hashlib.md5(text.encode())\n    return hash_object.hexdigest()\n",
    "HumanEval/163": "def generate_integers(a, b):\n    even_digits = []\n    \n    for num in range(a, b+1):\n        if num % 2 == 0:\n            even_digits.append(num)\n    \n    return even_digits\n"
}
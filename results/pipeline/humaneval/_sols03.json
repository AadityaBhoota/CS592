{
    "HumanEval/0": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Step 0: Sort the list of numbers\n    for i in range(len(numbers) - 1):  # Step 1: Iterate through the sorted list\n        if abs(numbers[i] - numbers[i + 1]) < threshold:  # Check for closeness within the threshold\n            return True\n    return False\n",
    "HumanEval/1": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(\" \", \"\")\n    separate_groups = []\n    open_paren_count = 0\n    temp_group = \"\"\n\n    for char in paren_string:\n        temp_group += char\n        if char == '(':\n            open_paren_count += 1\n        elif char == ')':\n            open_paren_count -= 1\n            if open_paren_count == 0:\n                separate_groups.append(temp_group)\n                temp_group = \"\"\n\n    return separate_groups\n",
    "HumanEval/2": "def truncate_number(number: float) -> float:\n    decimal_part = number - int(number)\n    return decimal_part\n",
    "HumanEval/3": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        \n        if balance < 0:\n            return True\n    \n    return False\n",
    "HumanEval/4": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        return 0.0\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute difference of each number from the mean\n    absolute_diff = [abs(num - mean) for num in numbers]\n    \n    # Calculate the average of these absolute differences\n    mean_absolute_dev = sum(absolute_diff) / len(absolute_diff)\n    return mean_absolute_dev\n",
    "HumanEval/5": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    return result\n",
    "HumanEval/6": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    groups = paren_string.split()\n\n    def max_nesting_level(parentheses: str) -> int:\n        max_depth = 0\n        current_depth = 0\n        for char in parentheses:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        return max_depth\n\n    return [max_nesting_level(group) for group in groups]\n",
    "HumanEval/7": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    result = []\n    \n    for string in strings:\n        if substring in string:\n            result.append(string)\n    \n    return result\n",
    "HumanEval/8": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:  # Check if numbers list is empty\n        return (0, 1)\n    \n    # Calculate sum and product of numbers in the list\n    numbers_sum = sum(numbers)\n    numbers_product = 1\n    for num in numbers:\n        numbers_product *= num\n    \n    return (numbers_sum, numbers_product)\n",
    "HumanEval/9": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    rolling_max_list = []\n    \n    for i in range(len(numbers)):\n        if i == 0:\n            rolling_max_list.append(numbers[i])\n        else:\n            max_val = max(numbers[:i+1])\n            rolling_max_list.append(max_val)\n\n    return rolling_max_list\n",
    "HumanEval/10": "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string. \"\"\"\n    def longest_postfix_palindrome(s: str) -> str:\n        \"\"\" Find the longest postfix of the supplied string that is a palindrome. \"\"\"\n        for i in range(len(s), 0, -1):\n            if s[:i] == s[:i][::-1]:\n                return s[i:]\n        return s  # If the whole string is a palindrome\n\n    longest_palindrome_postfix = longest_postfix_palindrome(string)\n    prefix = string[:-len(longest_palindrome_postfix)]\n    reversed_prefix = prefix[::-1]  # Reverse the prefix\n    return string + reversed_prefix\n\n# Testing the function\nprint(make_palindrome('cat'))  # Output should be 'catac'\n",
    "HumanEval/11": "from typing import List\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            result += \"1\"\n        else:\n            result += \"0\"\n    \n    return result\n",
    "HumanEval/12": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    \"\"\"\n    if not strings:\n        return None\n    \n    longest_string = strings[0]\n    max_length = len(strings[0])\n\n    for string in strings[1:]:\n        if len(string) > max_length:\n            longest_string = string\n            max_length = len(string)\n    \n    return longest_string\n",
    "HumanEval/13": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b \"\"\"\n    smallest = min(a, b)\n    for i in range(smallest, 0, -1):\n        if a % i == 0 and b % i == 0:\n            return i\n    return 1  # Default return if no common divisor found\n",
    "HumanEval/14": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    prefixes = []\n    # Step 2\n    for i in range(len(string)):\n        prefix = string[:i+1]\n        # Step 4\n        prefixes.append(prefix)\n    return prefixes\n",
    "HumanEval/15": "def string_sequence(n: int) -> str:\n    result = ''\n    for i in range(n + 1):\n        result += str(i)\n        if i < n:\n            result += ' '\n    \n    return result.strip()\n",
    "HumanEval/16": "def count_distinct_characters(string: str) -> int:\n    distinct_chars = set()\n\n    for char in string:\n        char_lower = char.lower()\n        distinct_chars.add(char_lower)\n\n    return len(distinct_chars)\n",
    "HumanEval/17": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    notes = music_string.split()\n    \n    beat_duration = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    \n    beat_durations = []\n    for note in notes:\n        if note in beat_duration:\n            beat_durations.append(beat_duration[note])\n    \n    return beat_durations\n",
    "HumanEval/18": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    \n    count = 0\n    \n    for i in range(len(string) - len(substring) + 1):\n        window = string[i:i + len(substring)]\n        if window == substring:\n            count += 1\n    \n    return count\n",
    "HumanEval/19": "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    number_list = numbers.split()\n\n    num_to_int = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n\n    int_list = [num_to_int[num] for num in number_list]\n    sorted_int_list = sorted(int_list)\n\n    int_to_num = {value: key for key, value in num_to_int.items()}\n    sorted_number_list = [int_to_num[num] for num in sorted_int_list]\n\n    sorted_numbers = ' '.join(sorted_number_list)\n\n    return sorted_numbers\n",
    "HumanEval/20": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers\")\n\n    closest_pair = None\n    min_diff = float('inf')\n\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (numbers[i], numbers[j])\n\n    return tuple(sorted(closest_pair))\n",
    "HumanEval/21": "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    range_values = max_num - min_num\n    rescaled_numbers = [(num - min_num) / range_values for num in numbers]\n    \n    return rescaled_numbers\n",
    "HumanEval/22": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    integers_only = []\n    for value in values:\n        if isinstance(value, int):\n            integers_only.append(value)\n    return integers_only\n",
    "HumanEval/23": "def strlen(string: str) -> int:\n    return len(string)\n",
    "HumanEval/24": "def largest_divisor(n: int) -> int:\n    divisor = 1\n    \n    for i in range(2, n // 2 + 1):\n        if n % i == 0:\n            divisor = i\n    \n    return divisor\n",
    "HumanEval/25": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    prime_factors = []\n    \n    for i in range(2, int(n**0.5) + 1):\n        while n % i == 0:\n            prime_factors.append(i)\n            n //= i\n    \n    if n > 1:\n        prime_factors.append(n)\n    \n    return prime_factors\n",
    "HumanEval/26": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    counts = {}  # Step 0: Create an empty dictionary to store the frequency of each element\n    for num in numbers:  # Step 1: Iterate through the input list and update the frequency of each element in the dictionary\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n            \n    unique_numbers = []  # Step 2: Create a new list to store the unique elements\n    for num in numbers:  # Step 3: Create a list to store elements that occur only once\n        if counts[num] == 1:\n            unique_numbers.append(num)\n            \n    return unique_numbers  # Step 4: Return the new list containing only unique elements\n",
    "HumanEval/27": "def flip_case(string: str) -> str:\n    flipped_string = \"\"\n    for char in string:\n        if char.isupper():\n            flipped_string += char.lower()\n        elif char.islower():\n            flipped_string += char.upper()\n    return flipped_string\n",
    "HumanEval/28": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    result = ''\n    \n    for string in strings:\n        result += string\n        \n    return result\n",
    "HumanEval/29": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    result = []\n    \n    for string in strings:\n        if string.startswith(prefix):\n            result.append(string)\n    \n    return result\n",
    "HumanEval/30": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\"\"\"\n    \n    positive_nums = []\n    \n    for num in l:\n        if num > 0:\n            positive_nums.append(num)\n        \n    return positive_nums\n",
    "HumanEval/31": "import math\n\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n < 2:\n        return False\n    \n    max_divisor = math.isqrt(n) + 1\n    \n    for i in range(2, max_divisor):\n        if n % i == 0:\n            return False\n    \n    return True\n",
    "HumanEval/32": "import math\nimport numpy as np\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef find_zero(xs: list):\n    \"\"\"\n    xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n    if len(xs) % 2 != 0 or len(xs) == 0:\n        return None\n\n    largest_non_zero_coeff = max(filter(lambda x: x != 0, xs), key=abs)\n\n    normalized_xs = [coeff / largest_non_zero_coeff for coeff in xs]\n\n    roots = np.roots(normalized_xs)\n\n    real_root = next((root for root in roots if np.isreal(root)), None)\n\n    return real_root.real if real_root else None\n",
    "HumanEval/33": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    result = []\n    \n    for index, value in enumerate(l):\n        if index % 3 == 0:\n            sorted_value = sorted(l[index])\n            result.append(sorted_value)\n        else:\n            result.append(value)\n    \n    return result\n",
    "HumanEval/34": "def unique(l: list):\n    unique_set = set(l)\n    unique_list = list(unique_set)\n    unique_list.sort()\n    return unique_list\n",
    "HumanEval/35": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\"\"\"\n    max_num = l[0]\n    \n    for num in l[1:]:\n        if num > max_num:\n            max_num = num\n    \n    return max_num\n",
    "HumanEval/36": "def fizz_buzz(n: int):\n    count = 0  # Step 0\n    \n    for num in range(1, n):  # Step 1\n        if num % 11 == 0 or num % 13 == 0:  # Step 2\n            if '7' in str(num):  # Step 3\n                count += 1  # Step 4\n    \n    return count  # Step 6\n",
    "HumanEval/37": "def sort_even(l: list):\n    odd_indices = l[::2]\n    even_indices = sorted(l[1::2])\n    return [val for pair in zip(odd_indices, even_indices) for val in pair]\n",
    "HumanEval/38": "def encode_cyclic(s: str):\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\ndef decode_cyclic(s: str):\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    decoded_groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(decoded_groups)\n",
    "HumanEval/39": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int):\n    count = 0\n    a, b = 0, 1\n    while count < n:\n        a, b = b, a + b\n        if is_prime(a):\n            count += 1\n    return a\n",
    "HumanEval/40": "def triples_sum_to_zero(l: list):\n    n = len(l)\n\n    l.sort()\n\n    for i in range(n):\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            if l[i] + l[left] + l[right] == 0:\n                return True\n            elif l[i] + l[left] + l[right] < 0:\n                left += 1\n            else:\n                right -= 1\n\n    return False\n",
    "HumanEval/41": "def car_race_collision(n: int):\n    total_collisions = n * n\n    return total_collisions\n",
    "HumanEval/42": "def incr_list(l: list):\n    result = []\n    \n    for num in l:\n        result.append(num + 1)\n    \n    return result\n",
    "HumanEval/43": "def pairs_sum_to_zero(l):\n    seen = set()\n    \n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    \n    return False\n",
    "HumanEval/44": "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n    # Step 0: Validate base\n    if base >= 10:\n        return \"Base should be less than 10.\"\n\n    # Step 1: Initialize an empty string to store the converted result\n    result = \"\"\n    \n    # Step 2: Convert the number to the new base\n    while x > 0:\n        remainder = x % base\n        result = str(remainder) + result  # Build the converted number in reverse order\n        x //= base\n\n    return result\n",
    "HumanEval/45": "def triangle_area(a, h):\n    return 0.5 * a * h\n\n# Testing the function\nprint(triangle_area(5, 3))  # Expected output: 7.5\n",
    "HumanEval/46": "def fib4(n: int):\n    if n < 4:\n        return 0\n    else:\n        fib4_sequence = [0, 0, 2, 0]  # Initial sequence\n\n        for i in range(4, n+1):\n            next_element = fib4_sequence[-1] + fib4_sequence[-2] + fib4_sequence[-3] + fib4_sequence[-4]\n            fib4_sequence = fib4_sequence[1:] + [next_element]\n\n        return fib4_sequence[-1]\n",
    "HumanEval/47": "def median(l: list):\n    if not l:  # Check if the list is empty\n        return None\n    \n    sorted_list = sorted(l)  # Sort the list\n    \n    n = len(sorted_list)\n    if n % 2 != 0:  # If the length of the list is odd\n        return sorted_list[n // 2]\n    # If the length of the list is even\n    return (sorted_list[n // 2 - 1] + sorted_list[n // 2]) / 2\n",
    "HumanEval/48": "def is_palindrome(text: str):\n    pointer1 = 0\n    pointer2 = len(text) - 1\n\n    while pointer1 < pointer2:\n        if text[pointer1] != text[pointer2]:\n            return False\n        \n        pointer1 += 1\n        pointer2 -= 1\n    \n    return True\n",
    "HumanEval/49": "def modp(n: int, p: int):\n    power_of_2 = 2 ** n\n    result = power_of_2 % p\n    return result\n",
    "HumanEval/50": "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    decoded_str = \"\"\n    for ch in s:\n        if ch.isalpha():\n            decoded_char = chr((ord(ch) - ord(\"a\") - 5) % 26 + ord(\"a\"))\n            decoded_str += decoded_char\n        else:\n            decoded_str += ch\n    return decoded_str\n",
    "HumanEval/51": "def remove_vowels(text):\n    result = \"\"\n    for char in text:\n        if char.lower() not in ['a', 'e', 'i', 'o', 'u']:\n            result += char\n    return result\n",
    "HumanEval/52": "def below_threshold(l: list, t: int):\n    for num in l:\n        if num >= t:\n            return False\n    return True\n",
    "HumanEval/53": "def add(x: int, y: int):\n    return x + y\n",
    "HumanEval/54": "def same_chars(s0: str, s1: str):\n    s0 = ''.join([char for char in s0 if char.isalpha()])\n    s1 = ''.join([char for char in s1 if char.isalpha()])\n    \n    sorted_s0 = sorted(s0)\n    sorted_s1 = sorted(s1)\n    \n    return sorted_s0 == sorted_s1\n",
    "HumanEval/55": "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n in (0, 1):\n        return n\n    \n    a, b = 0, 1\n    \n    for _ in range(2, n):\n        a, b = b, a + b\n        \n    return b\n",
    "HumanEval/56": "def correct_bracketing(brackets: str):\n    balance = 0\n   \n    for bracket in brackets:\n        if bracket == \"<\":\n            balance += 1\n        elif bracket == \">\":\n            balance -= 1\n            if balance < 0:\n                return False\n\n    return balance == 0\n",
    "HumanEval/57": "def monotonic(l: list):\n    increasing = all(l[i] <= l[i + 1] for i in range(len(l) - 1))\n    decreasing = all(l[i] >= l[i + 1] for i in range(len(l) - 1))\n    \n    if increasing or decreasing:\n        return True\n    return False\n",
    "HumanEval/58": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    \n    result = []\n    \n    for el in l1:\n        if el in l2 and el not in result:\n            result.append(el)\n    \n    return sorted(result)\n",
    "HumanEval/59": "def largest_prime_factor(n: int):\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return n\n\n# Test cases\nresult1 = largest_prime_factor(13195)\nresult2 = largest_prime_factor(2048)\n\nresult1, result2\n",
    "HumanEval/60": "def sum_to_n(n: int):\n    total_sum = 0\n\n    for i in range(1, n+1):\n        total_sum += i\n\n    return total_sum\n",
    "HumanEval/61": "def correct_bracketing(brackets: str):\n    stack = []\n    \n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if not stack:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n",
    "HumanEval/62": "def derivative(xs: list):\n    \"\"\" \n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    \n    derivative_coeffs = []\n\n    for power, coefficient in enumerate(xs[1:], start=1):\n        derivative_coeffs.append(coefficient * power)\n\n    return derivative_coeffs\n",
    "HumanEval/63": "def fibfib(n: int):\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n",
    "HumanEval/64": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. \n    Here, 'y' is also a vowel, but only when it is at the end of the given word.\n    \n    :param s: A string representing a word.\n    :return: The number of vowels in the given word.\n    \"\"\"\n    vowel_count = 0\n    \n    for char in s:\n        if char.lower() in ['a', 'e', 'i', 'o', 'u']:\n            vowel_count += 1\n\n    return vowel_count\n",
    "HumanEval/65": "def circular_shift(x, shift):\n    x_str = str(x)\n    num_digits = len(x_str)\n    \n    if shift > num_digits:\n        return x_str[::-1]\n    \n    rotated_str = x_str[num_digits - shift:] + x_str[:num_digits - shift]\n    return rotated_str\n",
    "HumanEval/66": "def digitSum(s):\n    total_sum = 0\n    for char in s:\n        if char.isupper():\n            total_sum += ord(char)\n    return total_sum\n",
    "HumanEval/67": "def fruit_distribution(s, n):\n    nums = [int(word) for word in s.split() if word.isdigit()]\n    apples = nums[0] if \"apples\" in s else 0\n    oranges = nums[1] if \"oranges\" in s else 0\n    mango = n - apples - oranges\n    \n    return mango\n",
    "HumanEval/68": "def pluck(arr):\n    min_even = None\n    min_even_index = None\n\n    for index, node in enumerate(arr):\n        if node % 2 == 0:  # Check if the node is even\n            if min_even is None or (node < min_even):\n                min_even = node\n                min_even_index = index\n\n    if min_even is None:\n        return []\n\n    return [min_even, min_even_index]\n",
    "HumanEval/69": "def search(lst):\n    freq_dict = {}\n    \n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    \n    max_num = -1\n    \n    for num, freq in freq_dict.items():\n        if num > freq and num > 0:\n            if freq >= max_num:\n                max_num = num\n    \n    return max_num\n",
    "HumanEval/70": "def strange_sort_list(lst):\n    if not lst:\n        return []\n\n    result = []\n    while lst:\n        min_val = min(lst)\n        result.append(min_val)\n        lst.remove(min_val)\n\n        if lst:\n            max_val = max(lst)\n            result.append(max_val)\n            lst.remove(max_val)\n\n    return result\n",
    "HumanEval/71": "import math\n\ndef triangle_area(a, b, c):\n    if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1\n",
    "HumanEval/72": "def will_it_fly(q, w):\n    is_palindromic = q == q[::-1]\n    total_weight = sum(q)\n    return is_palindromic and total_weight <= w\n",
    "HumanEval/73": "def smallest_change(arr):\n    # Step 1: Identify indices where elements need to be changed\n    n = len(arr)\n    change_indices = [i for i in range(n // 2) if arr[i] != arr[n - i - 1]]\n    \n    # Step 2: Initialize variable count to 0\n    count = 0\n    \n    # Step 3: Iterate through the change_indices list\n    for index in change_indices:\n        # Step 4: Find the minimum change required at the current index\n        count += min(abs(arr[index] - arr[n - index - 1]), 26 - abs(arr[index] - arr[n - index - 1]))\n        \n    return count\n",
    "HumanEval/74": "def total_match(lst1, lst2):\n    def total_chars_in_list(lst):\n        return sum(len(s) for s in lst)\n\n    total_chars_lst1 = total_chars_in_list(lst1)\n    total_chars_lst2 = total_chars_in_list(lst2)\n\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1  # If total characters are equal, return lst1\n",
    "HumanEval/75": "from itertools import combinations\n\ndef is_multiply_prime(a):\n    if a >= 100:\n        return False\n\n    def is_prime(x):\n        if x < 2:\n            return False\n        for i in range(2, int(x ** 0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    prime_factors = [i for i in range(2, a) if is_prime(i) and a % i == 0]\n\n    for combo in combinations(prime_factors, 3):\n        if combo[0] * combo[1] * combo[2] == a:\n            return True\n\n    return False\n",
    "HumanEval/76": "def is_simple_power(x, n):\n    if x == 1:\n        return False\n    elif n == 1:\n        return True\n    else:\n        result = math.log(x, n)\n        return result.is_integer()\n",
    "HumanEval/77": "# Step 3: Find the cube root of the number and check if it is an integer\n\ndef iscube(a):\n    if a < 0:\n        a = abs(a)\n    \n    cube_root = a**(1/3)\n    \n    # Step 4: If the cube root is an integer, return True; otherwise, return False.\n    return cube_root.is_integer()\n",
    "HumanEval/78": "def hex_key(num):\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in prime_digits:\n            count += 1\n    return count\n",
    "HumanEval/79": "def decimal_to_binary(decimal):\n    if not isinstance(decimal, int) or decimal < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    binary = bin(decimal)[2:]  # Convert decimal to binary and remove the '0b' prefix\n    binary = '0' * (8 - len(binary) % 8) + binary if len(binary) % 8 != 0 else binary  # Pad with zeros to make it a multiple of 8\n    \n    binary = 'db' + binary + 'db'  # Add 'db' at the beginning and end\n    \n    return binary\n",
    "HumanEval/80": "def is_happy(s):\n    if len(s) < 3:\n        return False\n    \n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n            \n    return True\n",
    "HumanEval/81": "def numerical_letter_grade(grades):\n    \"\"\"\n    It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write\n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A\n            > 3.3                A-\n            > 3.0                B+\n            > 2.7                B\n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+\n            > 0.7                D\n            > 0.0                D-\n              0.0                E\n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'A', 'C', 'B', 'A-']\n    \"\"\"\n    letter_grades = []  # Step 1: Create an empty list to store the letter grades\n\n    # Step 2: Iterate over each GPA and calculate the corresponding letter grade\n    for gpa in grades:\n        if 0.0 <= gpa <= 4.0:  # Check if GPA is within valid range\n            if gpa == 4.0:\n                letter_grades.append('A+')\n            elif 3.7 < gpa <= 4.0:\n                letter_grades.append('A')\n            elif 3.3 < gpa <= 3.7:\n                letter_grades.append('A-')\n            elif 3.0 < gpa <= 3.3:\n                letter_grades.append('B+')\n            elif 2.7 < gpa <= 3.0:\n                letter_grades.append('B')\n            elif 2.3 < gpa <= 2.7:\n                letter_grades.append('B-')\n            elif 2.0 < gpa <= 2.3:\n                letter_grades.append('C+')\n            elif 1.7 < gpa <= 2.0:\n                letter_grades.append('C')\n            elif 1.3 < gpa <= 1.7:\n                letter_grades.append('C-')\n            elif 1.0 < gpa <= 1.3:\n                letter_grades.append('D+')\n            elif 0.7 < gpa <= 1.0:\n                letter_grades.append('D')\n            elif 0.0 < gpa <= 0.7:\n                letter_grades.append('D-')\n        else:\n            letter_grades.append('Invalid GPA')  # Handle invalid GPA case\n    \n    return letter_grades  # Step 5: Return the list of calculated letter grades\n",
    "HumanEval/82": "import math\n\ndef prime_length(string):\n    if len(string) < 2:\n        return False\n    \n    sqrt_len = int(math.sqrt(len(string)))\n    \n    for i in range(2, sqrt_len + 1):\n        if len(string) % i == 0:\n            return False\n    \n    return True\n",
    "HumanEval/83": "    return count\n",
    "HumanEval/84": "def solve(N):\n    binary_str = bin(N)[2:]  # Convert N to binary string and remove the '0b' prefix\n    digit_sum = sum(int(digit) for digit in binary_str)\n    return bin(digit_sum)[2:]\n\n# Test the final implementation\nprint(solve(1000))  # Output: '110'\nprint(solve(150))   # Output: '110'\nprint(solve(147))   # Output: '1100'\n",
    "HumanEval/85": "def add(lst):\n    total_sum = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total_sum += lst[i]\n    return total_sum\n",
    "HumanEval/86": "def anti_shuffle(s):\n    words = s.split()\n    ordered_words = []\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        ordered_words.append(sorted_word)\n    \n    ordered_string = ' '.join(ordered_words)\n    \n    return ordered_string\n",
    "HumanEval/87": "def get_row(lst, x):\n    coordinates = []\n    \n    for i, row in enumerate(lst):\n        if x in row:\n            indices = [j for j, val in enumerate(row) if val == x]\n            for j in indices:\n                coordinates.append((i, j))\n    \n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n",
    "HumanEval/88": "def sort_array(array):\n    if not array:  # Check if the array is empty\n        return []\n    \n    first_element = array[0]\n    last_element = array[-1]\n    sum_first_last = first_element + last_element\n    \n    if sum_first_last % 2 == 0:\n        sorted_array = sorted(array, reverse=True)\n    else:\n        sorted_array = sorted(array)\n    \n    return sorted_array\n",
    "HumanEval/89": "def encrypt(s):\n    result = \"\"\n    \n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2  # Shifting down by two multiplied to two places\n            shifted_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a')) if char.islower() else chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            result += shifted_char\n        else:\n            result += char\n        \n    return result\n",
    "HumanEval/90": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = list(set(lst))\n    \n    if len(unique_lst) < 2:\n        return None\n    \n    unique_lst.sort()\n    \n    return unique_lst[1]\n",
    "HumanEval/91": "import re\n\ndef is_bored(S):\n    sentences = [sentence.strip() for sentence in re.split(r'[.!?]', S)]\n    bored_count = sum(1 for sentence in sentences if sentence.startswith('I'))\n    return bored_count\n",
    "HumanEval/92": "def any_int(x, y, z):\n    if all(isinstance(num, int) for num in [x, y, z]):\n        if x == y + z or y == x + z or z == x + y:\n            return True\n    return False\n",
    "HumanEval/93": "def encode(message):\n    vowels_mapping = {\n        'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w',\n        'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'\n    }\n    encoded_message = \"\"\n    \n    for char in message:\n        if char.isalpha():\n            if char.lower() in vowels_mapping:\n                encoded_message += vowels_mapping[char.lower()]\n            else:\n                encoded_message += char.swapcase()\n        else:\n            encoded_message += char\n\n    return encoded_message\n",
    "HumanEval/94": "def skjkasdkd(lst):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_numbers = [num for num in lst if is_prime(num)]\n    if prime_numbers:\n        largest_prime = max(prime_numbers)\n        sum_digits = sum(int(digit) for digit in str(largest_prime))\n        return sum_digits\n    return 0\n",
    "HumanEval/95": "def check_dict_case(dict):\n    if not dict:\n        return False\n\n    lower = False\n    upper = False\n\n    for key in dict:\n        if isinstance(key, str):\n            if key.islower():\n                lower = True\n            elif key.isupper():\n                upper = True\n        else:\n            return False\n\n    if lower and not upper:\n        return True\n    elif upper and not lower:\n        return True\n    else:\n        return False\n",
    "HumanEval/96": "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_up_to(n):\n    prime_numbers = []\n    count = 0\n    num = 2\n    while count < n:\n        if is_prime(num):\n            prime_numbers.append(num)\n            count += 1\n        num += 1\n        if num >= n:\n            break\n    return prime_numbers\n",
    "HumanEval/97": "def multiply(a, b):\n    unit_digit_a = a % 10\n    unit_digit_b = b % 10\n    \n    product = unit_digit_a * unit_digit_b\n    return product\n",
    "HumanEval/98": "def count_upper(s):\n    upper_vowel_count = 0\n    \n    for index, char in enumerate(s):\n        if char.upper() in ['A', 'E', 'I', 'O', 'U'] and index % 2 == 0:\n            upper_vowel_count += 1\n    \n    return upper_vowel_count\n",
    "HumanEval/99": "def closest_integer(value):\n    value = float(value)\n    floor_value = int(value)\n    ceil_value = int(value) + 1\n    diff_floor = abs(value - floor_value)\n    diff_ceil = abs(value - ceil_value)\n    \n    if diff_floor == diff_ceil:\n        return ceil_value if value > 0 else floor_value\n    \n    return ceil_value if diff_ceil < diff_floor else floor_value\n",
    "HumanEval/100": "def make_a_pile(n):\n    stones_in_each_level = []\n    stones_in_each_level.append(n)\n    \n    current_level_stones = n\n    for _ in range(n - 1):\n        if current_level_stones % 2 == 0:\n            current_level_stones += 1\n        else:\n            current_level_stones += 2\n        stones_in_each_level.append(current_level_stones)\n    \n    return stones_in_each_level\n",
    "HumanEval/101": "def words_string(s):\n    words = [word.strip() for word in s.replace(',', ' ').split()]\n    return words\n",
    "HumanEval/102": "def choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n\n    max_even_num = -1\n\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            if num > max_even_num:\n                max_even_num = num\n\n    return max_even_num\n",
    "HumanEval/103": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    \n    avg = (n + m) / 2\n    rounded_avg = round(avg)\n    \n    return bin(rounded_avg)\n",
    "HumanEval/104": "def unique_digits(x):\n    result = []\n    \n    for num in x:\n        has_even_digit = any(int(digit) % 2 == 0 for digit in str(num))\n        if not has_even_digit:\n            result.append(num)\n    \n    return sorted(result)\n",
    "HumanEval/105": "def by_length(arr):\n    if not arr:\n        return []\n    \n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    filtered_arr.sort()\n    filtered_arr.reverse()\n    words = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    result = [words[num] for num in filtered_arr]\n    return result\n",
    "HumanEval/106": "def f(n):\n    result = []\n    \n    for i in range(1, n+1):\n        if i % 2 == 0:\n            fact = 1\n            for j in range(1, i+1):\n                fact *= j\n            result.append(fact)\n        else:\n            result.append(sum(range(1, i+1)))\n    \n    return result\n",
    "HumanEval/107": "def even_odd_palindrome(n):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)\n",
    "HumanEval/108": "def count_nums(arr):\n    def sum_digits(num):\n        return sum(int(d) for d in str(abs(num)))\n\n    count = 0\n    for num in arr:\n        if sum_digits(num) > 0:\n            count += 1\n\n    return count\n",
    "HumanEval/109": "def move_one_ball(arr):\n    if not arr:  # Step 0: Check if the input array is empty\n        return True\n    \n    # Step 1: Find the index of the minimum element in the array\n    min_index = arr.index(min(arr))\n    \n    # Step 2: Calculate the number of right shifts needed to bring the minimum element to the first position\n    num_shifts = len(arr) - min_index\n    \n    # Step 4: Create a new array by performing the right shifts\n    new_arr = arr[-min_index:] + arr[:-min_index]\n    \n    # Step 5: Check if the new array is sorted in non-decreasing order\n    is_sorted = all(new_arr[i] <= new_arr[i+1] for i in range(len(new_arr)-1))\n    \n    return is_sorted\n",
    "HumanEval/110": "def exchange(lst1, lst2):\n    if all(x % 2 == 0 for x in lst1):\n        return \"YES\"  # No exchange needed\n\n    odd_count_lst1 = sum(1 for x in lst1 if x % 2 != 0)\n    odd_count_total = odd_count_lst1 + sum(1 for x in lst2 if x % 2 != 0)\n\n    if odd_count_total >= odd_count_lst1:\n        return \"YES\"  # There are enough odd elements in lst2 to exchange with lst1\n    else:\n        return \"NO\"  # Not enough odd elements in lst2 for the exchange\n",
    "HumanEval/111": "def histogram(test):\n    letters = test.split()\n    letter_count = {}\n    \n    for letter in letters:\n        if letter in letter_count:\n            letter_count[letter] += 1\n        else:\n            letter_count[letter] = 1\n    \n    max_count = max(letter_count.values())\n    \n    max_letters = {letter: count for letter, count in letter_count.items() if count == max_count}\n    \n    return max_letters\n",
    "HumanEval/112": "def is_palindrome(s):\n    return s == s[::-1]\n",
    "HumanEval/113": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    results = []\n    \n    for string in lst:\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        result_string = f\"the number of odd elements in the string {odd_count} of the input.\"\n        results.append(result_string)\n    \n    return results\n",
    "HumanEval/114": "def minSubArraySum(nums):\n    min_sum = float('inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n        current_sum = max(current_sum, 0)\n\n    return min_sum\n",
    "HumanEval/115": "def max_fill(grid, capacity):\n    total_operations = 0\n\n    # Iterating over each well in the grid to calculate the total units exceeding the bucket capacity\n    for row in grid:\n        for well in row:\n            if well > 0:\n                total_operations += -(-well // capacity)\n    \n    return total_operations\n",
    "HumanEval/116": "def sort_array(arr):\n    def count_ones(num):\n        return bin(num).count('1')\n\n    arr.sort(key=lambda x: (count_ones(x), x))\n    \n    return arr\n",
    "HumanEval/117": "def select_words(s, n):\n    def count_consonants(word):\n        consonants = \"bcdfghjklmnpqrstvwxyz\"\n        return len([letter for letter in word.lower() if letter in consonants])\n\n    words = s.split()  # Step 0: Split the input string into words\n\n    filtered_words = [word for word in words if count_consonants(word) == n]  # Step 2: Filter out words with n consonants\n    return filtered_words\n",
    "HumanEval/118": "def get_closest_vowel(word):\n    vowels = set(\"aeiouAEIOU\")\n    \n    for i in range(len(word) - 1, 0, -1):  # from the last character (excluding) to the second character\n        if word[i].isalpha() and not word[i].lower() in vowels:  # check for consonant\n            if word[i-1].isalpha() and not word[i-1].lower() in vowels and word[i+1].isalpha() and not word[i+1].lower() in vowels:\n                for v in range(i+1, len(word)):\n                    if word[v].isalpha() and word[v].lower() in vowels:\n                        return word[v]\n    \n    return \"\"\n",
    "HumanEval/119": "def match_parens(lst):\n    concat_string = lst[0] + lst[1]\n    open_count = 0\n\n    for char in concat_string:\n        if char == '(':\n            open_count += 1\n        elif char == ')':\n            open_count -= 1\n            if open_count < 0:\n                return 'No'\n\n    if open_count == 0:\n        return 'Yes'\n    else:\n        return 'No'\n",
    "HumanEval/120": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    max_numbers = []\n    arr.sort(reverse=True)\n    max_numbers = arr[:k]\n    return max_numbers\n",
    "HumanEval/121": "def solution(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 != 0)\n",
    "HumanEval/122": "def add_elements(arr, k):\n    sum_two_digits = 0\n    for i in range(k):\n        if 10 <= abs(arr[i]) < 100:\n            sum_two_digits += arr[i]\n    return sum_two_digits\n",
    "HumanEval/123": "def get_odd_collatz(n):\n    odd_collatz_list = []\n    \n    while n != 1:\n        if n % 2 == 1:\n            odd_collatz_list.append(n)\n        \n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    \n    if n % 2 == 1:  # Add n when n reaches 1\n        odd_collatz_list.append(n)\n    \n    odd_collatz_list.sort()\n    return odd_collatz_list\n\n# Test the function\nprint(get_odd_collatz(5))  # Output: [1, 5]\n",
    "HumanEval/124": "import re\n\ndef valid_date(date):\n    if not date:\n        return False\n    \n    date_parts = date.split('-')\n    \n    if len(date_parts) != 3:\n        return False\n    \n    month, day, year = date_parts\n    \n    if not all(part.isdigit() for part in date_parts):\n        return False\n    \n    month = int(month)\n    \n    if month < 1 or month > 12:\n        return False\n    \n    day = int(day)\n    \n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:  # Consider leap years separately\n            return False\n    else:\n        return False\n    \n    if not re.match(r'^\\d{2}-\\d{2}-\\d{4}$', date):\n        return False\n    \n    return True\n",
    "HumanEval/125": "def split_words(txt):\n    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.split(\",\")\n    else:\n        count = sum(1 for char in txt if char.islower() and ord(char) % 2 == 1)\n        return count if count > 0 else \"No lowercase letters with odd order in the alphabet\"\n",
    "HumanEval/126": "def is_sorted(lst):\n    prev = None\n    duplicates = set()\n    \n    for num in lst:\n        if num == prev:\n            duplicates.add(num)\n        elif num < prev:\n            return False\n        prev = num\n    \n    if len(duplicates) > 1:\n        return False\n    \n    return True\n",
    "HumanEval/127": "def intersection(interval1, interval2):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    \n    if start > end:\n        return \"NO\"  # No intersection\n    \n    length = end - start + 1\n    \n    if is_prime(length):\n        return \"YES\"\n    else:\n        return \"NO\"\n",
    "HumanEval/128": "def prod_signs(arr):\n    if not arr:\n        return None\n    \n    sign_product = 1\n    sum_magnitudes = 0\n    \n    for num in arr:\n        if num == 0:\n            continue\n        elif num > 0:\n            sum_magnitudes += num\n            sign_product *= 1\n        else:\n            sum_magnitudes += abs(num)\n            sign_product *= -1\n    \n    return sum_magnitudes * sign_product\n",
    "HumanEval/129": "def minPath(grid, k):\n    def get_neighbors(grid, row, col):\n        neighbors = []\n        rows, cols = len(grid), len(grid[0])\n\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                neighbors.append((new_row, new_col))\n\n        return neighbors\n\n    def find_min_path(grid, k, start_row, start_col):\n        rows, cols = len(grid), len(grid[0])\n\n        def backtrack(row, col, path):\n            if len(path) == k:\n                return path\n\n            neighbors = get_neighbors(grid, row, col)\n            paths = []\n            for new_row, new_col in neighbors:\n                if (new_row, new_col) not in path:\n                    new_path = backtrack(new_row, new_col, path + [(new_row, new_col)])\n                    if new_path:\n                        paths.append(new_path)\n\n            if paths:\n                return min(paths)\n            return None\n\n        return [grid[start_row][start_col]] + backtrack(start_row, start_col, [(start_row, start_col)])\n\n    rows, cols = len(grid), len(grid[0])\n    min_path = None\n\n    for i in range(rows):\n        for j in range(cols):\n            path = find_min_path(grid, k, i, j)\n            if min_path is None or path < min_path:\n                min_path = path\n\n    return min_path\n",
    "HumanEval/130": "def tri(n):\n    tribonacci = []  # To store the numbers in the Tribonacci sequence\n    \n    if n == 0:\n        return tribonacci\n    elif n == 1:\n        return [3]\n    elif n == 2:\n        return [3, 2]\n    \n    tribonacci = [0] * (n + 1)  # Initialize the list with zeros\n    tribonacci[0], tribonacci[1], tribonacci[2] = 0, 1, 1  # Set the initial values\n    \n    for i in range(3, n+1):\n        if i % 2 == 0:  # If i is even\n            tribonacci[i] = 1 + i // 2\n        else:  # If i is odd\n            tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3]\n    \n    return tribonacci\n",
    "HumanEval/131": "def digits(n):\n    product = 1\n    n_str = str(n)\n    \n    for digit in n_str:\n        digit_int = int(digit)\n        \n        if digit_int % 2 != 0:\n            product *= digit_int\n    \n    if product == 1:\n        return 0\n    \n    return product\n",
    "HumanEval/132": "def is_nested(string):\n    stack = []\n    \n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n    \n    return len(stack) > 0\n",
    "HumanEval/133": "import math\n\ndef sum_squares(lst):\n    total_sum = 0\n    for num in lst:\n        rounded_num = math.ceil(num)\n        squared_num = rounded_num * rounded_num\n        total_sum += squared_num\n    return total_sum\n",
    "HumanEval/134": "def check_if_last_char_is_a_letter(txt):\n    if txt == \"\":\n        return False\n    \n    last_char = txt[-1]\n    if last_char.isalpha() and (len(txt) == 1 or txt[-2] == \" \"):\n        return True\n    else:\n        return False\n",
    "HumanEval/135": "def can_arrange(arr):\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n                \n    return -1\n",
    "HumanEval/136": "def largest_smallest_integers(lst):\n    largest_negative = None\n    smallest_positive = None\n    \n    for num in lst:\n        if num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n        elif num > 0:\n            if smallest_positive is None or num < smallest_positive:\n                smallest_positive = num\n\n    return (largest_negative, smallest_positive)\n",
    "HumanEval/137": "def compare_one(a, b):\n    if a == b:\n        return None\n\n    if (isinstance(a, (int, float)) or a.replace(\",\", \".\").replace(\".\", \"\").isdigit()) and \\\n       (isinstance(b, (int, float)) or b.replace(\",\", \".\").replace(\".\", \"\").isdigit()):\n    \n        a_numeric = float(a.replace(\",\", \".\")) if isinstance(a, str) else a\n        b_numeric = float(b.replace(\",\", \".\")) if isinstance(b, str) else b\n\n        return max(a_numeric, b_numeric)\n    \n    return a if a > b else b\n",
    "HumanEval/138": "def is_equal_to_sum_even(n):\n    if n < 8:\n        return False\n    \n    count = 0\n    for i in range(2, n, 2):\n        diff = n - i\n        if diff >= 0:\n            count += 1\n    \n    return count == 4\n",
    "HumanEval/139": "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    result = 1\n\n    def factorial(num):\n        if num <= 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n\n    return result\n",
    "HumanEval/140": "def fix_spaces(text):\n    modified_text = text.replace(\" \", \"_\")\n    \n    # Replace more than two consecutive underscores with a single underscore\n    modified_text = modified_text.replace(\"__\", \"_\")\n    \n    # Replace all remaining consecutive underscores with a single hyphen\n    while \"--\" in modified_text:\n        modified_text = modified_text.replace(\"--\", \"-\")\n    \n    return modified_text\n",
    "HumanEval/141": "def file_name_check(file_name):\n    if sum(c.isdigit() for c in file_name) > 3:\n        return 'No'\n\n    if file_name.count('.') != 1:\n        return 'No'\n\n    file_parts = file_name.split('.')\n    if not file_parts[0][0].isalpha():\n        return 'No'\n\n    valid_extensions = ['txt', 'exe', 'dll']\n    if file_parts[-1] not in valid_extensions:\n        return 'No'\n\n    return 'Yes'\n",
    "HumanEval/142": "def sum_squares(lst):\n    total = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = lst[i] ** 3\n        total += lst[i]\n    return total\n",
    "HumanEval/143": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    \n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n        \n    return True\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)\n\nsentence = \"This is a test\"\nprint(words_in_sentence(sentence))  # Output: \"is\"\n",
    "HumanEval/144": "def simplify(x, n):\n    x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n\n    result_num = x_num * n_num\n    result_den = x_den * n_den\n\n    return result_num % result_den == 0\n",
    "HumanEval/145": "def sum_of_digits(num):\n    return sum(int(digit) for digit in str(abs(num)))\n\ndef order_by_points(nums):\n    key_func = lambda num, idx: (sum_of_digits(num), idx)\n    return sorted(nums, key=lambda x: key_func(x, nums.index(x)))\n",
    "HumanEval/146": "def specialFilter(nums):\n    count = 0\n\n    for num in nums:\n        if num > 10:\n            str_num = str(abs(num))\n            if int(str_num[0]) % 2 == 1 and int(str_num[-1]) % 2 == 1:\n                count += 1\n\n    return count\n",
    "HumanEval/147": "def get_max_triples(n):\n    a = []\n    for i in range(1, n+1):\n        a.append(i * i - i + 1)\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    \n    return count\n",
    "HumanEval/148": "def bf(planet1, planet2):\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    index1 = planets.index(planet1) if planet1 in planets else -1\n    index2 = planets.index(planet2) if planet2 in planets else -1\n    \n    if index1 == -1 or index2 == -1:\n        return ()\n    \n    if index1 > index2:\n        planet1, planet2 = planet2, planet1\n        \n    between_planets = planets[index1+1:index2]\n    \n    return tuple(between_planets)\n",
    "HumanEval/149": "def sorted_list_sum(lst):\n    if not lst:\n        return []\n\n    filtered_list = [word for word in lst if len(word) % 2 != 0]\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n\n    return sorted_list\n",
    "HumanEval/150": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = math.isqrt(n) + 1\n    for i in range(3, max_divisor, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef x_or_y(n, x, y):\n    if is_prime(n):\n        return x\n    else:\n        return y\n",
    "HumanEval/151": "def double_the_difference(lst):\n    sum_squares = 0\n    \n    for num in lst:\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            square_num = num ** 2\n            sum_squares += square_num\n    \n    return sum_squares if sum_squares > 0 else 0\n",
    "HumanEval/152": "def compare(game, guess):\n    differences = []  # Step 0: Create an empty list to store the differences\n    \n    # Step 1: Iterate over the elements of the game and guess arrays simultaneously using zip\n    for score, prediction in zip(game, guess):\n        # Step 2: Calculate the absolute difference between the score and prediction\n        diff = abs(score - prediction)\n        differences.append(diff)\n    \n    # Step 3: Return the list of differences\n    return differences\n",
    "HumanEval/153": "def Strongest_Extension(class_name, extensions):\n    strongest_extension = \"\"\n    max_strength = float('-inf')\n    \n    for extension in extensions:\n        CAP = sum(1 for letter in extension if letter.isupper())\n        SM = sum(1 for letter in extension if letter.islower())\n        strength = CAP - SM\n        \n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n\n    return f\"{class_name}.{strongest_extension}\"\n",
    "HumanEval/154": "def cycpattern_check(a, b):\n    if len(a) < len(b):\n        return False\n    \n    concat_a = a + a\n    \n    for i in range(len(a)):\n        sub_str = concat_a[i:i + len(b)]\n        if sub_str == b:\n            return True\n        b = b[1:] + b[0]\n    \n    return False\n",
    "HumanEval/155": "return even_count, odd_count  # Return the counts of even and odd digits\n",
    "HumanEval/156": "def int_to_mini_roman(number):\n    roman_numerals = {\n        1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x',\n        40: 'xl', 50: 'l', 90: 'xc', 100: 'c',\n        400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'\n    }\n    \n    conversion_rules = [\n        (1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n        (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'),\n        (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')\n    ]\n    \n    result = ''\n    for value, numeral in conversion_rules:\n        while number >= value:\n            result += roman_numerals[value]\n            number -= value\n            \n    return result.lower()\n",
    "HumanEval/157": "def right_angle_triangle(a, b, c):\n    if a + b > c and b + c > a and a + c > b:\n        hypotenuse = max(a, b, c)\n        if hypotenuse == a:\n            return a**2 == b**2 + c**2\n        elif hypotenuse == b:\n            return b**2 == a**2 + c**2\n        else:\n            return c**2 == a**2 + b**2\n    return False\n",
    "HumanEval/158": "def find_max(words):\n    unique_char_count = {}\n\n    for word in words:\n        unique_chars = set(word)\n        unique_char_count[word] = len(unique_chars)\n    \n    max_word = \"\"\n    max_count = 0\n\n    for word, count in unique_char_count.items():\n        if count > max_count or (count == max_count and word < max_word):\n            max_word = word\n            max_count = count\n\n    return max_word\n",
    "HumanEval/159": "def eat(number, need, remaining):\n    total_eaten = number + need\n    carrots_left = remaining - total_eaten\n    if carrots_left < 0:\n        carrots_left = 0\n    return [total_eaten, carrots_left]\n",
    "HumanEval/160": "def do_algebra(operator, operand):\n    result = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '+':\n            result += operand[i+1]\n        elif operator[i] == '-':\n            result -= operand[i+1]\n        elif operator[i] == '*':\n            result *= operand[i+1]\n        elif operator[i] == '//':\n            result //= operand[i+1]\n        elif operator[i] == '**':\n            result **= operand[i+1]\n    return result\n",
    "HumanEval/161": "def solve(s):\n    result = \"\"\n    \n    has_letters = any(char.isalpha() for char in s)\n    \n    for char in s:\n        if char.isalpha():\n            result += char.swapcase()\n        else:\n            result += char\n    \n    if not has_letters:\n        result = s[::-1]\n    \n    return result\n",
    "HumanEval/162": "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    \n    md5_hash = hashlib.md5(text.encode()).hexdigest()\n    return md5_hash\n",
    "HumanEval/163": "def generate_integers(a, b):\n    result = []\n    \n    for i in range(a, b+1):\n        if i % 2 == 0:\n            result.append(i)\n    \n    return result\n"
}